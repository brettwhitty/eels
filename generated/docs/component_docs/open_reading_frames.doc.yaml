---
# Ergatis Component Documentation
# Extracted from source by extract_component_docs.pl
# Source: TIGR/JCVI/IGS Ergatis bioinformatics workflow system
#
# This file preserves ALL documentation, comments, parameter descriptions,
# and structural details from the original Ergatis source files.

component: open_reading_frames
extracted_at: "2026-02-19T15:34:47"
source_files:
  - open_reading_frames.config
  - open_reading_frames.xml
  - open_reading_frames.i1.xml
  - component_docs/open_reading_frames.tmpl

# Component documentation (from Ergatis web UI help template)
component_documentation: |
  <p>
      Details on the implementation of the ORF finder script are found here. It should be 
      applicable to any input sequence files, but has been developed as the ORF finder for 
      processing the Global Ocean Survey data.
  </p>
  <h3>input</h3>
  <p>
      The input can any number of single or multi-sequence FASTA files.  Compressed input
      (via gzip) is natively supported.  A translation table can also be specified.
  </p>
  <h3>algorithm</h3>
  <ul>
      <li>The script scales to support input sequences in the GB range without prohibitive memory use.</li>
      <li>All six frames are scanned by default, with an optional --frames to specify a limited set. (eg, --frames=1,2,3)</li>
      <li>User-configurable --min_orf_size and --max_orf_size settings (default off).</li>
      <li>
          Intelligent translation using the codon table is employed. The codon CCN, for example, will code 
          for proline (P) regardless of the third position, so a P should be used in the translation instead 
          of X.
      </li>
      <li>
          Any codon that could be translated as a stop will be. TAN, for example, could be a stop codon (TAG) 
          or tyrosine (Y) but will be marked as a stop codon. This is the default behavior, but can turned off 
          by the user with --assume_stops=0.
      </li>
      <li>
          Partial codons at the end of an ORF resulting from the ends of the source sequence will treat the 
          missing bases as Ns for purposes of translation. Partial codons at the beginning of an ORF will be 
          ignored/excluded from translation.
      </li>
      <li>
          Option --beginning_as_start defaults to 1 and specifies whether the beginning of a sequence should 
          be treated as a start codon and the ORF marked as partial.
      </li>
      <li>
          Option --end_as_stop defaults to 1 and specifies whether the end of a sequence should be treated as 
          a stop codon and the ORF marked as partial.
      </li>
      <li>
          Option --full_orfs defaults to 0 and specifies whether ORFs span intervals from stop to stop, or start 
          to stop (all non-stops are treated as starts when --full_orfs=1)
      </li>
  </ul>
  <h3>output</h3>
  <p>
      The are many user-configurable options for the output files.  These include:
  </p>
  <ul>
      <li>Coordinates are reported using the zero inter-base standard.</li>
      <li>
          For each input file two output files are created, one for the nucleotide ORF and another for its 
          conceptual translation. The input file basename is used in the output file names. For example, if 
          foo.fasta is used as input foo.fna and foo.faa will be the two output files.
      </li>
      <li>The --gzip_output flag controls whether output sequence files will be gzipped (default=1).</li>
      <li>
          If --force_methionine option is used the initial amino acid in all translations will be M rather 
          than the actual amino acid specified by the translation table (default=0).
      </li>
      <li>ORF and translation output FASTA entries have headers as described in the HEADERS section below.</li>
      <li>Additional values can be passed to the headers like: --header_additions='foo=bar,ergatis_id=12345' </li>
  </ul>
  <h3>headers</h3>
  <p>
      An example of an ORF header:
  </p>
  <div class='code_container'>
     >JCVI_ORF_1105092286082 /pep_id=JCVI_PEP_1105092286083 /read_id=JCVI_READ_1098101644356
     /begin=473 /end=932 /orientation=-1 /5_prime_stop=TGA /3_prime_stop=TAG /ttable=11
     /ergatis_id=7720 /read_defline="/library_id=JCVI_LIB_MOVE858-H remaining defline here"
     
  </div>
  <p>
      The 'read_id' is the ID of the source read and 'begin' and 'end' are the coordinates of the prediction on that read. All coordinates are to be reported using the 0-based interbase coordinate system. The 'begin' coordinate should always be less than or equal to the 'end' coordinate, with the 'orientation' key providing the orientation with a value of 1 (forward) or -1 (reverse).
  </p>
  <p>
      The '5_prime_stop' and '3_prime_stop' keys have values of the actual codon characters unless the ORF is partial, in which case the appropriate keys will have a 0 value. The 'pep_id' is the ID generated for the conceptual translation, an example of which is below. The 'ttable' is the numerical value the translation table and the length of the polypeptide is provided with the 'length' value. Finally, the 'read_defline' value is the exact FASTA defline from the input read after read's ID.
  </p>
  <p>
      Once translated, the polypeptide FASTA header entry will look like this:
  </p>
  <div class='code_container'>
     >JCVI_PEP_1105092286083 /orf_id=JCVI_ORF_1105092286082 /read_id=JCVI_READ_1098101644356 
     /begin=473 /end=932 /orientation=-1 /5_prime_stop=TGA /3_prime_stop=TAG /ttable=11 /length=153 
     /ergatis_id=7720 /read_defline="/library_id=JCVI_LIB_MOVE858-H remaining defline here"
     
  </div>
  <p>
     The format is similar to the ORF entry, but some of the keys are different. The 'orf_id' key is a pointer to the ORF from which this translation is derived. The length is the length of the peptide sequence in amino acids. 
  </p>

# Configuration file - all sections, parameters, defaults, and inline comments
config:
  interface:
    classification: feature prediction / ORFs
  parameters:
    # integer value from the set (0-6, 9-16, 21-23), or path to EMBOSS format translation table file
    CODON_TABLE: 11
    # translation frames (1,2,3,4,5,6; F (1-3), R (4-6), or 0 for all)
    FRAMES: 0
    # minimum length of predicted orfs (0 = no limit)
    MIN_ORF_SIZE: 180
    # maximum length of predicted orfs (0 = no limit)
    MAX_ORF_SIZE: 0
    # minimum length of non-softmasked region of predicted orfs, if using softmasking (default = 150, disabled = 0)
    MIN_UNMASKED_SIZE: 150
    # treat beginning of read as a start codon
    BEGINNING_AS_START: 1
    # treat end of read as a stop codon
    END_AS_STOP: 1
    # assume stop codon wherever codon has an ambiguous base that could be translated as a stop
    ASSUME_STOPS: 0
    # predicted ORFs will be from start to stop (0) or from stop to stop (1)
    FULL_ORFS: 0
    # force first codon in predicted ORFs to be translated as methionine
    FORCE_METHIONINE: 0
    # comma delimited list of key=value pairs to be added to the fasta headers of the output sequence
    HEADER_ADDITIONS: ""
    # gzip output fasta files
    GZIP_OUTPUT: 1
  input:
    INPUT_FILE_LIST: ""
    INPUT_FILE: ""
    INPUT_DIRECTORY: ""
    # the following is only used when iterating over an INPUT_DIRECTORY
    INPUT_EXTENSION: fsa
  output:
    OUTPUT_TOKEN: default
    OUTPUT_DIRECTORY: $;REPOSITORY_ROOT$;/output_repository/$;COMPONENT_NAME$;/$;PIPELINEID$;_$;OUTPUT_TOKEN$;
    FNA_OUTPUT_LIST: $;OUTPUT_DIRECTORY$;/$;COMPONENT_NAME$;.fna.list
    FAA_OUTPUT_LIST: $;OUTPUT_DIRECTORY$;/$;COMPONENT_NAME$;.faa.list
  component:
    COMPONENT_NAME: open_reading_frames
    DESCRIPTION: none
    WORKFLOW_REPOSITORY: $;REPOSITORY_ROOT$;/workflow/runtime/$;COMPONENT_NAME$;/$;PIPELINEID$;_$;OUTPUT_TOKEN$;
    PIPELINE_TOKEN: unnamed
    # The version,revision,tag here is set by an interpolated CVS tag
    VERSION: $Name$
    RELEASE_TAG: $Name$
    REVISION: $Revision$
    TEMPLATE_XML: $;DOCS_DIR$;/$;COMPONENT_NAME$;.xml
    ITERATOR1: i1
    ITERATOR1_XML: $;DOCS_DIR$;/$;COMPONENT_NAME$;.$;ITERATOR1$;.xml
    # Distributed options
    GROUP_COUNT: 150
    NODISTRIB: 0
    # the following keys are replaced at runtime by the invocation script
    COMPONENT_CONFIG: ""
    COMPONENT_XML: ""
    PIPELINE_XML: ""
    PIPELINEID: ""
  include:
    PROJECT_CONFIG: ""

# Main workflow XML template - step definitions
workflow_xml:
  xml_comments:
    - Preprocessing
    - Processing
    - Iterator
    - Postprocessing
  command_sets:
    - open_reading_frames workflow
  includes:
    - "file=\"$;DOCS_DIR$;/file_iterator_template.xml\" keys=\"$;ITERATOR_NAME$;=ITERATOR1,$;ITERATOR_XML$;=ITERATOR1_XML\""
  steps:
    - name: create output directory
      type: RunUnixCommand
      executable: mkdir
      arg: -p -m 777 $;OUTPUT_DIRECTORY$;
    - name: create temp directory
      type: RunUnixCommand
      executable: mkdir
      arg: -p -m 777 $;TMP_DIR$;
    - name: create na fasta list
      type: RunUnixCommand
      executable: $;BIN_DIR$;/create_list_file
      params:
        - key: --directory
          value: $;OUTPUT_DIRECTORY$;
        - key: --regex
          value: "\".*\\.fna\""
        - key: --output_list
          value: $;FNA_OUTPUT_LIST$;
    - name: create aa fasta list
      type: RunUnixCommand
      executable: $;BIN_DIR$;/create_list_file
      params:
        - key: --directory
          value: $;OUTPUT_DIRECTORY$;
        - key: --regex
          value: "\".*\\.faa\""
        - key: --output_list
          value: $;FAA_OUTPUT_LIST$;

# Iterator i1 - per-input processing steps
iterator_i1:
  command_sets:
    - open_reading_frames compute
  steps:
    - name: open_reading_frames
      type: RunUnixCommand
      executable: $;BIN_DIR$;/open_reading_frames
      params:
        - key: --input_file
          value: $;I_FILE_PATH$;
        - key: --translation_table
          value: $;CODON_TABLE$;
        - key: --output_dir
          value: $;OUTPUT_DIRECTORY$;/$;ITERATOR_NAME$;/g$;GROUP_NUMBER$;
        - key: --gzip_output
          value: $;GZIP_OUTPUT$;
        - key: --beginning_as_start
          value: $;BEGINNING_AS_START$;
        - key: --end_as_stop
          value: $;END_AS_STOP$;
        - key: --assume_stops
          value: $;ASSUME_STOPS$;
        - key: --full_orfs
          value: $;FULL_ORFS$;
        - key: --min_orf_size
          value: $;MIN_ORF_SIZE$;
        - key: --max_orf_size
          value: $;MAX_ORF_SIZE$;
        - key: --min_unmasked_size
          value: $;MIN_UNMASKED_SIZE$;
        - key: --frames
          value: $;FRAMES$;
        - key: --force_methionine
          value: $;FORCE_METHIONINE$;
        - key: --header_additions
          value: "'$;HEADER_ADDITIONS$;'"

# Perl script documentation (POD)
perl_scripts:
  - script: create_list_file.pl
    pod: |
  =head1	NAME
  
  create_list_file.pl - script to create a list of files given a certain regex
  
  =head1	SYNOPSIS
  
  USAGE: create_list_file.pl
         [  --directory|d=/path/to/some/directory/
            --output_list|o=/path/output.list
            --regex|r=string regular expression
            --include_gz|g ]
  
  =head1	OPTIONS
  
  B<--directory,-d>
  	Location of the directory to search.  No wild card characters should be
      used in the directory.
      (Default: current directory)
  
  B<--output_list,-o>
      File that will be the list of found files
      (Default: standard out)
  
  B<--regex,-r>
      Regular expression for entire file name (including full path)
      (Default: finds all files)
  
  B<--include_gz|g>
      This flag tells the script to include .gz extensions in the list
  
  B<--help,-h>
  	Prints this help message
  
  =head1	DESCRIPTION
  
      This script will search a directory for file names containing the given
      regular expression.  By default, all .gz or .gzip extensions are stripped
      off.  Programs using these list files should know to search for .gz|.gzip
      versions.
  
      **Note: No wild card characters should be used in this option.
  
  =head1	INPUT
  
      There are no required options to the script and there isn't really any
      input.  See above for defaults.  
  
  =head1	OUTPUT
  
      The script will output a list of files that match the regular expression
      given by option --regex|-r. If no output file is given, this script will 
      print out to standard out.  
  
  =head1	CONTACT
  
      Kevin Galens
      kgalens@tigr.org
  - script: open_reading_frames.pl
    pod: |
  =head1 NAME
  
  open_reading_frames.pl - orf finding script for GOS sequence data
  
  =head1 SYNOPSIS
  
  USAGE: open_reading_frames.pl 
              --input_file=/path/to/some_file.fsa || --stdin
              --translation_table=11
            [ --output_dir=/some/dir
              --gzip_output=1
              --beginning_as_start=1
              --end_as_stop=1
              --assume_stops=0 
              --full_orfs=0
              --min_orf_size=180
              --max_orf_size=9999
              --min_unmasked_size=150
              --frames=1,2,3,4,5,6
              --force_methionine=0
              --header_additions='foo=bar,ergatis_id=12345'
              --unknown_aa=X
            ]
  
  =head1 OPTIONS
  
  B<--input_file,-i>
      Provide full path to fasta format sequence file (may contain multiple records).
      Alternatively, input can be accepted from STDIN using --stdin flag.
  
  B<--stdin>
      Optional. Instead of providing --input_file, fasta file input can be read from
  
  B<--output_dir>
      Optional. Directory to write output sequence files to. (default=.)
  
  B<--gzip_output>
      Optional. Compress output sequence files using gzip.
      
  B<--translation_table,-t>
      Translation table to use for ORF finding and amino acid translations.
      Provide an integer value specifying a script-supported translation table from
      the following set: (0-6, 9-16, 21-23), or provide the full path to an EMBOSS
      formatted translation table file.
      STDIN using this flag.
  
  B<--frames>
      Optional. Translation frames for which to output ORFs. Values can be:
      'F' (forward frames, 1-3), 'R' (reverse frames, 4-6), a comma-delimited string 
      composed of integer values 1-6 such as '1,4,5,6', or '0' for all six frames (default).
  
  B<--id_prefix>
      Optional.  A string to prepend to the beginning of all generated identifiers.  Attached
      to this will be either '.pep.$n' or '.orf.$n', where $n is a sequential integer.
      (default = '')   
  
  B<--beginning_as_start>
      Optional. Treat the beginning of the sequence as a start codon and mark ORFs as partial.
      (default = 1)
  
  B<--force_methionine>
      Optional. Force translation of first codon in any ORF as 'M'.
      
  B<--full_orfs>
      Optional. Predicts ORFs from stop codon to stop codon, without requiring start codons.
      
  B<--end_as_stop>
      Optional. Treat the end of the sequence as a stop codon and mark ORFs as partial.
      (default = 1)
  
  B<--assume_stops>
      Optional. Any codon that could be translated as a stop should be. 
      Eg: TAN could be a stop codon (TAG) or tyrosine (Y) but should be marked as a stop codon.
      (default = 1)
     
  B<--min_orf_size>
      Optional. Set the minimum size of ORFs to output. (default = 180)
   
  B<--max_orf_size>
      Optional. Set the maximum size of ORFs to output. (default = 999999999)
  
  B<--min_unmasked_size>
      Optional. The minimum number of non-softmasked bases and ORF must contain to be valid. (default = 150)
      
  B<--unknown_aa>
      Optional. Character to use for aa translation of ambiguous or partial non-degenerate codons. (default = 'X')
      
  B<--debug> 
      Debug level.  Use a large number to turn on verbose debugging. 
  
  B<--log,-l> 
      Log file
  
  B<--help,-h>
      This help message
  
  =head1  DESCRIPTION
  
  This script is a re-implementation of Doug Rusch's GOS ORF finding script.
  
  =head1  INPUT
  
  Input should be cleaned na sequence reads.
  
  =head1  OUTPUT
  
  Output will be na and aa sequence of predicted ORFs. Two output files will be created:
      INPUT_FILE_NAME_BASE.fna[.gz]
      INPUT_FILE_NAME_BASE.faa[.gz]
  
  =head1  CONTACT
  
      Brett Whitty
      bwhitty@tigr.org
