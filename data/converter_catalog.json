{
  "generated": "2026-02-18",
  "source": "/home/brett/work.local/ergatis-eels-devel/ergatis-git/src/perl",
  "converter_count": 67,
  "converters": [
    {
      "tool": "MSF_domain",
      "converter_script": "MSF_domain2bsml.pl",
      "name": "MSF_domain2bsml.pl  - convert MSF format alignment files into BSML documents",
      "synopsis": "USAGE:  MSF_domain2bsml.pl -a ali_dir -o msf.bsml",
      "description": "MSF_domain2bsml.pl is designed to convert multiple sequence alignments in MSF format\ninto BSML documents.  More specifically this script is equippd to parse the multiple \nsequence alignments of domains.  This requires the capture of the start and end \ncoordinates of each \"subsequence\" in the alignment.  As an option, the user can\nspecify the suffix of the alignment files that the script should parse in the \ndirectory specified by --ali_dir.  The default suffix is \"msf\" i.e. family.msf.\nIn addition, the user can specify what program this script is for.  For example if the\nmultiple sequence alignment represents COGS, the user can specify that\nwith the --program flag.  This will be reflected in the analysis object\nof the BSML document.\n\nSamples:\n\n1. Convert all MFS formatted files that end in \"aln\" in ali_dir\n   MSF_domain2bsml.pl -a ali_dir -o alignment.bsml -s aln\n\n\nNOTE:  \n\nCalling the script name with NO flags/options or --help will display the syntax requirement.\n\n\n=cut\n\n\nuse strict;\nuse Getopt::Long qw(:config no_ignore_case no_auto_abbrev);\nBEGIN {\nuse BSML::BsmlBuilder;\n}\nuse File::Basename;\nuse Pod::Usage;\n\n\nmy %options = ();\nmy $results = GetOptions (\\%options, 'ali_dir|a=s', 'output|o=s', 'program|p=s', \n                                     'verbose|v', 'suffix|s=s', 'help|h', 'man') || pod2usage();\n\n###-------------PROCESSING COMMAND LINE OPTIONS-------------###\n\nmy $output    = $options{'output'};\nmy $ali_dir   = $options{'ali_dir'};\n$ali_dir =~ s/\\/+$// if($ali_dir);\nmy $msf_suffix = $options{'suffix'} || \"msf\";  #default suffix pattern of alignment files\nmy $program   = $options{'program'} || \"clustal\";\n\n&cmd_check();\n###-------------------------------------------------------###\n\nmy $builder = new BSML::BsmlBuilder;\n\n# add an analysis object to the document. \nmy $filename = basename($output);\n$builder->createAndAddAnalysis( 'sourcename' => $filename,\n\t\t\t\t'programversion' => '1.0',\n\t\t\t\t'program' => $program,\n\t\t\t\t'bsml_link_url' => 'BsmlTables',\n\t\t\t\t'bsml_link_relation' => 'MULTIPLE_ALIGNMENTS' );\n\nmy $file_found = 0;\nmy $id=0;\nopendir(DIR, $ali_dir) or die \"Unable to access $ali_dir due to $!\";\nwhile( my $file = readdir(DIR)) {\n    next if ($file =~ /^\\.{1,2}$/);  #skip  \".\" ,  \"..\"\n    if($file =~ /^(.+?)(\\.msf\\.dtab)?\\.$msf_suffix$/) {\n\t$file_found++;\n\tmy $accession = undef;\n\tmy $domain_id = \"domain_\";\n\tif($file =~ /^(PF\\d{5})\\.$msf_suffix$/ || $file =~ /^(TIGR\\d{5})\\.$msf_suffix$/) { \n\t    $accession = $1;\n\t    $domain_id .= $accession;\n\t} else {\n\t    #my $fam_name = $1;\n\t    $id++;\n\t    $domain_id .= $id\n\t}\n\tmy $MSF_alignments = process_MSF_file(\"$ali_dir/$file\");\n\tif(keys %$MSF_alignments < 1) {  #skip empty msf files\n\t    #this checks to see if the previous domain_id is from $id++ or $accession\n            #and will subtract 1 from $id if previous domain_id is from $id++\n\t    if(!defined($accession)) { \n\t\t$id--;\n            }\n\t    next;\n\t}\n\n\tmy $table = $builder->createAndAddMultipleAlignmentTable('molecule-type' => $MSF_alignments->{'mol_type'},\n                                                             'class'         => 'match');\n\t$table->addattr( 'id', $domain_id );\n\n\tmy $summary = $builder->createAndAddAlignmentSummary( 'multipleAlignmentTable' => $table,\n\t\t\t\t\t\t\t      'seq-type' =>  $MSF_alignments->{'mol_type'},\n\t\t\t\t\t\t\t      'seq-format' => 'MSF' \n\t\t\t\t\t\t\t      );\n\tmy $aln = $builder->createAndAddSequenceAlignment( 'multipleAlignmentTable' => $table );\n\tmy $seqnum=0;\n\tmy $sequences_tag;\n\tforeach my $seq (keys %{ $MSF_alignments->{'polypeptides'} }) {\n\t    $seqnum++;\n\t    my ($pro_acc, $coords) = split(/\\//, $seq);\n\t    $pro_acc =~ s/\\|\\|$//;                         #remove terminal '||' if exists\n\t    my $alignment = join ('', @{ $MSF_alignments->{'polypeptides'}->{$seq}->{'alignment'} });\n\t    my $start  = $MSF_alignments->{'polypeptides'}->{$seq}->{'end5'}; \n\t    my $end    = $MSF_alignments->{'polypeptides'}->{$seq}->{'end3'};\n\t    my $domain_length = $end - $start + 1;\n\t    #IMPORTANT!!!!\n\t    #In order to ensure that each seq in a multiple sequence alignment is truly\n            #unique, the seq-name and name will be in the form \"polypeptide_accession:seqnum\"\n            #i.e. (ana1.10005.m00234_polypeptide:1). \n\n\t    $builder->createAndAddAlignedSequence( 'alignmentSummary' => $summary,\n\t\t\t\t\t\t   'seqnum' => $seqnum,\n\t\t\t\t\t\t   'length' => $domain_length,\n\t\t\t\t\t\t   'name'   => \"$pro_acc:$seqnum\", #<--see notes above\n                                                   'start'  => $start\n                                                 );\n\t    $builder->createAndAddSequenceData( 'sequenceAlignment' => $aln,\n\t\t\t\t\t\t'seq-name' => \"$pro_acc:$seqnum\",  #<--see notes above\n\t\t\t\t\t\t'seq-data' => $alignment\n                                              );\n\t    $sequences_tag .= \"$seqnum:\";\n\t}\n\t$aln->addattr( 'sequences', $sequences_tag );\n\n    }\n\n}\nif($file_found) {\n    $builder->write( $output );\n    chmod 0777, $output;\n} else {\n    print STDERR \"No files that ends in \\\"$msf_suffix\\\" are found in $ali_dir\\n\";\n}\n\n\n\n\n\nsub process_MSF_file {\n\n    my $file = shift;\n\n\n    my $MSF_alignments ={};\n    open(MSF, \"$file\") or die \"Unable to open $file due to $!\";\n    my $line;\n    my $msf_type;\n    while(defined($line = <MSF>) and $line !~ /^\\/\\//) {\n\tif( $line =~ /MSF:\\s*([\\S]+)\\s*Type:\\s*([\\S]+)\\s*Check/) {\n\t    my $msf_length = $1;\n\t    return undef if($msf_length == 0);  #abort if align_len = 0\n\n\t    if($2 eq 'P') {\n\t\t$msf_type = 'polypeptide';\n\t    }elsif($2 eq 'N') {\n\t\t$msf_type = 'nucleotide';\n\t    }else {\n\t\t$msf_type = 'polypeptide';\n\t    }\n\t    $MSF_alignments->{'mol_type'} = $msf_type;\n\t}\n\n\tif($line =~ /Name:\\s*([\\S]+)\\s*Len:\\s*([\\S]+)\\s*Check:\\s*([\\S]+)\\s*Weight:\\s*([\\S]+)/) {\n\t    my $name    = $1;\n\t    my $name2   = $name;\n\t    my $ali_len = $2;\n\t    my $check   = $3;\n\t    my $weight  = $4;\n\t    my ($polypeptide, $coord) = split(/\\//, $name);\n\t    my ($start5, $end3) = split(\"-\", $coord);\n\t    \n\t    $MSF_alignments->{'polypeptides'}->{$name}->{'length'} = $ali_len;\n\t    $MSF_alignments->{'polypeptides'}->{$name}->{'check'}  = $check;\n\t    $MSF_alignments->{'polypeptides'}->{$name}->{'weight'} = $weight;\n\t    $MSF_alignments->{'polypeptides'}->{$name}->{'end5'}   = $start5;\n\t    $MSF_alignments->{'polypeptides'}->{$name}->{'end3'}   = $end3;\n\t    $MSF_alignments->{'polypeptides'}->{$name}->{'alignment'} = [];\n\t}\n    }\n\n    my $replacements;\n    my $spaces;\n    while($line = <MSF>) {\n\tif($line =~ /^([\\S]+)/) {\n\t    my $name = $1;\n\t    my $name2  = $name;\n\t    if($name =~ /(\\/.+)/) {\n\t\t$replacements = $1;\n\t\t$spaces = \" \" x length($replacements);\n\t\t$line =~ s/$replacements/$spaces/;\n\t\t$name =~ s/$replacements//g;\n\t    }\n\t    if(exists($MSF_alignments->{'polypeptides'}->{$name2})) {\n\t\tpush( @{ $MSF_alignments->{'polypeptides'}->{$name2}->{'alignment'} }, $line );\n            } else {\n\t\tprint STDERR \"ERROR, $name is not valid polypeptide name\\n\";\n            }\n\t}\n    }\n\n    return $MSF_alignments;\n\n}\n\t\n\t\nsub cmd_check {\n#quality check\n\n    if( exists($options{'man'})) {\n\tpod2usage({-exitval => 1, -verbose => 2, -output => \\*STDOUT});\n    }   \n\n    if( exists($options{'help'})) {\n\tpod2usage({-exitval => 1, -verbose => 1, -output => \\*STDOUT});\n    }\n\n    if(!$output or !$ali_dir) {\n\tpod2usage({-exitval => 2,  -message => \"$0: All the required options are not specified\", -verbose => 1, -output => \\*STDERR});\n    }\n    \n    if(! -d $ali_dir) {\n\tprint STDERR \"$ali_dir directory NOT found.  Aborting...\\n\";\n\texit 5;\n    }\n\n}",
      "options": {},
      "contact": null
    },
    {
      "tool": "analysis",
      "converter_script": "analysis2bsml.pl",
      "name": "analysis2bsml.pl - add analysis parameters to a BSML result doc",
      "synopsis": "USAGE:  analysis2bsml.pl --bsml_file=/path/to/some/output.bsml \n                             --conf=/path/to/some/pipeline.config\n                           [ --ergatis_control_file=/path/to/ergatis_install.ini ]\n                           [ --componenturl=/path/to/some/pipeline.xml ]\n                           [ --pipelineurl=/path/to/some/pipeline0.xml ]\n                           [ --debug debug_level  ]\n                           [ --log log_file ]\n                           [ --analysis_id=some_id ]",
      "description": "This script is used to record the parameters of an analysis into the BSML file that the\nanalysis created.  This is done to ensure that each of the run-time settings for the\nanalysis are recorded for informational purposes or to re-run the analysis.\n\n=cut\n\n\nuse strict;\nuse Getopt::Long qw(:config no_ignore_case no_auto_abbrev);\nuse Pod::Usage;\nuse File::Basename;\nuse Ergatis::Logger;\nuse XML::Twig;\nuse Config::IniFiles;\n\nmy %options = ();\nmy $results = GetOptions (\\%options,\n              'analysis_id|a=s',\n\t\t\t  'bsml_file|b=s',\n\t\t\t  'conf|c=s',\n\t\t\t  'log|l=s',\n\t\t\t  'debug=s',\n\t\t\t  'ergatis_control_file|e=s',\n\t\t\t  'componenturl|u=s',\n\t\t\t  'pipelineurl|p=s',\n\t\t\t  'help|h') || pod2usage();\n\nmy $logfile = $options{'log'} || Ergatis::Logger::get_default_logfilename();\nmy $logger = new Ergatis::Logger('LOG_FILE'=>$logfile,\n\t\t\t\t  'LOG_LEVEL'=>$options{'debug'});\n$logger = Ergatis::Logger::get_logger();\n\n# display documentation\nif( $options{'help'} ){\n    pod2usage( {-exitval=>0, -verbose => 2, -output => \\*STDERR} );\n}\n\n&check_parameters(\\%options);\n\n## build the Twig.  this will toggle the $research_found below if it works\nmy $research_found = 0;\nmy $research_text = '';\nmy $twig = XML::Twig->new(\n                            twig_roots => { 'Research' => \\&process_research },\n                            pretty_print => 'indented',\n                         );\n\nmy $fh;\nif (-e $options{'bsml_file'} && $options{'bsml_file'} !~ /\\.gz$/){\n    print \"Opening regular file\\n\";\n    open ($fh, $options{'bsml_file'}) or $logger->logdie(\"Could not open file '$options{'bsml_file'}: $!\");\n}\nelse{\n    if ($options{'bsml_file'} !~ /\\.gz$/ && -e $options{'bsml_file'}.\".gz\"){\n\t$options{'bsml_file'} .= \".gz\";\n    }\n    if($options{'bsml_file'} =~ /\\.gz$/ && -e $options{'bsml_file'}){\n\tprint \"Opening gzip file\\n\";\n\topen ($fh, \"<:gzip\", $options{'bsml_file'}) || $logger->logdie(\"Could not open zipped file '$options{'bsml_file'}': $!\");\n    }\n    else{\n\t$logger->logdie(\"Could not open file '$options{'bsml_file'}: $!\");\n    }\n}\n\n$twig->parse( $fh );\n\nclose $fh;\n\n## if no Research element was found, build one\nif (! $research_found) {\n    undef $twig;  ## might as well\n\n    my $research = XML::Twig::Elt->new('Research');\n    my $analyses = XML::Twig::Elt->new('Analyses');\n    my $analysis = XML::Twig::Elt->new('Analysis');\n    \n    ## add an ID on analysis if it was passed\n    if ( defined($options{'analysis_id'}) ) {\n        $analysis->set_att('id', $options{'analysis_id'});\n    }\n    \n    ## add the Attributes to the Analysis element\n    &add_config_params($analysis);\n   \n\t## add software version attributes to the Analysis element\n\tadd_software_versions($analysis);\n   \t\n    ## build them together\n    $analysis->paste('last_child', $analyses);\n    $analyses->paste('last_child', $research);\n    \n    $research_text = tabbed(\\$research->sprint, 1, 2);\n}\n\n\n## open the input file.  if a Research element exists, replace it, else just add it\n##  before the closing Bsml tag.  because you can't read and write to the same stream,\n##  we'll have to write to a temp file and then move it over the original.\nmy $ifh;\nmy $ofh;\nif($options{'bsml_file'} =~ /\\.gz$/){\n    print \"Read/write zip file\\n\";\n    open ($ifh, \"<:gzip\", $options{'bsml_file'}) || $logger->logdie(\"can't read input BSML file\");\n    open ($ofh, \">:gzip\", \"$options{'bsml_file'}.part\") || $logger->logdie(\"can't write output BSML file\");\n}\nelse{\n    open ($ifh, \"<$options{'bsml_file'}\") || $logger->logdie(\"can't read input BSML file\");\n    open ($ofh, \">$options{'bsml_file'}.part\") || $logger->logdie(\"can't write output BSML file\");\n}\nmy $replace_mode = 0;\nmy $research_not_found = 1;\n\n## loop through the file\nfor (<$ifh>) {\n   \n    if (m|<Research>|) {\n        $replace_mode = 1;\n        $research_not_found = 0;\n        print $ofh \"$research_text\\n\";\n        \n    } elsif (m|</Research>|) {\n        $replace_mode = 0;\n    \n    } elsif (m|</Bsml>| && $research_not_found) {\n        ## if you hit a </Bsml> and never found <Research>, print the Research\n        ##  text before the closing </Bsml>\n        print $ofh \"$research_text\\n\";\n        print $ofh $_;\n        \n    } elsif (! $replace_mode) {\n        print $ofh $_;\n    }\n}\n\n## close your files, then move the .part over the original\nclose $ifh;\nclose $ofh;\nsystem(\"mv $options{'bsml_file'}.part $options{'bsml_file'}\") && $logger->logdie(\"failed to move temporary .part file over source\");\n\n\nsub tabbed {\n    my ($txtref, $tablevels, $tabspacing) = @_;\n    my @txt = split(\"\\n\", $$txtref);\n    my $result = '';\n    \n    for (@txt) {\n        $result .= (' ' x ($tablevels * $tabspacing)) . \"$_\\n\";\n    }\n    \n    return $result;\n}\n\nsub process_research {\n    my ($twig, $research) = @_;\n    \n    $research_found = 1;\n    my $analyses_not_found = 0;\n    my $analysis_not_found = 1;\n    \n    ## grab the Analyses element, if there was one\n    my $analyses = $research->first_child('Analyses');\n    \n    ## if there wasn't an Analyses element, create one\n    if (! $analyses) {\n        $analyses = XML::Twig::Elt->new('Analyses');\n        $analyses_not_found = 1;\n    }elsif(! defined($options{'analysis_id'}) ) {\n\t    my $analysis = $analyses->first_child('Analysis');\n\t    if($analysis){\n\t        $options{'analysis_id'} = $analysis->att('id');\n\t    }\n    }\n    \n    ## does Analyses contain any Analysis elements?\n    my $analysis;\n    if ( $analyses->children_count('Analysis') ) {\n        \n        ## do any of them match the id we were looking for?\n        for ( $analyses->children('Analysis') ) {\n            if ( $options{analysis_id} eq 'first' ) {\n                $analysis = $_;\n                $analysis_not_found = 0;\n                last;            \n            }\n        \n            if ( $_->att('id') eq $options{'analysis_id'} ) {\n                $analysis = $_;\n                $analysis_not_found = 0;\n                last;\n            }\n        }\n    }\n    \n    ## add an Analysis element if we didn't find the one we were looking for\n    if ($analysis_not_found) {\n        $analysis = XML::Twig::Elt->new('Analysis');\n        \n        if ( defined($options{'analysis_id'}) ) {\n            $analysis->set_att('id', $options{'analysis_id'});\n        }\n    }\n\n    ## make sure the sourcename is only the path to the output directory, not the output file itself.\n    for my $attribute ( $analysis->children('Attribute') ) {\n        if ( $attribute->att('name') eq 'sourcename' ) {\n            $attribute->set_att('content',dirname(dirname($attribute->att('content'))));\n            last;\n        }\n    }\n    \n    ## add the Attributes to the Analysis element\n    &add_config_params($analysis);\n   \n\tif (defined($options{'ergatis_control_file'})) {\n\t\t## add software version attributes to the Analysis element\n\t\tadd_software_versions($analysis);\n\t}\n    \n    ## add the analysis element to the Analyses element\n    $analysis->paste('last_child', $analyses) if ($analysis_not_found);\n    \n    ## add the analyses element to the Research element\n    $analyses->paste('last_child', $research) if ($analyses_not_found);\n    \n    ## save the text of the Research element\n    $research_text = $research->sprint;\n\n}\n\nsub add_config_params {\n    my $analysis = shift;\n    \n    my $cfg = new Config::IniFiles( -file => $options{'conf'});\n    my @sections = $cfg->Sections();\n    \n    for my $section (@sections) {\n        my @parameters = $cfg->Parameters($section);\n        \n        for my $param (@parameters) {\n\t        my $value = $cfg->val($section,$param);\n\n\t        $param =~ s/\\$;//g;\n\t        $param = lc($param);\n\t        \n            if($value ne \"\"){\n                ## create the new Attribute\n                my $attribute = XML::Twig::Elt->new('Attribute');\n                $attribute->set_att('name', $param);\n                $attribute->set_att('content', $value);\n                \n                ## add it to the Analysis\n\t            $attribute->paste('last_child', $analysis);\n\t        }\n        }\n    }\n    \n    for my $at ( 'componenturl', 'pipelineurl' ) {\n        if ( defined($options{$at}) ){\n            my $attribute = XML::Twig::Elt->new('Attribute');\n            $attribute->set_att( 'name', $at );\n            $attribute->set_att( 'content', $options{$at} );\n            $attribute->paste('last_child', $analysis);\n        }\n    }\n}\n\n\nsub add_software_versions {\n    my $analysis = shift;\n\n    ## this is optional for now.  don't die if the file doesn't exist.  this is only appropriate\n    ##  when an organization is doing the same sort of software version tracking as we are.  This\n    ##  see bug: http://sourceforge.net/tracker/index.php?func=detail&aid=1831859&group_id=148765&atid=772583\n    if (! -e $options{'ergatis_control_file'} ) {\n        return;\n    }\n    \n\tmy %software_version = ();\n\tmy %tag_onto = (\n\t\t\t\t\t'prok_prism' \t=> 'prok_prism_version',\n\t\t\t\t\t'coati' \t\t=> 'coati_version',\n\t\t\t\t\t'euk_prism' \t=> 'euk_prism_version',\n\t\t\t\t\t'chado_prism' \t=> 'chado_prism_version',\n\t\t\t\t\t'shared_prism' \t=> 'shared_prism_version',\n\t\t\t\t\t'bsml' \t\t\t=> 'bsml_version',\n\t\t\t\t\t'ergatis' \t\t=> 'ergatis_version',\n\t\t\t\t\t'ontologies' \t=> 'ontologies_version',\n\t\t\t\t\t'chado_schema' \t=> 'chado_schema_version',\n\t\t\t\t\t'cvdata' \t\t=> 'cvdata_version',\n\t\t\t\t\t'peffect'\t\t=> 'peffect_version',\n\t\t\t\t\t'server' \t\t=> 'database_server_name',\n\t\t\t\t   );\n\n\topen (IN, $options{'ergatis_control_file'}) \n\t\t|| $logger->logdie(\"Could not open $options{ergatis_control_file} for reading\"); \n\n\twhile (<IN>) {\n\t\tchomp;\n\t\ts/\\s+//g;\n\t\tif ($_ eq '' || /^#/) {next;}\n\t\tmy ($tag, $version) = split('=');\n\t\tif (!defined($tag_onto{$tag})) {\n\t\t\t$logger->logdie(\"No ontology term defined for software tag '$tag'.\");\n\t\t}\n\t\tif ($version eq '') {\n\t\t\t$logger->logdie(\"Software version string for tag '$tag' is empty. Check control file for errors.\");\n\t\t}\n\t\t$software_version{$tag_onto{$tag}} = $version;\n\t}\n\n    foreach my $name(keys(%software_version)) {\n\t\tmy $content = $software_version{$name};\n\n        ## create the new Attribute\n        my $attribute = XML::Twig::Elt->new('Attribute');\n        $attribute->set_att('name', $name);\n        $attribute->set_att('content', $content);\n            \n        ## add it to the Analysis\n\t    $attribute->paste('last_child', $analysis);\n\t}\n}\n\nsub check_parameters{\n    my ($options) = @_;\n    \n    if(! -e $options{'bsml_file'} && ! -e $options{'bsml_file'}.\".gz\"){\n\tpod2usage({-exitval => 2,  -message => \"Can't read bsml file $options{'bsml_file'} or $options{'bsml_file'}.gz\", -verbose => 1, -output => \\*STDERR});    \n    }\n    if(! -e $options{'conf'}){\n\tpod2usage({-exitval => 2,  -message => \"Can't read conf file $options{'conf'}\", -verbose => 1, -output => \\*STDERR});    \n    }\n    \n    ## this is optional for now.  don't die if the file doesn't exist.  this is only appropriate\n    ##  when an organization is doing the same sort of software version tracking as we are.  This\n    ##  see bug: http://sourceforge.net/tracker/index.php?func=detail&aid=1831859&group_id=148765&atid=772583\n#    if(defined $options{ergatis_control_file} && ! -e $options{'ergatis_control_file'}){\n#\t\tpod2usage({-exitval => 2,  -message => \"Can't read ergatis install control file $options{'ergatis_control_file'}\", -verbose => 1, -output => \\*STDERR});    \n#\t}\n}",
      "options": {},
      "contact": null
    },
    {
      "tool": "antigenic",
      "converter_script": "antigenic2bsml.pl",
      "name": "antigenic2bsml.pl - convert ANTIGENIC output to BSML",
      "synopsis": "USAGE: antigenic2bsml.pl --input=/path/to/antigenic_file --output=/path/to/output.bsml --project=aa1 --input=/path/to/antigenic/input.fsa --compress_bsml_output=0",
      "description": "This script is used to convert the output from ANTIGENIC into BSML.",
      "options": {
        "input": "The fasta file used as input to the antigenic run.",
        "project": "[OPTIONAL]\n    The project (used for id making).\n    Default: unknown",
        "compress_bsml_output": "Will create gzipped output",
        "id_repository": "Required for creating feature identifiers.  Each project should have\n    its own id_repository directory - use the full path to it here.  This\n    is used by the IdGenerator.pm module.",
        "debug": "Debug level.  Use a large number to turn on verbose debugging.",
        "log": "Log file",
        "output": "Output BSML file (will be created, must not exist)",
        "help": "This help message"
      },
      "contact": "David Riley driley@som.umaryland.edu =cut use strict; use Log::Log4perl qw(get_logger); use Getopt::Long qw(:config no_ignore_case no_auto_abbrev); use BSML::BsmlBuilder; use BSML::BsmlParserTwig; use BSML::BsmlRepository; use Ergatis::IdGenerator; use Pod::Usage; use Ergatis::Logger; my %options = (); my $results = GetOptions (\\%options, 'input|i=s', 'output|o=s', 'debug|d=s', 'id_repository|r=s', 'input=s', 'compress_bsml_output=s', 'project|p=s', 'log|l=s', 'help|h') || pod2usage(); my $logfile = $options{'log'} || Ergatis::Logger::get_default_logfilename(); my $logger = new Ergatis::Logger('LOG_FILE'=>$logfile, 'LOG_LEVEL'=>$options{'debug'}); $logger = $logger->get_logger(); # display documentation if( $options{'help'} ){ pod2usage( {-exitval=>0, -verbose => 2, -output => \\*STDOUT} ); } my $defline; my $fastaFile; my $gzip = 0; ## make sure all passed options are peachy &check_parameters(\\%options); ## we want to create ids unique to this document, which will be replaced later. they must ## contain the prefix that will be used to look up a real id, such as ath1.gen.15 my $next_id = 1; ## we want a new doc my $doc = new BSML::BsmlBuilder(); ## we're going to generate ids my $idgen = Ergatis::IdGenerator->new( id_repository => $options{id_repository} ); ## open the input file for parsing (even if it's gziped (bug 2591)) my $mode = \"<\"; $mode .= \":gzip\" if($options{'input'} =~ /.gz$/); open (my $ifh, $mode, $options{'input'}) || $logger->logdie(\"can't open input file for reading\"); my @sequence_ids; my %result_ref_hash; #my $temp; my %property_hash; my $epitope_hash; my %qualifier_hash; my $skip_flag = 0; my $in_epitope = 0; my $start = 0; my $end = 0; my $strand; my $score; my $seq_name = ''; my $seq_name_to_feat_table; #my $line; while (<$ifh>) { if(/Name:\\s(\\S+)/) { $seq_name=$1; } elsif(/Start:\\s(\\S+)/) { $start=$1; } elsif(/End:\\s(\\S+)/) { $end = $1; } elsif(/Strand:\\s(\\S+)/) { $strand=$1; } elsif(/Score:\\s(\\S+)/) { $score=$1; } elsif(/Max_score_pos:\\s(\\S+)/) { my $seq; if( !( $seq = $doc->returnBsmlSequenceByIDR($seq_name)) ){ $seq = $doc->createAndAddSequence($seq_name, $seq_name, undef, 'aa', 'polypeptide'); $doc->createAndAddBsmlAttribute( $seq, 'defline', $defline); # $doc->createAndAddSeqDataImport( $seq, 'fasta', $options{input}, \"sdi_\" . $s . '_seq', $s ); $seq->addBsmlLink('analysis', '#antigenic_analysis', 'input_of'); $seq_name_to_feat_table->{$seq_name} = $doc->createAndAddFeatureTable($seq); } my $project = $options{'project'}; if($seq_name =~ /^([^\\.]+)\\./ && ($options{'project'} eq 'unknown')) { $project = $1; } my $feature_table = $seq_name_to_feat_table->{$seq_name}; my $ep = $doc->createAndAddFeature( $feature_table, $idgen->next_id( project => $project, type => 'epitope'), 'epitope', 'epitope'); $ep->addBsmlLink('analysis', '#antigenic_analysis', 'computed_by'); $ep->addBsmlIntervalLoc( $start, $end, $strand); } } my $analysis = $doc->createAndAddAnalysis( id => 'antigenic_analysis', sourcename => $options{'output'}, program => 'antigenic', algorithm => 'antigenic', ); $doc->write($options{'output'},,$gzip); exit; sub check_parameters { ## required params my @required = qw( input output id_repository ); for ( @required ) { if (! defined $options{$_}) { $logger->logdie( \"$_ is a required option\" ); } } ## make sure input file exists if (! -e $options{'input'}) { unless(-e $options{'input'}.\".gz\") { $options{'input'}.=\".gz\"; } else { pod2usage({-message => \"Input file '$options{'input'}' does not exist!\"}); } } ## in case they want to compress the bsml output (bug 2591) if($options{'compress_bsml_output'}) { $gzip = 1; } $options{'project'} = 'unknown' unless ($options{'project'}); $options{'command_id'} = '0' unless ($options{'command_id'}); return 1; } ## parse_position parses the position field to give an array containing ## start [and stop] sites sub parse_position { my ($position) = @_; if ($position =~ /^\\s*([^\\s]+)\\s*$/) { return split(\"-\", $1); } else { return (); } }"
    },
    {
      "tool": "aragorn",
      "converter_script": "aragorn2bsml.pl",
      "name": "aragorn2bsml.pl - Creates a bsml document from aragorn raw\n    output",
      "synopsis": "USAGE: aragorn2bsml.pl\n            --input_file=/path/to/some/aragorn.raw\n            --output=/path/to/aragorn.bsml\n            --id_repository=/path/to/id_repository\n            --fasta_input=/path/to/input.fsa\n          [ --project=aa1\n            --compress_output=1\n            --log=/path/to/file.log\n            --debug=4\n            --help\n          ]",
      "description": "This script is used to converts aragorns tab-delimited output into BSML.",
      "options": {
        "input_file": "[REQUIRED] Raw output generated by aragorn using the -w option",
        "output": "[REQUIRED] The output bsml file.",
        "id_repository": "[REQUIRED] Id repository for use by Ergatis::IdGenerator.pm",
        "fasta_input": "[REQUIRED] The input file that was used as input for the glimmer3 run",
        "compress_output": "[OPTIONAL] The output file will be compressed for any non-zero value (gzip)",
        "project": "[OPTIONAL] Project name (used in id generation).  Can also use the token 'parse'.  \n    aragorn2bsml.pl will then try to parse the project from the input file.  \n    DEFAULT = 'parse'",
        "log": "Logfile.",
        "debug": "Larger number = more verbose.",
        "help": "Print this message"
      },
      "contact": "Kevin Galens kgalens@tigr.org =cut use strict; use warnings; use Getopt::Long qw(:config no_ignore_case no_auto_abbrev pass_through); use Pod::Usage; use BSML::BsmlBuilder; use Ergatis::IdGenerator; use Ergatis::Logger; use Data::Dumper; ####### GLOBALS AND CONSTANTS ########### my $inputFile; #Holds input files my $project; #The project (ex aa1) my $output; #Output file my $idMaker; #The Ergatis::IdGenerator my $bsml; #BSML::BsmlBuilder object object. my $data; #Holds parsed aragorn information my $inputFsa; #The fasta file input to aragorn my $debug; #The debug variable my $gzip; #If the output should be compressed my $analysis_name = 'aragorn';#For the bsml links ######################################## my %options = (); my $results = GetOptions (\\%options, 'input_file|i=s', 'output|o=s', 'project|p=s', 'id_repository|r=s', 'fasta_input|a=s', 'compress_output|g=s', 'log|l=s', 'debug=s', 'help|h') || &_pod; #Setup the logger my $logfile = $options{'log'} || Ergatis::Logger::get_default_logfilename(); my $logger = new Ergatis::Logger('LOG_FILE'=>$logfile, 'LOG_LEVEL'=>$options{'debug'}); $logger = $logger->get_logger(); # Check the options. &check_parameters(\\%options); $data = &parseAragornData($inputFile); print \"Calling generate BSML\\n\"; $bsml = &generateBsml($data); print \"Writing to $output\\n\"; $bsml->write($output, '', $gzip); ######################## SUB ROUTINES ####################################### sub parseAragornData { my ($file) = @_; my $retval = {}; my $seq = \"\"; my $fh; open($fh, \"< $file\") or &_die(\"Could not open raw aragorn file ($file) for reading\"); while(<$fh>) { chomp; next if(/^\\s+$/); #If we are on the header line if(/^>(\\S+)/) { $seq = $1; next; #This means we found a tRNA } elsif( /^T/ ) { my ($comp, $start, $stop, $type, $antiCodon) = ($1, $2, $3, $4, $5) if(/TI?\\s+(c?)\\[(\\d+),(\\d+)\\]\\s+\\d+\\s+(\\w{3})\\((\\w{3})\\)/); &_die(\"Couldn't parse tmRNA line $_\") unless($start && $stop && $type && $antiCodon); $comp = 1 if($comp eq 'c'); $comp = 0 if(!$comp || $comp != 1 ); ($start, $stop) = ($start > $stop) ? ($stop, $start) : ($start, $stop); push(@{$retval->{$seq}->{'tRNA'}}, [$start, $stop, $comp, $type, $antiCodon]); #This means we found a tmRNA } elsif( /^M/ ) { my ($comp, $start, $stop) = ($1, $2, $3) if(/M[NP]\\s+(c?)\\[(\\d+),(\\d+)/); &_die(\"Couldn't parse tmRNA line $_\") unless($start && $stop); $comp = 1 if($comp eq 'c'); $comp = 0 if(!$comp || $comp != 1 ); ($start, $stop) = ($start > $stop) ? ($stop, $start) : ($start, $stop); push(@{$retval->{$seq}->{'tmRNA'}}, [$start, $stop, $comp]); #This means we messed up } else { my $char = substr($_, 0, 1); &_die(\"The line did not start with a >, T, or M. But it did start with a $char\"); } } return $retval; } sub generateBsml { my $data = shift; my $doc = new BSML::BsmlBuilder; open( IN, \"< $inputFsa\" ) or $logger->logdie(\"Unable to open $inputFsa\"); my $defline = <IN>; close( IN ); my $inputId = $1 if( $defline =~ /^>(\\S+)/ ); $logger->logdie(\"Can't parse input id from $inputFsa\") unless( $inputId ); $inputId =~ s/\\.$//; &createSequence( $doc, $inputId ) unless( scalar keys %$data ); foreach my $seqId ( keys %$data ) { die(\"There is not sequence id ($seqId)\") unless($seqId); my $seq = &createSequence( $doc, $seqId ); while( my ($rnaType, $rnas) = each( %{$data->{$seqId}} ) ) { foreach my $rna ( @$rnas ) { &createRNAGene( $doc, $seq, $rna, $rnaType ); } } } #Finish the document (add analysis) $doc->createAndAddAnalysis( id => \"${analysis_name}_analysis\", programversion => '1', algorithm => 'aragorn', name => 'aragorn' ); return $doc; } sub createSequence { my ($bsml, $seqId) = @_; print \"Called createSequnece on $seqId\\n\"; #Find the entry in the fasta file my $fsa; open($fsa, \"< $inputFsa\") or die(\"Unable to open $inputFsa ($!)\"); my ($length, $defline); my $seq = \"\"; my $found = 0; while(<$fsa>) { chomp; if(/^>($seqId.*)/) { $found = 1; $defline = $1; } elsif( /^>/ && $found ) { $length = length($seq); $found = 0; last; } elsif( $found ) { $seq .= $_; } } my $class = $1 if($seqId =~ /[^\\.]+\\.(\\w+)\\./); die(\"Could not parse class from id ($seqId)\") unless($class); my $seqObj = $bsml->createAndAddSequence( $seqId, '', $length, 'dna', $class); $seqObj->addBsmlLink( 'analysis', \"#\".$analysis_name.\"_analysis\", \"input_of\" ); $bsml->createAndAddBsmlAttribute( $seqObj, 'defline', $defline ); $bsml->createAndAddSeqDataImport( $seqObj, 'fasta', $inputFsa, '', $seqId ); return $seqObj; } sub createRNAGene { my ($doc, $seq, $rna, $rnaType) = @_; my $featTable = @{$seq->returnBsmlFeatureTableListR}[0]; $featTable = $doc->createAndAddFeatureTable( $seq ) unless($featTable); die(\"Could not make feature table element\") unless($featTable); my ($featId, $geneId); my %featG; foreach my $word ( (qw/ CDS gene exon /),$rnaType) { #Make the id $featId = $idMaker->next_id( 'type' => $word, 'project' => $project ); #Create the feature my $feat = $doc->createAndAddFeature( $featTable, $featId, '', $word ); die(\"Couldn't make feature object\") unless($feat); #All features need the interval loc and analysis link $feat->addBsmlIntervalLoc( $rna->[0] -1, $rna->[1], $rna->[2] ); $feat->addBsmlLink( 'analysis', \"#\".$analysis_name.\"_analysis\", 'computed_by' ); #If it's a tRNA feature, we should add some attributes to it #But only on the tRNA feature if( $word eq 'tRNA' ) { $doc->createAndAddBsmlAttribute( $feat, 'gene_product_name', \"tRNA-\".$rna->[3] ); $doc->createAndAddBsmlAttribute( $feat, 'tRNA_anti-codon', uc($rna->[4]) ); } #So we can add them all to feature groups $featG{$featId} = $word; #Save this for the group-set attr of the feature group element $geneId = $featId if( $word eq 'gene' ); } #Create a feature group my $fg = $doc->createAndAddFeatureGroup( $seq, '', $geneId ); foreach my $fId ( keys %featG ) { #Create a feature-group-member element for each of the feature types and add it to the feature group my $fgm = $doc->createAndAddFeatureGroupMember( $fg, $fId, $featG{$fId} ); } } sub check_parameters { my $options = shift; my $error = \"\"; &_pod if($options{'help'}); if($options{'input_file'}) { $error .= \"Option input_file ($options{'input_file'}) does not exist\\n\" unless(-e $options{'input_file'}); $inputFile = $options{'input_file'}; } else { $error = \"Option input_file is required\\n\"; } unless($options{'output'}) { $error .= \"Option output is required\\n\"; } else { $output = $options{'output'}; } unless($options{'id_repository'}) { $error .= \"Option id_repository is required. Please see Ergatis::IdGenerator \". \"for details.\\n\"; } else { $idMaker = new Ergatis::IdGenerator( 'id_repository' => $options{'id_repository'} ); $idMaker->set_pool_size( 'tRNA' => 20 ); } unless($options{'fasta_input'}) { $error .= \"Option fasta_input is required\\n\"; } else { $error .= \"$options{'fasta_input'} (fasta_input) does not exist\\n\" unless(-e $options{'fasta_input'}); $inputFsa = $options{'fasta_input'}; } unless($options{'project'}) { $project = &parseProjectName( $inputFsa ) if( $inputFsa ); } else { $project = $options{'project'}; $project = &parseProjectName( $inputFsa ) if($project eq 'parse' && $inputFsa); } unless($options{'compress_output'}) { $gzip = 0; } else { $gzip = 1; } if($options{'debug'}) { $debug = $options{'debug'}; } unless($error eq \"\") { &_die($error); } } sub parseProjectName { my $input = shift; my $projectName; open(IN, \"< $input\" ) or $logger->logdie(\"Unable to open $input\"); my $defline = <IN>; close(IN); $projectName = $1 if( $defline =~ /^>([^\\s\\.]+)/ ); $logger->logdie(\"Can't parse project name from $input\") unless($projectName); return $projectName; } sub _pod { pod2usage( {-exitval => 0, -verbose => 2, -output => \\*STDERR} ); } sub _die { my $msg = shift; $logger->logdie($msg); }"
    },
    {
      "tool": "augustus",
      "converter_script": "augustus2bsml.pl",
      "name": "augustus2bsml.pl - Creates a bsml document from augustus raw\n    output",
      "synopsis": "USAGE: augustus2bsml.pl\n            --input_file=/path/to/some/augustus.raw\n            --output=/path/to/augustus.bsml\n            --project=aa1\n            --id_repository=/path/to/id_repository\n            --fasta_input=/path/to/glimmer3/input.fsa\n          [ --log=/path/to/file.log\n            --debug=4\n            --help\n          ]",
      "description": "This script is used to convert the output from an augustus search into BSML.",
      "options": {
        "input_file": "Raw augustus output.",
        "output": "The output bsml file.",
        "project": "The project (used for id generation).",
        "id_repository": "Id repository for use by Workflow::IdGenerator.pm",
        "fasta_input": "The input file that was used as input for the glimmer3 run",
        "log": "Logfile.",
        "help": "Print this message"
      },
      "contact": "Kevin Galens kgalens@tigr.org =cut use strict; use warnings; use Getopt::Long qw(:config no_ignore_case no_auto_abbrev pass_through); use Pod::Usage; use Chado::Gene; use BSML::GenePredictionBsml; use Ergatis::IdGenerator; use Ergatis::Logger; use Data::Dumper; ####### GLOBALS AND CONSTANTS ########### my $inputFile; #Holds input files my $project; #The project (ex aa1) my $output; #Output file my $idMaker; #The Ergatis::IdGenerator my $bsml; #BSML::BsmlBuilder object object. my $data; #Holds parsed augustus information my $inputFsa; #The fasta file input to augustus my $sourcename; #Used for the analysis section of the bsml my $debug; #The debug variable ######################################## # handle versions of the executable with different output flags like this # to get the right encoding in the model object & bsml. my %version_map = ('1.8.2' => \"1\", '2.0.2' => \"2\", '2.3.1' => \"2\", '2.5.5' => '2'); ######################################## my %options = (); my $results = GetOptions (\\%options, 'input_file|i=s', 'output|o=s', 'project|p=s', 'id_repository|r=s', 'fasta_input|a=s', 'log|l=s', 'debug=s', 'help|h') || &_pod; #Setup the logger my $logfile = $options{'log'} || Ergatis::Logger::get_default_logfilename(); my $logger = new Ergatis::Logger('LOG_FILE' =>$logfile, 'LOG_LEVEL'=>$options{'debug'}); $logger = $logger->get_logger(); # Check the options. &check_parameters(\\%options); $data = &parseAugustusData($inputFile); $bsml = &generateBsml($data); $bsml->writeBsml($output); exit(0); ######################## SUB ROUTINES ####################################### sub parseAugustusData { my ($file) = @_; my @genes; #Array of gene objects. my ($tmp, $curGene, $curTransc) = ({}, 0, 0); open(my $in, \"< $file\") or &_die(\"Unable to open $file (input_file) ($!)\"); # Check the version of the augustus executable. This is necessary because the output is # somewhat inconsistent between versions my $version = &get_version($in) || $logger->logdie(\"Can't get the version of augustus used\"); while(<$in>) { next if(/^\\#/); next if(/^\\s+$/); chomp; my @cols = split(/\\t/); $cols[0] =~ s/(\\S+)\\s.*/$1/; next unless( $cols[1] eq 'AUGUSTUS' ); #The first column should contain the input sequence id. We use it for #the project name if it was not passed in or if the keyword parse #was passed in. if( ! $project || $project eq 'parse' ) { $project = $1 if( $cols[0] =~ /^([^\\.]+)/ ); } die(\"Could not parse project name from $cols[0]\") unless( $project && $project ne 'parse' ); #Parse out the augustus assigned gene id. #Column two is the feature column. #The id will be something like g1 (for gene 1) or t1 (for transcript 1). my ($newGeneId, $newTransId); if($cols[2] eq 'gene') { $newGeneId = $cols[8]; } elsif($cols[2] eq 'transcript' && $cols[8] =~ /^(.+?)\\.(.+)/) { $newGeneId = $1; $newTransId = $2; } elsif($cols[8] =~ /transcript_id\\s\\\"(.+?)\\.(.+?)\\\"/) { $newGeneId = $1; $newTransId = $2; } else { &_die(\"could not parse out fake gene id from column 8 ($cols[8]) on line $_\"); } #Make sure the start is always less than the stop. And parse the strand out. my ($start, $end) = ($cols[3] > $cols[4]) ? ($cols[4], $cols[3]) : ($cols[3], $cols[4]); my $strand = ($cols[6] eq '+') ? 0 : 1; #adjust for interbase coords: $start--; #If we have come across a new gene id (a fake one that augustus assigns), then #create a new gene. unless($newGeneId eq $curGene) { $tmp->{$newGeneId} = new Chado::Gene( $idMaker->next_id( 'type' => 'gene', 'project' => $project), $start, $end, $strand, $cols[0]); $curGene = $newGeneId; } # Deal with the lines according to column 2 (the type column). # Base this also on the version of the augustus program. # (Yes, this *is* fugly. It works.) if ($version_map{$version} == 1) { if($cols[2] =~ /^(initial|internal|terminal|single)$/) { my $exonId = $idMaker->next_id( 'type' => 'exon', 'project' => $project ); $tmp->{$newGeneId}->addExon($exonId, $start, $end, $strand); $tmp->{$newGeneId}->addToGroup($newTransId, { 'id' => $exonId } ); my $score = $cols[5]; $tmp->{$newGeneId}->addFeatureScore($exonId, 'p-value', $score) if($score); } elsif($cols[2] eq 'transcript') { foreach my $type(qw(CDS transcript polypeptide) ) { my $id = $idMaker->next_id( 'type' => $type, 'project' => $project ); $tmp->{$newGeneId}->addFeature( $id, $start, $end, $strand, $type ); $tmp->{$newGeneId}->addToGroup( $newTransId, { 'id' => $id } ); my $score = $cols[5]; $tmp->{$newGeneId}->addFeatureScore($id, 'p-value', $score) if($score); } } } elsif ($version_map{$version} == 2) { if($cols[2] =~ /^CDS$/) { my $exonId = $idMaker->next_id( 'type' => 'exon', 'project' => $project ); $tmp->{$newGeneId}->addExon($exonId, $start, $end, $strand); $tmp->{$newGeneId}->addToGroup($newTransId, { 'id' => $exonId } ); my $score = $cols[5]; $tmp->{$newGeneId}->addFeatureScore($exonId, 'p-value', $score) if($score); } elsif($cols[2] eq 'transcript') { foreach my $type(qw(CDS transcript polypeptide) ) { my $id = $idMaker->next_id( 'type' => $type, 'project' => $project ); $tmp->{$newGeneId}->addFeature( $id, $start, $end, $strand, $type ); $tmp->{$newGeneId}->addToGroup( $newTransId, { 'id' => $id } ); my $score = $cols[5]; $tmp->{$newGeneId}->addFeatureScore($id, 'p-value', $score) if($score); } } } } @genes = values %{$tmp}; return \\@genes; } sub generateBsml { my $data = shift; #Create the document my $doc = new BSML::GenePredictionBsml( 'augustus', $sourcename ); #Add all the genes to the document foreach my $gene(@{$data}) { $doc->addGene($gene); } #Get the sequence id from the input fasta file. my $seqId; open(IN, \"< $inputFsa\") or &_die(\"Unable to open $inputFsa\"); while(<IN>) { #assume it's a single fasta file if(/^>([^\\s+]+)/) { $seqId = $1; last; } } close(IN); #Set the fasta input (Returns zero if not succesful) my $addedTo = $doc->setFasta($seqId, $inputFsa); &_die(\"$seqId was not a sequence associated with the gene\") unless($addedTo); #Return the document. return $doc; } sub check_parameters { my $options = shift; my $error = \"\"; &_pod if($options{'help'}); if($options{'input_file'}) { $error .= \"Option input_file ($options{'input_file'}) does not exist\\n\" unless(-e $options{'input_file'}); $inputFile = $options{'input_file'}; } else { $error = \"Option input_file is required\\n\"; } #Parse the sourcename from the inputfile if( $inputFile ) { $sourcename = $1 if( $inputFile =~ m|^(.*)/[^/]+$| ); } #If the sourcename contains the iterator and group directories #( ie if run in ergatis ), remove them. $sourcename =~ s|/.*/g\\d+$|| if( $sourcename ); unless($options{'output'}) { $error .= \"Option output is required\\n\"; } else { $output = $options{'output'}; } unless($options{'project'}) { $project = \"parse\"; } else { $project = $options{'project'}; } unless($options{'id_repository'}) { $error .= \"Option id_repository is required. Please see Ergatis::IdGenerator \". \"for details.\\n\"; } else { $idMaker = new Ergatis::IdGenerator( 'id_repository' => $options{'id_repository'} ); $idMaker->set_pool_size( 'exon' => 20, 'transcript' => 20, 'gene' => 20, 'polypeptide' => 20, 'CDS' => 20 ); } unless($options{'fasta_input'}) { $error .= \"Option fasta_input is required\\n\"; } else { $error .= \"$options{'fasta_input'} (fasta_input) does not exist\\n\" unless(-e $options{'fasta_input'}); $inputFsa = $options{'fasta_input'}; } if($options{'debug'}) { $debug = $options{'debug'}; } unless($error eq \"\") { &_die($error); } } sub get_version { # Pull off a single line from the passed filehandle reference, then parse # the augustus version. my $fh = shift; my $first_line = <$fh>; my $version; # if ($first_line =~ /\\(version (\\d+\\.\\d+[\\.\\d+]?)\\)/) { if( $first_line =~ /\\(version\\s*(\\d+\\.\\d+[\\.\\d]+)\\)/ ) { $version = $1; } return ($version); } sub _pod { pod2usage( {-exitval => 0, -verbose => 2, -output => \\*STDERR} ); } sub _die { my $msg = shift; $logger->logdie($msg); }"
    },
    {
      "tool": "bepipred",
      "converter_script": "bepipred2bsml.pl",
      "name": "tmhmm2bsml.pl - convert TMHMM output to BSML",
      "synopsis": "USAGE: tmhmm2bsml.pl --input=/path/to/tmhmm_file --output=/path/to/output.bsml --project=aa1 --input=/path/to/tmhmm/input.fsa --compress_bsml_output=0",
      "description": "This script is used to convert the output from TMHMM into BSML.",
      "options": {
        "input": "The fasta file used as input to the tmhmm run.",
        "project": "[OPTIONAL]\n    The project (used for id making).\n    Default: unknown",
        "compress_bsml_output": "Will create gzipped output",
        "id_repository": "Required for creating feature identifiers.  Each project should have\n    its own id_repository directory - use the full path to it here.  This\n    is used by the IdGenerator.pm module.",
        "debug": "Debug level.  Use a large number to turn on verbose debugging.",
        "log": "Log file",
        "output": "Output BSML file (will be created, must not exist)",
        "help": "This help message"
      },
      "contact": "David Riley driley@som.igs.umaryland.edu =cut use strict; use Log::Log4perl qw(get_logger); use Getopt::Long qw(:config no_ignore_case no_auto_abbrev); use BSML::BsmlBuilder; use BSML::BsmlParserTwig; use BSML::BsmlRepository; use Ergatis::IdGenerator; use Pod::Usage; use Ergatis::Logger; my %options = (); my $results = GetOptions (\\%options, 'input|i=s', 'output|o=s', 'debug|d=s', 'id_repository|r=s', 'fasta_input=s', 'compress_bsml_output=s', 'project|p=s', 'log|l=s', 'help|h') || pod2usage(); my $logfile = $options{'log'} || Ergatis::Logger::get_default_logfilename(); my $logger = new Ergatis::Logger('LOG_FILE'=>$logfile, 'LOG_LEVEL'=>$options{'debug'}); $logger = $logger->get_logger(); # display documentation if( $options{'help'} ){ pod2usage( {-exitval=>0, -verbose => 2, -output => \\*STDOUT} ); } my $defline; my $fastaFile; my $gzip = 0; ## make sure all passed options are peachy &check_parameters(\\%options); ## we want to create ids unique to this document, which will be replaced later. they must ## contain the prefix that will be used to look up a real id, such as ath1.gen.15 my $next_id = 1; ## we want a new doc my $doc = new BSML::BsmlBuilder(); ## we're going to generate ids my $idgen = Ergatis::IdGenerator->new( id_repository => $options{id_repository} ); ## recognized output result data term mappings my %result_term = ( 'Length' => 'length', 'Number of predicted TMHs' => 'tmh_count', 'Exp number of AAs in TMHs' => 'exp_aa_in_tmh', 'Exp number, first 60 AAs' => 'exp_first_60', 'Total prob of N-in' => 'prob_n_in', ); ## recognized results qualifier term mappings my %qualifier = ( 'POSSIBLE N-term signal sequence' => 'n_term_signal', ); ## open the input file for parsing (even if it's gziped (bug 2591)) my $mode = \"<\"; $mode .= \":gzip\" if($options{'input'} =~ /.gz$/); open (my $ifh, $mode, $options{'input'}) || $logger->logdie(\"can't open input file for reading\"); my @sequence_ids; my %result_ref_hash; #my $temp; my %property_hash; my $epitope_hash; my %qualifier_hash; my $skip_flag = 0; my $in_epitope = 0; my $epitope_start = 0; my $epitope_stop = 0; my $seq_id = ''; #my $line; while (my $line = <$ifh>) { chomp $line; ## skip lines until we hit #'s if($line =~ /^#/) { next; } else { my @fields = split(/\\s+/, $line); if($seq_id eq '' || $seq_id eq $fields[0]) { $seq_id = $fields[0]; # Are we in an epitope? if($fields[8] eq 'E') { # Start a new eptiope here if(!$in_epitope) { $in_epitope = 1; $epitope_start=$fields[3]; $epitope_stop=$fields[3]; } # If we are we'll extend. else { $epitope_stop = $fields[4]; } } # If we're not in an epitope we'll go in here if we were # just recently in one. elsif($in_epitope) { if(!$epitope_hash->{$seq_id}) { $epitope_hash->{$seq_id} = (); } push(@{$epitope_hash->{$seq_id}}, {'start' => $epitope_start, 'stop' => $epitope_stop}); # &create_epitope($seq_id, $epitope_start, $epitope_stop); $in_epitope = 0; } } elsif($in_epitope) { push(@{$epitope_hash->{$seq_id}}, {'start' => $epitope_start, 'stop' => $epitope_stop}); # &create_epitope($seq_id, $epitope_start, $epitope_stop); $seq_id = $fields[0]; $in_epitope=0; } else { $seq_id = $fields[0]; } } } &create_doc($epitope_hash); exit; sub create_doc { my($epitopes) = @_; foreach my $s (keys %$epitopes) { my $seq = $doc->createAndAddSequence($s, $s, '', 'aa', 'polypeptide'); $doc->createAndAddBsmlAttribute( $seq, 'defline', $s); $doc->createAndAddSeqDataImport( $seq, 'fasta', $options{fasta_input}, \"sdi_\" . $s . '_seq', $s ); $seq->addBsmlLink('analysis', '#bepipred_analysis', 'input_of'); my $feature_table; $feature_table = $doc->createAndAddFeatureTable($seq); ## this makes ID pulling more efficient if ( scalar @{$epitopes->{$s}} ) { $idgen->set_pool_size( located_sequence_feature => scalar @{$epitopes->{$s}} ); } foreach my $ep_ref (@{$epitopes->{$s}}) { my $ep = $doc->createAndAddFeature( $feature_table, $idgen->next_id( project => $options{'project'}, type => 'epitope'), 'epitope', 'epitope'); $ep->addBsmlLink('analysis', '#bepipred_analysis', 'computed_by'); $ep->addBsmlIntervalLoc( $ep_ref->{'start'}, $ep_ref->{'stop'}, 0); } } my $analysis = $doc->createAndAddAnalysis( id => 'bepipred_analysis', sourcename => $options{'output'}, program => 'bepipred', algorithm => 'bepipred', ); $doc->write($options{'output'},,$gzip); } exit(); sub check_parameters { ## required params my @required = qw( fasta_input input output id_repository ); for ( @required ) { if (! defined $options{$_}) { $logger->logdie( \"$_ is a required option\" ); } } ## make sure input file exists if (! -e $options{'input'}) { unless(-e $options{'input'}.\".gz\") { $options{'input'}.=\".gz\"; } else { pod2usage({-message => \"Input file '$options{'input'}' does not exist!\"}); } } ## make sure the fasta input was provided. (Bug 3781) if($options{'fasta_input'}) { $fastaFile = $options{'fasta_input'}; open(IN, \"$fastaFile\") or pod2usage({-message => \"Could not open fasta_input $fastaFile ($!)\"}); while(<IN>) { chomp; if(/^>(.*)/) { $defline = $1; last; } } close(IN); } else { pod2usage({-message => \"Option fasta_input is required\"}); } ## in case they want to compress the bsml output (bug 2591) if($options{'compress_bsml_output'}) { $gzip = 1; } $options{'project'} = 'unknown' unless ($options{'project'}); $options{'command_id'} = '0' unless ($options{'command_id'}); return 1; } ## parse_position parses the position field to give an array containing ## start [and stop] sites sub parse_position { my ($position) = @_; if ($position =~ /^\\s*([^\\s]+)\\s*$/) { return split(\"-\", $1); } else { return (); } }"
    },
    {
      "tool": "berbtab",
      "converter_script": "berbtab2bsml.pl",
      "name": "berbtab2bsml.pl  - convert info stored in BER btab files into BSML documents",
      "synopsis": "USAGE:  berbtab2bsml.pl -b btab_dir -o blastp.bsml -d bsml_dir",
      "description": "berbtab2bsml.pl is designed to convert information in ber btab files into BSML documents.\n\nNOTE:  \n\nCalling the script name with NO flags/options or --help will display the syntax requirement.\n\n\n=cut\n\n\nuse strict;\nuse Getopt::Long qw(:config no_ignore_case no_auto_abbrev);\nuse English;\nuse File::Basename;\nuse File::Path;\nuse Pod::Usage;\nuse Ergatis::Logger;\nuse BSML::BsmlRepository;\nuse BSML::BsmlBuilder;\nuse BSML::BsmlParserTwig;\nuse Ergatis::IdGenerator;\n\nmy %lookupDb;\nmy %lookupProtDb;\nmy %prot2cds_lookup;\nmy %cds2coords;\nmy %cds2bestmval;\nmy @bestFrameshifts;\nmy %cds2trans;\nmy %cds2polyp;\nmy %addedFeats;\nmy %options = ();\nmy $gzip = 0;\nmy $project = 'parse';\nmy $results = GetOptions (\\%options, \n\t\t\t  'btab_dir|b=s', \n\t\t\t  'btab_file|f=s',\n\t\t\t  'bsml_dir|d=s', \n              'bsml_file|bf=s',\n              'bp_offset|bo=s',\n              'mapping_file=s',\n\t\t\t  'output|o=s', \n              'gzip_output=s',\n\t\t\t  'max_hsp_count|m=s',\n\t\t\t  'pvalue|p=s', \n\t\t\t  'log|l=s',\n\t\t\t  'debug=s',\n\t\t\t  'class|c=s',\n\t\t\t  'analysis_id=s',\n              'id_repository=s',\n              'project_abbreviation|a=s',\n\t\t\t  'help|h') || pod2usage();\n\nmy $logfile = $options{'log'} || Ergatis::Logger::get_default_logfilename();\nmy $logger = new Ergatis::Logger('LOG_FILE'=>$logfile,\n\t\t\t\t  'LOG_LEVEL'=>$options{'debug'});\n$logger = $logger->get_logger();\n\nif($options{'pvalue'} eq \"\"){\n    $options{'pvalue'} = 10;\n}\n\nmy $class;\nif (!defined($options{'class'})){\n    $logger->logdie(\"class was not defined\");\n}\nelse{\n    $class = $options{'class'};\n}\n\n\n\n# display documentation\nif( $options{'help'} ){\n    pod2usage( {-exitval=>0, -verbose => 2, -output => \\*STDOUT} );\n}\n\n&check_parameters(\\%options);\n\nmy $files = &get_btab_files($options{'btab_dir'},$options{'btab_file'});\n\nmy $doc = new BSML::BsmlBuilder();\nmy %featTables;\nmy $idGenerator;\nmy $num_seqs_added = 0;\n\n$doc->makeCurrentDocument();\nparse_ber_btabs($files);\n\n## Removing i1 from the sourcename so that this modification doesnt have to be made manually in the DB \n## when bsml file is loaded after the pipeline is run\nmy $srcname = $options{'output'};\n$srcname =~ s/\\/i1//;\n\n$doc->createAndAddAnalysis(\n                            id => $options{analysis_id},\n                            sourcename => $srcname,\n                            program => 'ber',\n                            algorithm => 'ber',\n                            programversion => 'none',\n                          );\n\n$doc->write($options{'output'}, '', $options{'gzip_output'});\n\nsub parse_ber_btabs {\n\n    my $btab_files = shift;\n    my $num;\n    foreach my $file (@$btab_files) {\n\n        $num++; \n        open (BTAB, \"$file\") or die \"Unable to open \\\"$file\\\" due to $!\";\n        $logger->debug(\"opening $file $num using pvalue cutoff $options{'pvalue'}\") if($logger->is_debug());\n        my $query_id;\n\n        my $count = 0;\n\n        while(my $line = <BTAB>) {\n            chomp($line);\n            my @btab = split(\"\\t\", $line);\n            $count++;\n\n            #if we don't pass the pvalue cutoff\n            next if($btab[20] > $options{'pvalue'} );\n\n            #if it's not created by praze (ber)\n            next if($btab[3] ne 'praze');\n\n            #next if( !($btab[13] > 0) || !($btab[14] > 0) );\n\n            #make sure we have query id and match id\n            next if(!$btab[0] or !$btab[5]);\n\n            #for when fastacmd is used to pull sequences from the database:\n            #it appends an lcl| to the front of the accession. Can't figure out\n            #how to stop that.\n            $btab[0] =~ s/^lcl\\|//;\n\n            #$btab[5] =~ s/\\|//g;   #get rid of trailing |\n            $query_id = $btab[0];\t    \n            my $match_name = $btab[5];\n\n            # Only take the frameshifts from the hit with the best mvalue. This is a HACK\n            # for now and should probably be replaced with something more sophisticated.\n            if(!defined($cds2bestmval{$btab[0]}) || ($btab[12] > $cds2bestmval{$btab[0]})) {\n                $cds2bestmval{$btab[0]} = $btab[12];\n                &createFrameshifts($btab[19], $btab[0], $btab[2],$btab[12]) if($btab[19] && defined($options{bp_offset}));\n                #splice(@btab, 19, 1);   Why was this happening?\n            }\n\n            for (my $i=0;$i<scalar(@btab);$i++){\n                if ($btab[$i] eq 'N/A'){\n                    $btab[$i] = undef;\n                }\n            }\n            \n            my $align = &createAndAddBtabLine(\n                                              doc                => $doc,\n                                              class              => $class,\n                                              query_name         => $btab[0],\n                                              date               => $btab[1],\n                                              query_length       => $btab[2],\n                                              blast_program      => $btab[3],\n                                              search_database    => $btab[4],\n                                              dbmatch_accession  => $btab[5],\n                                              start_query        => $btab[6],\n                                              stop_query         => $btab[7],\n                                              start_hit          => $btab[8],\n                                              stop_hit           => $btab[9],\n                                              percent_identity   => $btab[10],\n                                              percent_similarity => $btab[11],\n                                              raw_score          => $btab[12],\n                                              bit_score          => $btab[13],\n                                              chain_number       => $btab[14],\n                                              segment_number     => $btab[14],\n                                              dbmatch_header     => $btab[15],\n                                              blast_frame        => $btab[16],\n                                              query_strand       => $btab[17],\n                                              subject_length     => $btab[18],\n                                              e_value            => $btab[19],\n                                              p_value            => $btab[20]\n                                              );\n\n            my $seq = $doc->returnBsmlSequenceByIDR($match_name);\n\n        }\n        close BTAB;\n\n        if ($query_id) {\n            my $seq = $doc->returnBsmlSequenceByIDR($query_id);\n        }\n\n        &addFrameshifts();\n\n        #unfortunately, if the input btab doesn't have any hits, we don't know\n        #which CDS was run (which means we don't know the parent sequence either).\n        #But we have to add a sequence. This is a hack.\n        if( $count == 0 ) {\n            my $base = $1 if( $file =~ m|^.*/([^/]+)| );\n            my $polypeptide = $1 if( $base =~ /([^\\.]+\\.polypeptide\\.\\w+(\\.\\d+)?)/ );\n            my $cds;\n            unless(defined( $polypeptide )) {\n                $cds = $1 if( $base =~ /([^\\.]+\\.CDS\\.\\w+(\\.\\d+)?)/ );\n            }\n\n            #does it exist in the lookup? (means that it's a valid sequence id)\n            if( !defined( $cds ) && exists( $lookupProtDb{$polypeptide} ) ) {\n                $cds = $prot2cds_lookup{$polypeptide};\n            } \n            \n            #if it's still not defined\n            if( !defined( $cds ) ) {\n                die(\"No hits in the btab and could not parse polypeptide name from file name\");\n            }\n                \n            &addSequenceElement( $cds, 'na', 'CDS' );\n            &addSequenceElement( $cds2polyp{$cds}, 'aa', 'polypeptide');\n        }\n    }\n}\n\nsub get_btab_files{\n    my ($directory,$file) = @_;\n    my @files;\n    if(-d $directory){\n\topendir(DIR, $directory) or die \"Unable to access $directory due to $!\";\n\twhile( my $filename = readdir(DIR)) {\n\t    if($filename =~ /(.+)\\.btab$/) {\n            push (@files, \"$directory/$filename\");\n\t    }\n\t}\n    }\n    if($file ne \"\"){\n\tpush @files,$file;\n    }\n    return \\@files;\n}\n\n\nsub check_parameters{\n    my ($options) = @_;\n    \n    if(!$options{'output'} or (!$options{'btab_dir'} && !$options{'btab_file'})) {\n\tpod2usage({-exitval => 2,  -message => \"$0: All the required options are not specified\", -verbose => 1, -output => \\*STDERR});    \n    }\n\n    if((! -d $options{'btab_dir'}) && (! -e $options{'btab_file'})) {\n\tprint STDERR \"btab directory \\\"$options{'btab_dir'}\\\" or btab file $options{'btab_file'} cannot be found.  Aborting...\\n\";\n\texit 5;\n    } \n\n    if( $options{'project_abbreviation'} ) {\n        $project = $options{'project_abbreviation'};\n    }\n\n    unless($options{'mapping_file'}) {\n        $logger->logdie(\"mapping_file option is required.\");\n    } else {\n        $logger->logdie(\"Mapping_file ($options{mapping_file} does not exist\")\n            unless(-e $options{'mapping_file'});\n        open(IN, \"<\", $options{'mapping_file'}) or \n            $logger->logdie(\"Unable to open mapping file $options{mapping_file} ($!)\");\n        while( my ($prot, $cds, $trans, $asm, $coords) = split(/\\t/, <IN>) ) {\n            chomp($asm);\n            $lookupDb{$cds} = $asm;\n            $lookupProtDb{$prot} = $asm;\n            $prot2cds_lookup{$prot} = $cds;\n            $coords =~ /(\\d+)\\:(\\d+)\\/([01])/;\n            $cds2coords{$cds} = {'fmin' => $1, 'fmax' => $2, 'complement' => $3};\n            $cds2trans{$cds} = $trans;\n            $cds2polyp{$cds} = $prot;\n        }\n\n        close(IN);\n    }\n  \n    if($options{'id_repository'}) {\n        $logger->logdie(\"id_repository does not exist\") unless(-d $options{'id_repository'});\n    } else {\n        $logger->logdie(\"option id_repository is required.\");\n    }\n    $idGenerator = new Ergatis::IdGenerator( 'id_repository' => $options{'id_repository'} );\n    $idGenerator->set_pool_size( 'frameshift_mutation' => 25 );\n\n    return 1;\n}\n\nsub addSequenceElement {\n    my ($seqId, $mol, $type) = @_;\n    \n    #Check to see if the sequence has already been added.\n    unless( $doc->returnBsmlSequenceByIDR( $seqId ) ){\n\t    my $seq = $doc->createAndAddSequence( $seqId, $seqId, 'na', $mol, $type );\n\t\t$seq->addBsmlLink('analysis', '#' . $options{analysis_id}, 'input_of');\n        return $seq;\n    }\n}\n\nsub createFrameshifts {\n    my ($fsString,$modelId,$modelLen,$mvalue) = @_;\n\n    @bestFrameshifts = ();\n    my @frameShifts = split(/:/,$fsString);\n    $logger->logdie(\"Could not parse frameshift information from string ($fsString)\") unless(@frameShifts);\n\n    $logger->logdie(\"Model id: ($modelId) does not exist in the lookup_db ($options{lookup_db})\") \n        unless(exists($lookupDb{$modelId}));\n\n    my $seqId = $lookupDb{$modelId};\n    my $seq;\n\n    #Parse out the project id\n    if( $project eq 'parse' ) {\n        undef $project;\n        $project = $1 if($seqId =~ /^([^\\.]+)\\./);\n        die(\"Could not parse project from sequence id: $seqId\")\n            unless( $project );\n    }\n    die(\"Project was not set correctly\") unless( $project );\n    \n    #will add the sequence element if it doesn't already exist\n    $seq = &addSequenceElement( $seqId, 'dna', 'assembly' );\n\n    #Check to see if said sequence object has a feature table object\n    unless(exists($featTables{$seqId})) {\n        $featTables{$seqId} = $doc->createAndAddFeatureTable($seq);\n    }\n    \n    #Now add the frameshifts\n    foreach my $fs (@frameShifts) {\n\n        my ($start, $end) = ($1, $2) if($fs =~ /(.+)-(.+)/);\n        $logger->logdie(\"Could not parse frameshift data ($fs)\")\n            unless($start && $end);\n\n        ($start--, $end--);\n        my $strand = $cds2coords{$modelId}->{'complement'} ? 1 : 0;\n        \n        if($start > $end) {\n            ($end, $start) = ($start, $end);\n            $strand = 1;\n        }\n        if($strand) {\n            $start = $modelLen - $start;\n            $end = $modelLen - $end;\n            ($end, $start) = ($start, $end);\n            ($start--, $end--);\n        }\n        \n        # Calculate the coordinates of the frameshift using the bp_offset and the\n        # coordinates from the mapping file.\n        my $model_fmin = $cds2coords{$modelId}->{'fmin'};\n        my $model_fmax = $cds2coords{$modelId}->{'fmax'};\n        if(($model_fmax - $model_fmin + 2*$options{'bp_offset'}) != $modelLen) {\n            if($model_fmin < $options{'bp_offset'}) {\n                $model_fmin = 0;\n            }\n        }\n        else {\n            $model_fmin -= $options{'bp_offset'};\n        }\n         \n        push(@bestFrameshifts, {\n            'seq_id' => $seqId,\n            'cds_id' => $modelId,\n            'start' => $model_fmin + $start,\n            'stop' => $model_fmin + $end,\n            'strand' => $strand,\n            'project' => $project\n             });\n    }\n}\n\n# Add only the 'best' frameshifts to the document.\nsub addFrameshifts {\n\n    foreach my $fs (@bestFrameshifts) {\n        my $fId = $idGenerator->next_id('type' => 'frameshift', 'project' => $fs->{'project'});\n\n        # Add the frameshift feature\n        my $feat = $doc->createAndAddFeature($featTables{$fs->{'seq_id'}}, $fId, $fId, 'frameshift');\n        # Add a link to the analysis \n        $feat->addBsmlLink('analysis', '#'.$options{'analysis_id'}, 'computed_by');\n        #Locate the frameshift on the genomic sequence assembly\n        $feat->addBsmlIntervalLoc($fs->{'start'}, $fs->{'stop'}, $fs->{'strand'});\n\n        # Add the transcript feature\n        if(!$addedFeats{$cds2trans{$fs->{'cds_id'}}}) {\n            $doc->createAndAddFeature($featTables{$fs->{'seq_id'}}, $cds2trans{$fs->{'cds_id'}}, '','transcript');\n            $addedFeats{$cds2trans{$fs->{'cds_id'}}} = 1;\n        }\n\n        # Add a featuregroup with the frameshift and the transcript of this gene.\n        my $fg = $doc->createAndAddFeatureGroup( $doc->returnBsmlSequenceByIDR( $fs->{'seq_id'}),'');\n        $doc->createAndAddFeatureGroupMember( $fg, $cds2trans{$fs->{'cds_id'}}, 'transcript');\n        $doc->createAndAddFeatureGroupMember( $fg, $fId, 'frameshift');\n\n \n    }\n}\n\nsub createAndAddBtabLine {\n\n    my %args = @_;\n    my $doc = $args{'doc'};\n    \n    my $nice_id = $args{'dbmatch_accession'};\n    $nice_id =~ s/\\|/_/g;\n\n    #determine if the query name and the dbmatch name are a unique pair in the document\n    \n    my $alignment_pair_list = BSML::BsmlDoc::BsmlReturnAlignmentLookup( \"$args{'query_name'}\", \"$nice_id\" );\n\n    my $alignment_pair = '';\n    if( $alignment_pair_list )\n    {\n        $alignment_pair = $alignment_pair_list->[0];\n    }\n\n    if( $alignment_pair  )\n    {\n\t    #add a new BsmlSeqPairRun to the alignment pair and return\n\t    my $seq_run = $alignment_pair->returnBsmlSeqPairRunR( $alignment_pair->addBsmlSeqPairRun() );\n\n\t    if( $args{'start_query'} > $args{'stop_query'} )\n        {\n            $seq_run->setattr( 'refpos', $args{'stop_query'}-1 );\n            $seq_run->setattr( 'runlength', $args{'start_query'} - $args{'stop_query'} + 1 );\n            $seq_run->setattr( 'refcomplement', 1 );\n        }\n\t    else\n        {\n            $seq_run->setattr( 'refpos', $args{'start_query'}-1 );\n            $seq_run->setattr( 'runlength', $args{'stop_query'} - $args{'start_query'} + 1 );\n            $seq_run->setattr( 'refcomplement', 0 );\n        }\n\n\t    #the database sequence is always 5' to 3'\n\n\t    $seq_run->setattr( 'comppos', $args{'start_hit'} -1 )                                   if (defined ($args{'start_hit'}));\n\t    $seq_run->setattr( 'comprunlength', $args{'stop_hit'} - $args{'start_hit'} + 1 )     if ((defined ($args{'start_hit'})) and (defined ($args{'stop_hit'})));\n\t    $seq_run->setattr( 'compcomplement', 0 );\n\n\t    $seq_run->setattr( 'runscore', $args{'bit_score'} )                                  if (defined ($args{'bit_score'}));\n\t    $seq_run->setattr( 'runprob', $args{'e_value'} )                                     if (defined ($args{'e_value'}));\n\n        $seq_run->addBsmlAttr( 'class', 'match_part' );\n\t    $seq_run->addBsmlAttr( 'percent_identity', $args{'percent_identity'} )               if (defined ($args{'percent_identity'}));   \n\t    $seq_run->addBsmlAttr( 'percent_similarity', $args{'percent_similarity'} )           if (defined ($args{'percent_similarity'}));\n\t    $seq_run->addBsmlAttr( 'chain_number', $args{'chain_number'} )                       if (defined ($args{'chain_number'}));\n\t    $seq_run->addBsmlAttr( 'segment_number', $args{'segment_number'} )                   if (defined ($args{'segment_number'}));\n\t    $seq_run->addBsmlAttr( 'p_value', $args{'p_value'} )                                 if (defined ($args{'p_value'}));\n\n\t    return $alignment_pair;\n    }\n\n    #no alignment pair matches, add a new alignment pair and sequence run\n    #check to see if sequences exist in the BsmlDoc, if not add them with basic attributes\n    my $seq;\n    \n\n    if( !( $doc->returnBsmlSequenceByIDR( \"$args{'query_name'}\")) ){\n\t    $seq = $doc->createAndAddSequence( \"$args{'query_name'}\", \"$args{'query_name'}\", $args{'query_length'}, 'na', $args{'class'} );\n\t\t$seq->addBsmlLink('analysis', '#' . $options{analysis_id}, 'input_of');\n    }\n\n    \n    if( !( $doc->returnBsmlSequenceByIDR( \"$args{'dbmatch_accession'}\")) ){\n        $seq = $doc->createAndAddSequence( \"$nice_id\", \"$args{'dbmatch_header'}\", $args{'subject_length'}, 'aa', 'polypeptide' );\n        $doc->createAndAddBsmlAttribute( $seq, 'defline', $args{'dbmatch_accession'} );\n    }\n\n    ## see if the dbmatch_header format is recognized.  if so, add some cross-references\n    if (defined $args{'dbmatch_header'}) {\n        $doc->createAndAddCrossReferencesByParse( sequence => $seq, string => $args{'dbmatch_header'} );\n    }\n\n    $alignment_pair = $doc->returnBsmlSeqPairAlignmentR( $doc->addBsmlSeqPairAlignment() );\n\n\t## add analysis link \n\t$alignment_pair->addBsmlLink('analysis', '#' . $options{analysis_id}, 'computed_by');\n\n    $alignment_pair->setattr( 'refseq', \"$args{'query_name'}\" )                                 if (defined ($args{'query_name'}));\n    $alignment_pair->setattr( 'compseq', \"$nice_id\" )                         if (defined ($args{'dbmatch_accession'}));\n    \n    BSML::BsmlDoc::BsmlSetAlignmentLookup( \"$args{'query_name'}\", \"$nice_id\", $alignment_pair );\n\n    $alignment_pair->setattr( 'refxref', ':'.$args{'query_name'})        if (defined ($args{'query_name'}));                     \n    $alignment_pair->setattr( 'refstart', 0 );\n    $alignment_pair->setattr( 'refend', $args{'query_length'} )      if (defined ($args{'query_length'}));\n    $alignment_pair->setattr( 'reflength', $args{'query_length'} )       if (defined ($args{'query_length'}));\n\n    $alignment_pair->setattr( 'method', $args{'blast_program'} )         if (defined ($args{'blast_program'}));\n\n    $alignment_pair->setattr( 'compxref', $args{'search_database'}.':'.$args{'dbmatch_accession'} )  if ((defined ($args{'search_database'})) and (defined ($args{'dbmatch_accession'})));\n    $alignment_pair->setattr( 'class', 'match' );\n\n    my $seq_run = $alignment_pair->returnBsmlSeqPairRunR( $alignment_pair->addBsmlSeqPairRun() );\n\n    if( $args{'start_query'} > $args{'stop_query'} )\n    {\n        $seq_run->setattr( 'refpos', $args{'stop_query'}-1 );\n        $seq_run->setattr( 'runlength', $args{'start_query'} - $args{'stop_query'} + 1 );\n        $seq_run->setattr( 'refcomplement', 1 );\n    }\n    else\n    {\n        $seq_run->setattr( 'refpos', $args{'start_query'} -1);\n        $seq_run->setattr( 'runlength', $args{'stop_query'} - $args{'start_query'} + 1 );\n        $seq_run->setattr( 'refcomplement', 0 );\n    }\n\n    #the database sequence is always 5' to 3'\n    \n    $seq_run->setattr( 'comppos', $args{'start_hit'} -1)                                     if (defined  ($args{'start_hit'}));\n    $seq_run->setattr( 'comprunlength', ($args{'stop_hit'} - $args{'start_hit'} + 1))      if ((defined ($args{'start_hit'})) and (defined ($args{'stop_hit'})));\n    $seq_run->setattr( 'compcomplement', 0 );\n    \n    $seq_run->setattr( 'runscore', $args{'bit_score'} )                                    if (defined  ($args{'bit_score'}));\n    $seq_run->setattr( 'runprob', $args{'e_value'} )                                       if (defined  ($args{'e_value'}));\n\n    $seq_run->addBsmlAttr( 'class', 'match_part');\n    $seq_run->addBsmlAttr( 'percent_identity', $args{'percent_identity'} )                 if (defined  ($args{'percent_identity'}));\n    $seq_run->addBsmlAttr( 'percent_similarity', $args{'percent_similarity'} )             if (defined  ($args{'percent_similarity'}));\n    $seq_run->addBsmlAttr( 'chain_number', $args{'chain_number'} )                         if (defined  ($args{'chain_number'}));\n    $seq_run->addBsmlAttr( 'segment_number', $args{'segment_number'} )                     if (defined  ($args{'segment_number'}));\n    $seq_run->addBsmlAttr( 'p_value', $args{'p_value'} )                                   if (defined  ($args{'p_value'}));\n\n    return $alignment_pair;\n\n\n}",
      "options": {},
      "contact": null
    },
    {
      "tool": "blast",
      "converter_script": "blast2bsml.pl",
      "name": "blast2bsml.pl  - convert raw blast output to BSML documents",
      "synopsis": "USAGE:  blast2bsml.pl -i blastp.raw -o blastp.bsml -q /path/to/query_file.fsa -l /path/to/logfile.log",
      "description": "blastbtab2bsml.pl takes raw output from WU-BLAST and translates it to BSML.\nIn the case of an empty results set, a sequence stub and analysis link will\nstill be created for the query sequence.\n\nNOTE:\n\nCalling the script name with NO flags/options or --help will display the syntax requirement.",
      "options": {
        "input": "The input raw blast output from the wu-blast suite.",
        "output": "The output BSML file name.",
        "query_file_path": "The full path to the query FASTA file (used to populate refxref)\n    [When used in workflow should be passed ITER_FILE_PATH]",
        "gzip_output": "Compress the bsml output.  If there is not .gz extension on the the output file\n    one will be added (optional).",
        "debug": "Debug level.  Use a large number to turn on verbose debugging.",
        "log": "Log file",
        "help": "This help message"
      },
      "contact": "Brett Whitty bwhitty@tigr.org =cut use strict; use Bio::SearchIO; use English; use File::Basename; use File::Path; use Getopt::Long qw(:config no_ignore_case no_auto_abbrev); use Pod::Usage; use Ergatis::Logger; use BSML::BsmlRepository; use BSML::BsmlBuilder; use BSML::BsmlParserTwig; my %options = (); my $results = GetOptions (\\%options, 'input|i=s', 'output|o=s', 'query_file_path|q=s', 'gzip_output|g=s', 'log|l=s', 'debug|d=s', 'analysis_id|a=s', 'split=s', 'bsml_dir|d=s', ## deprecated. keeping for backward compat (for now) 'max_hsp_count|m=s', 'max_alignment_count|M=s', 'filter_hsps_for_stats|F=s', 'pvalue|p=s', 'debug=s', 'class|c=s', 'do_nothing=s', 'help|h') || pod2usage(); my $logfile = $options{'log'} || Ergatis::Logger::get_default_logfilename(); my $logger = new Ergatis::Logger('LOG_FILE'=>$logfile, 'LOG_LEVEL'=>$options{'debug'}); $logger = $logger->get_logger(); ## display documentation if( $options{'help'} || scalar keys(%options) == 0 ){ pod2usage( {-exitval=>0, -verbose => 2, -output => \\*STDOUT} ); } if($options{'do_nothing'}) { exit; } if($options{'pvalue'} eq \"\"){ $options{'pvalue'} = 10; } my $ref_molecule = { 'blastn' => 'na', 'blastp' => 'aa', 'blastx' => 'na', 'tblastn' => 'aa', 'tblastx' => 'na', }; my $comp_molecule = { 'blastn' => 'na', 'blastp' => 'aa', 'blastx' => 'aa', 'tblastn' => 'na', 'tblastx' => 'na', }; ## make sure everything passed was peachy &check_parameters(\\%options); my $class; if (!defined($options{'class'})){ $logger->logdie(\"class was not defined\"); } else { $class = $options{'class'}; } ##determine wu-blast program my $blast_program; if ($options{'analysis_id'} =~ /^([^_]+)_analysis/) { $blast_program = $1; $blast_program =~ s/.*-//; } else { $logger->logdie(\"analysis_id '$options{analysis_id}' has unexpected structure\"); } ##check that we've got defined molecule types for the analysis program unless($ref_molecule->{$blast_program} && $comp_molecule->{$blast_program}) { $logger->logdie(\"Molecule types for '$options{analysis_id}' are undefined\"); } my $deflines = get_deflines($options{'query_file_path'}); ## get a filehandle on the input open(my $ifh, \"<$options{input}\") || $logger->logdie(\"can't read the input sequence: $!\"); my $in = new Bio::SearchIO(-format => 'blast', -fh => $ifh); ## open the output file: ##open (my $ofh, \">$options{output}\") || $logger->logdie(\"can't create output file for BLAST report: $!\"); my $currdoc; my $docs = {}; if(exists $options{'split'} && $options{'split'}){ } else{ $currdoc = new BSML::BsmlBuilder(); $currdoc->makeCurrentDocument(); } # HSP = Highest-scoring segment pairs my $hsplookup = {}; my @hsp_ref_array; # parse each blast record: RESULT: while( my $result = $in->next_result ) { my $hsp_counter = 0; my $hit_counter = 0; # parse each hit per record. while( my $hit = $result->next_hit ) { if ($options{'max_alignment_count'} && ++$hit_counter > $options{'max_alignment_count'}) { next RESULT; } # a hit consists of one or more HSPs while( my $hsp = $hit->next_hsp ) { my @x; $x[0] = $result->query_name(); # date $x[2] = $result->query_length(); $x[3] = $hsp->algorithm(); ## database name will get parsed with whitespace if its path is long $x[4] = $result->database_name(); $x[4] =~ s/\\s//g; $x[5] = $hit->name(); $x[6] = $hsp->start('query'); $x[7] = $hsp->end('query'); my $queryStrand = $hsp->strand('query'); if ($queryStrand == -1) { ($x[6], $x[7]) = ($x[7], $x[6]); } $x[8] = $hsp->start('hit'); $x[9] = $hsp->end('hit'); my $hitStrand = $hsp->strand('hit'); if ($hitStrand == -1) { ($x[8], $x[9]) = ($x[9], $x[8]); } $x[10] = sprintf (\"%.1f\", $hsp->percent_identity()); my $similarity = $hsp->frac_conserved('total') * 100; $x[11] = sprintf(\"%.1f\", $similarity); $x[12] = $hsp->score(); $x[13] = $hsp->bits(); my $desc = $hit->description(); $desc =~ s/\\\\t/ /g; #encountered rare case where a '\\t' was inserted in description $x[15] = $desc; # replace ctrl-a's inserted by recent versions of bioperl $x[15] =~ s/\\cA/ /g; $x[16] = ( ($hsp->query->frame + 1) * $hsp->query->strand); #blast frame (1, 2, 3, -1, -2, -3). my $strandDescript = \"null\"; if ($queryStrand == 1) { $strandDescript = \"Plus\"; } elsif ($queryStrand == -1) { $strandDescript = \"Minus\"; } $x[17] = $strandDescript; $x[18] = $hit->length(); $x[19] = $hsp->evalue(); $x[20] = $hsp->pvalue(); ################ Generating p-value from e-value ################## ################ if p-value is undefined. ################## unless($x[20]) { $x[20] = calculate_pvalue($x[19]); } ##################################################################################### if(($x[20] <= $options{'pvalue'}) && ($x[0] ne \"\") && ($x[5] ne \"\")){ ## pvalue is less than cutoff parameter ## so process btab line $hsp_counter++; if(($x[20] <= $options{'pvalue'}) && ($x[0] ne \"\") && ($x[5] ne \"\")){ if(!(exists $hsplookup->{$x[0]}->{$x[5]})){ $hsplookup->{$x[0]}->{$x[5]} = []; } push @{$hsplookup->{$x[0]}->{$x[5]}},{'pvalue'=>$x[20], 'line'=>\\@x}; } else { $logger->debug(\"Skipping $x[0] $x[5] pvalue $x[20] above pvalue cutoff of $options{'pvalue'}\") if($logger->is_debug()); } } else { ## else we're gonna skip the line $logger->debug(\"Skipping $x[0] $x[5] pvalue $x[20] above pvalue cutoff of $options{'pvalue'}\") if($logger->is_debug()); } } } if ($hsp_counter == 0) { if(exists $options{'split'} && $options{'split'}){ my $queryname = $result->query_name(); if(!exists $docs->{$queryname}){ my $doc = new BSML::BsmlBuilder(); $docs->{$queryname} = $doc; } $docs->{$queryname}->makeCurrentDocument(); $currdoc = $docs->{$queryname}; } my $align = &createAndAddNullResult( doc => $currdoc, query_name => $result->query_name(), query_length => $result->query_length(), class => $class, ); } } my $qual_stats = {}; foreach my $query (keys %{$hsplookup}){ foreach my $subject (keys %{$hsplookup->{$query}}) { my @hsps = sort {$a->{'pvalue'} <=> $b->{'pvalue'}} @{$hsplookup->{$query}->{$subject}}; my $maxhsp; if ($options{'max_hsp_count'} ne \"\") { $maxhsp = ($options{'max_hsp_count'}<scalar(@hsps)) ? $options{'max_hsp_count'} : scalar(@hsps); } else { $maxhsp = scalar(@hsps); } my $queryid; ######## Calculate Coverage info # # ## calculate coverage stuff my $new_subject; @hsp_ref_array = (); for (my $i=0; $i<$maxhsp; $i++) { my @btab = @{$hsps[$i]->{'line'}}; $queryid = $btab[0] if ($btab[0] && (!$queryid)); for (my $i=0; $i<scalar(@btab); $i++) { if ($btab[$i] eq 'N/A'){ $btab[$i] = undef; } } my $orig_dbmatch_accession = $btab[5]; #$btab[5] =~ s/[^a-z0-9\\_\\.\\-]/_/gi; $new_subject = $btab[5]; my $qfmin = $btab[6]; my $qfmax = $btab[7]; my $qstrand = 0; my $tfmin = $btab[8]; my $tfmax = $btab[9]; my $tstrand = 0; ## if query positions are on the reverse strand if ($btab[6] > $btab[7]) { $qfmin = $btab[7]; $qfmax = $btab[6]; $qstrand = 1; } ## if target positions are on the reverse strand if ($btab[8] > $btab[9]) { $tfmin = $btab[9]; $tfmax = $btab[8]; $tstrand = 1; } ## transform the start positions to interbase $qfmin = $qfmin - 1; $tfmin = $tfmin - 1; my $hsp_ref = { 'query_protein_id' => $btab[0], 'target_protein_id' => $btab[5], 'significance' => $btab[20], 'percent_identity' => $btab[10], 'percent_similarity'=> $btab[11], 'query_seqlen' => $btab[2], 'target_seqlen' => $btab[18], 'query_fmin' => $qfmin, 'query_fmax' => $qfmax, 'query_strand' => $btab[17], 'target_fmin' => $tfmin, 'target_fmax' => $tfmax, 'target_strand' => $tstrand, ## target strand is not captured in btab }; push (@hsp_ref_array, $hsp_ref); } if (!defined($qual_stats->{$queryid})) { $qual_stats->{$queryid} = {}; } my $filtered_hsp_ref_array = \\@hsp_ref_array; if($options{'filter_hsps_for_stats'}) { $filtered_hsp_ref_array = &filterBlastpHsps(\\@hsp_ref_array); if(scalar(@hsp_ref_array) != scalar(@$filtered_hsp_ref_array)) { } } my $coverage_arr_ref = &getAvgBlastPPctCoverage($filtered_hsp_ref_array); my $id_sim_arr_ref = &getAvgBlastPIdSim($filtered_hsp_ref_array); $qual_stats->{$queryid}->{$new_subject} = { 'percent_coverage_refseq' => sprintf(\"%.1f\",$coverage_arr_ref->[0]), 'percent_coverage_compseq' => sprintf(\"%.1f\",$coverage_arr_ref->[1]), 'percent_identity' => sprintf(\"%.1f\",$id_sim_arr_ref->[0]), 'percent_similarity' => sprintf(\"%.1f\",$id_sim_arr_ref->[1]), }; # # ################################# for (my $i=0; $i<$maxhsp; $i++) { my @btab = @{$hsps[$i]->{'line'}}; $logger->debug(\"Storing HSP $btab[0] $btab[5] $btab[20]\") if ($logger->is_debug()); $queryid = $btab[0] if ($btab[0] && (!$queryid)); for (my $i=0;$i<scalar(@btab);$i++){ if ($btab[$i] eq 'N/A'){ $btab[$i] = undef; } } ## dbmatch_accession needs to be alphanumeric or _-. ## but the original needs to be passed to createAndAddBtabLine so it can ## be recognized and parsed my $orig_dbmatch_accession = $btab[5]; #$btab[5] =~ s/[^a-z0-9\\_\\.\\-]/_/gi; if(exists $options{'split'} && $options{'split'}){ my $queryname = $btab[0]; if(!exists $docs->{$queryname}){ my $doc = new BSML::BsmlBuilder(); $docs->{$queryname} = $doc; } $docs->{$queryname}->makeCurrentDocument(); $currdoc = $docs->{$queryname}; } my $align = &createAndAddBlastResultLine( doc => $currdoc, query_name => $btab[0], date => $btab[1], query_length => $btab[2], blast_program => $btab[3], search_database => $btab[4], dbmatch_accession => $btab[5], start_query => $btab[6], stop_query => $btab[7], start_hit => $btab[8], stop_hit => $btab[9], percent_identity => $btab[10], percent_similarity => $btab[11], raw_score => $btab[12], bit_score => $btab[13], dbmatch_header => $btab[15], blast_frame => $btab[16], qry_strand => $btab[17], hit_length => $btab[18], e_value => $btab[19], p_value => $btab[20], percent_coverage_refseq => $qual_stats->{$btab[0]}->{$btab[5]}->{'percent_coverage_refseq'}, percent_coverage_compseq => $qual_stats->{$btab[0]}->{$btab[5]}->{'percent_coverage_compseq'}, percent_identity_total => $qual_stats->{$btab[0]}->{$btab[5]}->{'percent_identity'}, percent_similarity_total => $qual_stats->{$btab[0]}->{$btab[5]}->{'percent_similarity'}, class => $class, orig_dbmatch_accession => $orig_dbmatch_accession ); my $seq = $currdoc->returnBsmlSequenceByIDR($btab[5]); } if ($queryid) { my $seq = $currdoc->returnBsmlSequenceByIDR($queryid); } } } my $algorithm = $options{analysis_id}; if ( $options{analysis_id} =~ /(.+)_analysis/ ) { $algorithm = $1; } if(exists $options{'split'} && $options{'split'}){ foreach my $query (keys %$docs){ my $dname = `dirname $options{'output'}`; chomp $dname; my $outputfile = \"$dname/$query.bsml\"; $outputfile =~ s/\\|/_/g; my $doc = $docs->{$query}; $doc->makeCurrentDocument(); $doc->createAndAddAnalysis( id => $options{analysis_id}, sourcename => $outputfile, algorithm => $algorithm, program => $algorithm, ); #print STDERR \"Writing $query to $outputfile\\n\"; $doc->write($outputfile, '', $options{'gzip_output'}); } } else{ $currdoc->createAndAddAnalysis( id => $options{analysis_id}, sourcename => $options{output}, algorithm => $algorithm, program => $algorithm, ); $currdoc->write($options{'output'}, '', $options{'gzip_output'}); } exit(0); ##Adds BSML tags for the case where ##the query sequence returned no hits sub createAndAddNullResult { my %args = @_; my $doc = $args{'doc'}; if( !( $doc->returnBsmlSequenceByIDR( \"$args{'query_name'}\")) ){ my $seq = $doc->createAndAddSequence( \"$args{'query_name'}\", \"$args{'query_name'}\", $args{'query_length'}, $ref_molecule->{$blast_program}, $args{'class'} ); $doc->createAndAddSeqDataImport( $seq, 'fasta', $options{'query_file_path'}, '', $args{'query_name'} ); $seq->addBsmlLink( 'analysis', '#' . $options{'analysis_id'}, 'input_of' ); $doc->createAndAddBsmlAttribute( $seq, 'defline', $deflines->{$args{'query_name'}}, ); } } sub createAndAddBlastResultLine { my %args = @_; my $doc = $args{'doc'}; #determine if the query name and the dbmatch name are a unique pair in the document my $alignment_pair_list = BSML::BsmlDoc::BsmlReturnAlignmentLookup( $args{'query_name'}, $args{'dbmatch_accession'} ); my $alignment_pair = ''; if( $alignment_pair_list ) { $alignment_pair = $alignment_pair_list->[0]; } if( $alignment_pair ) { #add a new BsmlSeqPairRun to the alignment pair and return my $seq_run = $alignment_pair->returnBsmlSeqPairRunR( $alignment_pair->addBsmlSeqPairRun() ); $doc->createAndAddBsmlAttribute($seq_run, 'class', 'match_part'); if( $args{'start_query'} > $args{'stop_query'} ) { $seq_run->setattr( 'refpos', $args{'stop_query'}-1 ); $seq_run->setattr( 'runlength', $args{'start_query'} - $args{'stop_query'} + 1 ); $seq_run->setattr( 'refcomplement', 1 ); } else { $seq_run->setattr( 'refpos', $args{'start_query'}-1 ); $seq_run->setattr( 'runlength', $args{'stop_query'} - $args{'start_query'} + 1 ); $seq_run->setattr( 'refcomplement', 0 ); } #the database sequence is always 5' to 3' $seq_run->setattr( 'comppos', $args{'start_hit'} -1 ) if (defined ($args{'start_hit'})); if ((defined $args{'start_hit'}) and (defined $args{'stop_hit'})) { if ($args{'start_hit'} < $args{'stop_hit'}) { $seq_run->setattr('comprunlength', $args{'stop_hit'} - $args{'start_hit'} + 1 ); } else { $seq_run->setattr('comprunlength', $args{'stop_hit'} - $args{'start_hit'} - 1 ); } } $seq_run->setattr( 'compcomplement', 0 ); $seq_run->setattr( 'runscore', $args{'bit_score'} ) if (defined ($args{'bit_score'})); $seq_run->setattr( 'runprob', $args{'e_value'} ) if (defined ($args{'e_value'})); $seq_run->addBsmlAttr( 'percent_identity', $args{'percent_identity'} ) if (defined ($args{'percent_identity'})); $seq_run->addBsmlAttr( 'percent_similarity', $args{'percent_similarity'} ) if (defined ($args{'percent_similarity'})); ## add hsp percent coverage stats $seq_run->addBsmlAttr( 'percent_coverage_refseq', sprintf(\"%.1f\", $seq_run->{'attr'}->{'runlength'} / $args{'query_length'} * 100) ) if (defined ($seq_run->{'attr'}->{'runlength'}) && defined($args{'query_length'})); if ($blast_program eq 'tblastn'){ $seq_run->addBsmlAttr( 'percent_coverage_compseq', sprintf(\"%.1f\", abs($seq_run->{'attr'}->{'comprunlength'} /3) / $args{'query_length'} * 100) ) if (defined ($seq_run->{'attr'}->{'comprunlength'}) && defined($args{'query_length'})); } else { $seq_run->addBsmlAttr( 'percent_coverage_compseq', sprintf(\"%.1f\", abs($seq_run->{'attr'}->{'comprunlength'}) / $args{'query_length'} * 100) ) if (defined ($seq_run->{'attr'}->{'comprunlength'}) && defined($args{'query_length'})); ## ^^ } $seq_run->addBsmlAttr( 'p_value', $args{'p_value'} ) if (defined ($args{'p_value'})); return $alignment_pair; } #no alignment pair matches, add a new alignment pair and sequence run #check to see if sequences exist in the BsmlDoc, if not add them with basic attributes my $seq; if( !( $doc->returnBsmlSequenceByIDR( \"$args{'query_name'}\")) ){ $seq = $doc->createAndAddSequence( \"$args{'query_name'}\", \"$args{'query_name'}\", $args{'query_length'}, $ref_molecule->{$blast_program}, $args{'class'} ); $doc->createAndAddSeqDataImport( $seq, 'fasta', $options{'query_file_path'}, '', $args{'query_name'} ); $doc->createAndAddBsmlAttribute( $seq, 'defline', $deflines->{$args{'query_name'}}, ); $seq->addBsmlLink( 'analysis', '#' . $options{analysis_id}, 'input_of' ); } if( !( $doc->returnBsmlSequenceByIDR( \"$args{'dbmatch_accession'}\")) ){ $seq = $doc->createAndAddSequence( \"$args{'dbmatch_accession'}\", \"$args{'dbmatch_header'}\", ($args{'hit_length'} || 0), $comp_molecule->{$blast_program}, $args{'class'} ); $doc->createAndAddSeqDataImport( $seq, 'fasta', $args{'search_database'}, '', $args{'dbmatch_accession'} ); ## see if the dbmatch_header format is recognized. if so, add some cross-references if (defined $args{'dbmatch_header'}) { $doc->createAndAddCrossReferencesByParse( sequence => $seq, string => $args{orig_dbmatch_accession} ); } } $alignment_pair = $doc->returnBsmlSeqPairAlignmentR( $doc->addBsmlSeqPairAlignment() ); ## to the alignment pair, add a Link to the analysis $alignment_pair->addBsmlLink( 'analysis', '#' . $options{analysis_id}, 'computed_by' ); $alignment_pair->setattr( 'refseq', \"$args{'query_name'}\" ) if (defined ($args{'query_name'})); $alignment_pair->setattr( 'compseq', \"$args{'dbmatch_accession'}\" ) if (defined ($args{'dbmatch_accession'})); BSML::BsmlDoc::BsmlSetAlignmentLookup( \"$args{'query_name'}\", \"$args{'dbmatch_accession'}\", $alignment_pair ); $alignment_pair->setattr( 'refxref', $options{'query_file_path'}.':'.$args{'query_name'} ) if (defined ($args{'query_name'})); $alignment_pair->setattr( 'refstart', 0 ); $alignment_pair->setattr( 'refend', $args{'query_length'} ) if (defined ($args{'query_length'})); $alignment_pair->setattr( 'reflength', $args{'query_length'} ) if (defined ($args{'query_length'})); $alignment_pair->setattr( 'method', $args{'blast_program'} ) if (defined ($args{'blast_program'})); $alignment_pair->setattr( 'compxref', $args{'search_database'}.':'.$args{'dbmatch_accession'} ) if ((defined ($args{'search_database'})) and (defined ($args{'dbmatch_accession'}))); $alignment_pair->setattr( 'class', 'match' ); ## add average percent coverage values to alignment pair $alignment_pair->addBsmlAttr( 'percent_coverage_refseq', $args{'percent_coverage_refseq'} ) if (defined ($args{'percent_coverage_refseq'})); $alignment_pair->addBsmlAttr( 'percent_coverage_compseq', $args{'percent_coverage_compseq'} ) if (defined ($args{'percent_coverage_compseq'})); ## add percent identity and similarity values to alignment pair $alignment_pair->addBsmlAttr( 'percent_identity', $args{'percent_identity_total'} ) if (defined ($args{'percent_identity_total'})); $alignment_pair->addBsmlAttr( 'percent_similarity', $args{'percent_similarity_total'} ) if (defined ($args{'percent_similarity_total'})); my $seq_run = $alignment_pair->returnBsmlSeqPairRunR( $alignment_pair->addBsmlSeqPairRun() ); $doc->createAndAddBsmlAttribute($seq_run, 'class', 'match_part'); if( $args{'start_query'} > $args{'stop_query'} ) { $seq_run->setattr( 'refpos', $args{'stop_query'}-1 ); $seq_run->setattr( 'runlength', $args{'start_query'} - $args{'stop_query'} + 1 ); $seq_run->setattr( 'refcomplement', 1 ); } else { $seq_run->setattr( 'refpos', $args{'start_query'} -1 ); $seq_run->setattr( 'runlength', $args{'stop_query'} - $args{'start_query'} + 1 ); $seq_run->setattr( 'refcomplement', 0 ); } #the database sequence is always 5' to 3' $seq_run->setattr( 'comppos', $args{'start_hit'} -1 ) if (defined ($args{'start_hit'})); if ((defined $args{'start_hit'}) and (defined $args{'stop_hit'})) { if ($args{'start_hit'} < $args{'stop_hit'}) { $seq_run->setattr('comprunlength', $args{'stop_hit'} - $args{'start_hit'} + 1 ); } else { $seq_run->setattr('comprunlength', $args{'stop_hit'} - $args{'start_hit'} - 1 ); } } $seq_run->setattr( 'compcomplement', 0 ); $seq_run->setattr( 'runscore', $args{'bit_score'} ) if (defined ($args{'bit_score'})); $seq_run->setattr( 'runprob', $args{'e_value'} ) if (defined ($args{'e_value'})); $seq_run->addBsmlAttr( 'percent_identity', $args{'percent_identity'} ) if (defined ($args{'percent_identity'})); $seq_run->addBsmlAttr( 'percent_similarity', $args{'percent_similarity'} ) if (defined ($args{'percent_similarity'})); ## add hsp percent coverage stats $seq_run->addBsmlAttr( 'percent_coverage_refseq', sprintf(\"%.1f\", $seq_run->{'attr'}->{'runlength'} / $args{'query_length'} * 100) ) if (defined ($seq_run->{'attr'}->{'runlength'}) && defined($args{'query_length'})); if ($blast_program eq 'tblastn'){ $seq_run->addBsmlAttr( 'percent_coverage_compseq', sprintf(\"%.1f\", abs($seq_run->{'attr'}->{'comprunlength'} /3) / $args{'query_length'} * 100) ) if (defined ($seq_run->{'attr'}->{'comprunlength'}) && defined($args{'query_length'})); } else { $seq_run->addBsmlAttr( 'percent_coverage_compseq', sprintf(\"%.1f\", abs($seq_run->{'attr'}->{'comprunlength'}) / $args{'query_length'} * 100) ) if (defined ($seq_run->{'attr'}->{'comprunlength'}) && defined($args{'query_length'})); ## ^^ } $seq_run->addBsmlAttr( 'chain_number', $args{'chain_number'} ) if (defined ($args{'chain_number'})); $seq_run->addBsmlAttr( 'segment_number', $args{'segment_number'} ) if (defined ($args{'segment_number'})); $seq_run->addBsmlAttr( 'p_value', $args{'p_value'} ) if (defined ($args{'p_value'})); return $alignment_pair; } sub getAvgBlastPIdSim { my($hsps) = @_; my $sim_sum=0; my $id_sum=0; my $q_len_sum=0; my $numHsps = 0; # Group by query and target id my $hspsByQuery = &groupByMulti($hsps, ['query_protein_id', 'target_protein_id']); foreach my $queryId (keys %$hspsByQuery) { my $hspsByTarget = $hspsByQuery->{$queryId}; foreach my $subjId (keys %$hspsByTarget) { my $shsps = $hspsByTarget->{$subjId}; # my $querySeqLen = $shsps->[0]->{'query_seqlen'}; # my $targetSeqLen = $shsps->[0]->{'target_seqlen'}; foreach my $hsp(@{$shsps}) { ++$numHsps; my $q_seg_len = $hsp->{'query_fmax'} - $hsp->{'query_fmin'}; $q_len_sum += $q_seg_len; $sim_sum += $hsp->{'percent_similarity'} * $q_seg_len; $id_sum += $hsp->{'percent_identity'} * $q_seg_len; } } } if ($numHsps == 0) { return undef; } else { return [($id_sum/$q_len_sum), ($sim_sum/$q_len_sum)]; } } ## Returns an array reference where ## [0] = query percent coverage, ## and [1] = target percent coverage sub getAvgBlastPPctCoverage { my($hsps) = @_; my $qsum=0; my $tsum=0; my $numHsps=0; # Group by query and target id my $hspsByQuery = &groupByMulti($hsps, ['query_protein_id', 'target_protein_id']); # Loop per query ID and subject ID foreach my $queryId (keys %$hspsByQuery) { my $hspsByTarget = $hspsByQuery->{$queryId}; foreach my $subjId (keys %$hspsByTarget) { ++$numHsps; my $shsps = $hspsByTarget->{$subjId}; my $querySeqLen = $shsps->[0]->{'query_seqlen'}; my $targetSeqLen = $shsps->[0]->{'target_seqlen'}; # Map the interval locations for each run in this hit. my @queryIntervals = map { {'fmin' => $_->{'query_fmin'}, 'fmax' => $_->{'query_fmax'}, 'strand' => $_->{'query_strand'}} } @$shsps; my @targetIntervals = map { {'fmin' => $_->{'target_fmin'}, 'fmax' => $_->{'target_fmax'}, 'strand' => $_->{'target_strand'}} } @$shsps; # For any overlapping intervals, combine them my $mergedQueryIntervals = &mergeOverlappingIntervals(\\@queryIntervals); my $mergedTargetIntervals = &mergeOverlappingIntervals(\\@targetIntervals); my $queryHitLen = 0; my $targetHitLen = 0; # Combine all merged interval lengths to get the query and subject hit lengths map { $queryHitLen += ($_->{'fmax'} - $_->{'fmin'}); } @$mergedQueryIntervals; map { $targetHitLen += ($_->{'fmax'} - $_->{'fmin'}); } @$mergedTargetIntervals; my $num_query_intervals = scalar @$mergedQueryIntervals; my $num_target_intervals = scalar @$mergedTargetIntervals; # Calculate query and subject sequence coverage $qsum += ($queryHitLen / $querySeqLen) / $num_query_intervals; if ($blast_program eq 'tblastn') { $tsum += (($targetHitLen / 3) / $querySeqLen) / $num_target_intervals; } else { $tsum += ($targetHitLen / $querySeqLen) / $num_target_intervals; } } } if ($numHsps == 0) { return undef; } else { return [($qsum/$numHsps*100.0), ($tsum/$numHsps*100.0)]; } } # Generalized version of groupBy sub groupByMulti { my($arrayref, $keyFields) = @_; my $nKeys = scalar(@$keyFields); my $groups = {}; foreach my $a (@$arrayref) { my @keyValues = map { $a->{$_} } @$keyFields; my $hash = $groups; for (my $i = 0;$i < $nKeys;++$i) { my $kv = $keyValues[$i]; if ($i < ($nKeys-1)) { $hash->{$kv} = {} if (!defined($hash->{$kv})); $hash = $hash->{$kv}; } else { $hash->{$kv} = [] if (!defined($hash->{$kv})); push(@{$hash->{$kv}}, $a); } } } return $groups; } # Generate a new set of intervals by merging any that overlap in the original set. # sub mergeOverlappingIntervals { my($intervals) = @_; # result set of intervals my $merged = []; # sort all intervals by fmin my @sorted = sort { $a->{'fmin'} <=> $b->{'fmin'} } @$intervals; # current interval my $current = undef; foreach my $i (@sorted) { if (!defined($current)) { # case 1: no current interval $current = $i; } else { # case 2: compare current interval to interval $i if ($i->{'fmin'} > $current->{'fmax'}) { # case 2a: no overlap push(@$merged, $current); $current = $i; } elsif ($i->{'fmax'} > $current->{'fmax'}) { # case 2b: overlap, with $i ending to the right of $current $current->{'fmax'} = $i->{'fmax'}; } } } push(@$merged, $current) if (defined($current)); return $merged; } # Returns only those BLAST HSPs that contributed to the best Sum(P) value # reported for each subject/query sequence pair. # sub filterBlastpHsps { my($links) = @_; my $linksByQuery = &groupByMulti($links, ['query_protein_id', 'target_protein_id']); my $result = []; # Aggregate all HSPs with the same subject and query sequence foreach my $queryId (keys %$linksByQuery) { my $linksBySubject = $linksByQuery->{$queryId}; foreach my $subjId (keys %$linksBySubject) { my $slinks = $linksBySubject->{$subjId}; my @sortedLinks = sort { $a->{'significance'} <=> $b->{'significance'} } @$slinks; # heuristic - assume that all HSPs with the same Sum(P) as the best are contributing to that Sum(p) score my $bestScore = $sortedLinks[0]->{'significance'}; foreach my $sl (@sortedLinks) { last if ($sl->{'significance'} > $bestScore); push(@$result, $sl); } } } return $result; } sub check_parameters { my $options = shift; unless (-e $options{'input'}) { $logger->logdie(\"input option not passed or does not exist!\"); exit(1); } unless (defined $options{'output'}) { $logger->logdie(\"output option not passed\"); exit(1); } ## handle some defaults if (! $options{'analysis_id'}) { $options{'analysis_id'} = 'unknown_analysis'; } if (! $options{'query_file_path'}) { $logger->logdie(\"Must provide value for --query_file_path\"); } } ## retrieve deflines from a fasta file sub get_deflines { my ($fasta_file) = @_; my $deflines = {}; my $ifh; if (! -e $fasta_file) { if (-e $fasta_file.\".gz\") { $fasta_file .= \".gz\"; } elsif (-e $fasta_file.\".gzip\") { $fasta_file .= \".gzip\"; } } if ($fasta_file =~ /\\.(gz|gzip)$/) { open ($ifh, \"<:gzip\", $fasta_file) || $logger->logdie(\"can't open input file '$fasta_file': $!\"); } else { open ($ifh, $fasta_file) || $logger->logdie(\"Failed opening '$fasta_file' for reading: $!\"); } while (<$ifh>) { unless (/^>/) { next; } chomp; if (/^>((\\S+).*)$/) { $deflines->{$2} = $1; } } close $ifh; if (scalar(keys(%{$deflines})) < 1) { $logger->warn(\"defline lookup failed for '$fasta_file'\"); } return $deflines; } #See http://www.ncbi.nlm.nih.gov/BLAST/tutorial/Altschul-1.html sub calculate_pvalue { my $evalue = shift; my $estimate = 0.57721566490153; #my $p = 1 - (bexp( (-1*$evalue), 4 ) ); ( 1 - ( $estimate**(-1*$evalue) ) ); return $evalue; }"
    },
    {
      "tool": "blastbtab",
      "converter_script": "blastbtab2bsml.pl",
      "name": "blastbtab2bsml.pl  - convert info stored in btab files into BSML documents",
      "synopsis": "USAGE:  blastbtab2bsml.pl -b btab_dir -o blastp.bsml",
      "description": "blastbtab2bsml.pl is designed to convert information in btab files into BSML documents.\n\nNOTE:  \n\nCalling the script name with NO flags/options or --help will display the syntax requirement.\n\n=cut\n\n\nuse strict;\nuse Getopt::Long qw(:config no_ignore_case no_auto_abbrev);\nuse English;\nuse File::Basename;\nuse File::Path;\nuse Pod::Usage;\nuse Ergatis::Logger;\nuse BSML::BsmlRepository;\nuse BSML::BsmlBuilder;\nuse BSML::BsmlParserTwig;\n\nmy %options = ();\nmy $results = GetOptions (\\%options, \n              'analysis_id|a=s',\n              'btab_dir|b=s', \n              'btab_file|f=s',\n              'query_file_path|q=s',\n              'output|o=s', \n              'max_hsp_count|m=s',\n              'pvalue|p=s', \n              'log|l=s',\n              'debug=s',\n              'class|c=s',\n              'gzip|z=s',\n              'help|h') || pod2usage();\n\nmy $logfile = $options{'log'} || Ergatis::Logger::get_default_logfilename();\nmy $logger = new Ergatis::Logger('LOG_FILE'=>$logfile,\n                  'LOG_LEVEL'=>$options{'debug'});\n$logger = $logger->get_logger();\n\nif($options{'help'}) {\n    pod2usage();\n}\n\nif($options{'pvalue'} eq \"\"){\n    $options{'pvalue'} = 10;\n}\n\nmy $class;\nif (!defined($options{'class'})){\n    $logger->logdie(\"class was not defined\");\n}\nelse{\n    $class = $options{'class'};\n}\n\n# display documentation\nif( $options{'help'} ){\n    pod2usage( {-exitval=>0, -verbose => 2, -output => \\*STDOUT} );\n}\n\n&check_parameters(\\%options);\n\nmy $files = &get_btab_files($options{'btab_dir'},$options{'btab_file'});\n\nmy $doc = new BSML::BsmlBuilder();\n\nmy $seq_data_import_file = $options{'query_file_path'};\n\n$seq_data_import_file =~ s/\\.gz$|\\.gzip$//;\n\nmy $deflines = get_deflines($options{'query_file_path'});\n\n#generate lookups\n$doc->makeCurrentDocument();\nparse_blast_btabs($files);\n\n## create sequence stubs for input sequences with null output\nforeach my $seq_id(keys(%{$deflines})) {\n    if(!($doc->returnBsmlSequenceByIDR($seq_id))){\n        my $seq = $doc->createAndAddSequence( \n                                                $seq_id, \n                                                $seq_id, \n                                                '',     # length\n                                                '',   # molecule \n                                                '',     # class\n                                            );\n        \n        $seq->addBsmlLink('analysis', '#' . $options{analysis_id}, 'input_of');\n        $doc->createAndAddBsmlAttribute( $seq, 'defline', $deflines->{$seq_id} );\n        $doc->createAndAddSeqDataImport( $seq, 'fasta', $seq_data_import_file, '', $seq_id);\n    }\n}\n\n## add the analysis element\nmy $program = $options{analysis_id};\n   $program =~ s/_analysis//;\n$doc->createAndAddAnalysis(\n                            id => $options{analysis_id},\n                            sourcename => $options{'output'},\n                            algorithm => $program,\n                            program => $program,\n                          );\n\nif($options{'gzip'}){\n    $doc->write($options{'output'},undef,1);\n}\nelse{\n    $doc->write($options{'output'});\n}\n\nsub parse_blast_btabs {\n\n    my $btab_files = shift;\n\n    my $num;\n    foreach my $file(@$btab_files) {\n    $num++;\n    open (BTAB, \"$file\") or $logger->logdie(\"Unable to open \\\"$file\\\" due to $!\");\n    $logger->debug(\"opening $file $num using pvalue p_value $options{'pvalue'}, hsp cutoff $options{'max_hsp_count'}\") if($logger->is_debug());\n    my $hsplookup;\n    while(my $line = <BTAB>) {\n        chomp($line);\n        \n        #Bioperl seems to place control characters in some btab files (when using wu-blast2btab)\n        #These characters are not allowed in XML, so removing them here\n        $line =~ s/\\cA/ /g;\n\n        my @btab = split(\"\\t\", $line);\n        if(($btab[20] <= $options{'pvalue'}) && ($btab[0] ne \"\") && ($btab[5] ne \"\")){\n        if(!(exists $hsplookup->{$btab[0]}->{$btab[5]})){\n            $hsplookup->{$btab[0]}->{$btab[5]} = [];\n        }\n        push @{$hsplookup->{$btab[0]}->{$btab[5]}},{'pvalue'=>$btab[20],\n                                'line'=>$line};\n        }\n        else{\n        $logger->debug(\"Skipping $btab[0] $btab[5] pvalue $btab[20] above pvalue cutoff of $options{'pvalue'}\") if($logger->is_debug());\n        }\n    }\n    close BTAB;\n    \n    ## This block prepares an array of HSP data structured so that we can use\n    ## existing subs taken from Sybil::Util to calculate coverage/identity info\n    my $cov_qual_stats = {};\n    my @hsp_ref_array = ();\n    my $new_subject = '';\n    foreach my $query (keys %$hsplookup) {\n        foreach my $subject (keys %{$hsplookup->{$query}}){\n            my @hsps = sort {$a->{'pvalue'} <=> $b->{'pvalue'}} @{$hsplookup->{$query}->{$subject}};\n            my $maxhsp;\n            if($options{'max_hsp_count'} ne \"\"){\n                $maxhsp = ($options{'max_hsp_count'}<scalar(@hsps)) ? $options{'max_hsp_count'} : scalar(@hsps);\n            } else {\n                $maxhsp = scalar(@hsps);\n            }\n            my $queryid;\n            for(my $i=0;$i<$maxhsp;$i++){\n                my $line = $hsps[$i]->{'line'};\n                my @btab = split(\"\\t\", $line);\n                $queryid = $btab[0] if($btab[0] && (!$queryid));\n\n                for (my $i=0;$i<scalar(@btab);$i++){\n                    if ($btab[$i] eq 'N/A'){\n                        $btab[$i] = undef;\n                    }\n                }\n                \n                my $orig_dbmatch_accession = $btab[5];\n                $btab[5] =~ s/[^a-z0-9\\_\\.\\-]/_/gi;\n\n                $new_subject = $btab[5];\n                \n                my $qfmin = $btab[6];\n                my $qfmax = $btab[7];\n                my $qstrand = 0;\n                my $tfmin = $btab[8];\n                my $tfmax = $btab[9];\n                my $tstrand = 0;\n                    \n                ## if query positions are on the reverse strand\n                if ($btab[6] > $btab[7]) {\n                        $qfmin = $btab[7];\n                        $qfmax = $btab[6];\n                        $qstrand = 1;\n                }\n                \n                ## if target positions are on the reverse strand\n                if ($btab[8] > $btab[9]) {\n                        $tfmin = $btab[9];\n                        $tfmax = $btab[8];\n                        $tstrand = 1;\n                }\n                \n                ## transform the start positions to interbase \n                $qfmin = $qfmin - 1;\n                $tfmin = $tfmin - 1;    \n                    \n                my $hsp_ref = { \n                                'query_protein_id'  => $btab[0],\n                                'target_protein_id' => $btab[5],\n                                'significance'      => $btab[20],\n                                'percent_identity'  => $btab[10],\n                                'query_seqlen'      => $btab[2],\n                                'target_seqlen'     => $btab[18],\n                                'query_fmin'        => $qfmin,\n                                'query_fmax'        => $qfmax,\n                                'query_strand'      => $btab[17],\n                                'target_fmin'       => $tfmin,\n                                'target_fmax'       => $tfmax,\n                                'target_strand'     => $tstrand, ## target strand is not captured in btab \n                              };\n                push (@hsp_ref_array, $hsp_ref);\n            }\n            if (!defined($cov_qual_stats->{$query})) {\n               $cov_qual_stats->{$query} = {};\n            }\n            \n            my $coverage_arr_ref = &getAvgBlastPPctCoverage(\\@hsp_ref_array);\n        \n            $cov_qual_stats->{$query}->{$new_subject} = {\n                'percent_coverage_refseq'   =>  sprintf(\"%.1f\",$coverage_arr_ref->[0]),\n                'percent_coverage_compseq'      =>  sprintf(\"%.1f\",$coverage_arr_ref->[1]),\n                                                        };\n        }\n    }\n\n    foreach my $query (keys %$hsplookup){\n        foreach my $subject (keys %{$hsplookup->{$query}}){\n        my @hsps = sort {$a->{'pvalue'} <=> $b->{'pvalue'}} @{$hsplookup->{$query}->{$subject}};\n        my $maxhsp;\n        if($options{'max_hsp_count'} ne \"\"){\n            $maxhsp = ($options{'max_hsp_count'}<scalar(@hsps)) ? $options{'max_hsp_count'} : scalar(@hsps);\n        }\n        else{\n            $maxhsp = scalar(@hsps);\n        }\n        my $queryid;\n        for(my $i=0;$i<$maxhsp;$i++){\n            my $line = $hsps[$i]->{'line'};\n            my @btab = split(\"\\t\", $line);\n            $logger->debug(\"Storing HSP $btab[0] $btab[5] $btab[20]\") if($logger->is_debug());\n            $queryid = $btab[0] if($btab[0] && (!$queryid));\n\n            for (my $i=0;$i<scalar(@btab);$i++){\n            if ($btab[$i] eq 'N/A'){\n                $btab[$i] = undef;\n            }\n            }\n            \n            ## dbmatch_accession needs to be alphanumeric or _-.\n            ##  but the original needs to be passed to createAndAddBtabLine so it can\n            ##  be recognized and parsed\n            my $orig_dbmatch_accession = $btab[5];\n            $btab[5] =~ s/[^a-z0-9\\_\\.\\-]/_/gi;\n\n            my $align = &createAndAddBtabLine(\n                              doc                => $doc,\n                              query_name         => $btab[0],\n                              date               => $btab[1],\n                              query_length       => $btab[2],\n                              blast_program      => $btab[3],\n                              search_database    => $btab[4],\n                              dbmatch_accession  => $btab[5],\n                              start_query        => $btab[6],\n                              stop_query         => $btab[7],\n                              start_hit          => $btab[8],\n                              stop_hit           => $btab[9],\n                              percent_identity   => $btab[10],\n                              percent_similarity => $btab[11],\n                              raw_score          => $btab[12],\n                              bit_score          => $btab[13],\n                              dbmatch_header     => $btab[15],\n                              blast_frame        => $btab[16],\n                              qry_strand         => $btab[17],\n                              hit_length         => $btab[18],\n                              e_value            => $btab[19],\n                              p_value            => $btab[20],\n                              percent_coverage_refseq    => $cov_qual_stats->{$btab[0]}->{$btab[5]}->{'percent_coverage_refseq'},\n                              percent_coverage_compseq       => $cov_qual_stats->{$btab[0]}->{$btab[5]}->{'percent_coverage_compseq'},\n                              class              => $class,\n                              orig_dbmatch_accession => $orig_dbmatch_accession\n                              );\n\n            my $seq = $doc->returnBsmlSequenceByIDR($btab[5]);\n\n\n\n        }\n        if($queryid){\n            my $seq = $doc->returnBsmlSequenceByIDR($queryid);\n        }\n        }\n    }\n    }\n}\n    \n\nsub get_btab_files{\n    my ($directory,$file) = @_;\n    my @files;\n    if(-d $directory){\n    opendir(DIR, $directory) or die \"Unable to access $directory due to $!\";\n    while( my $filename = readdir(DIR)) {\n        if($filename =~ /(.+)\\.btab$/) {\n        push (@files, \"$directory/$filename\");\n        }\n    }\n    }\n    if($file ne \"\"){\n    push @files,$file;\n    }\n    return \\@files;\n}\n\n\nsub check_parameters{\n    my ($options) = @_;\n    \n    if(!$options{'output'} or (!$options{'btab_dir'} && !$options{'btab_file'})) {\n    pod2usage({-exitval => 2,  -message => \"$0: All the required options are not specified\", -verbose => 1, -output => \\*STDERR});    \n    }\n\n    if((! -d $options{'btab_dir'}) && (! -e $options{'btab_file'})) {\n    print STDERR \"btab directory \\\"$options{'btab_dir'}\\\" or btab file $options{'btab_file'} cannot be found.  Aborting...\\n\";\n    exit 5;\n    } \n\n    ## handle some defaults\n    if (! $options{analysis_id}) {\n        $options{analysis_id} = 'unknown_analysis';\n    }\n\n    return 1;\n}\n\nsub createAndAddBtabLine {\n\n    my %args = @_;\n    my $doc = $args{'doc'};\n\n#    my $orig_dbmatch_accession = $args{dbmatch_accession};\n#    $args{dbmatch_accession} =~ s/[^a-z0-9\\_]/_/gi;\n\n    #determine if the query name and the dbmatch name are a unique pair in the document\n    my $alignment_pair_list = BSML::BsmlDoc::BsmlReturnAlignmentLookup( $args{'query_name'}, $args{'dbmatch_accession'} );\n\n    my $alignment_pair = '';\n    if( $alignment_pair_list ) {\n        $alignment_pair = $alignment_pair_list->[0];\n    }\n\n    if( $alignment_pair ) {\n        #add a new BsmlSeqPairRun to the alignment pair and return\n        my $seq_run = $alignment_pair->returnBsmlSeqPairRunR( $alignment_pair->addBsmlSeqPairRun() );\n\n        if( $args{'start_query'} > $args{'stop_query'} ) {\n            $seq_run->setattr( 'refpos', $args{'stop_query'}-1 );\n            $seq_run->setattr( 'runlength', $args{'start_query'} - $args{'stop_query'} + 1 );\n            $seq_run->setattr( 'refcomplement', 1 );\n        } else {\n            $seq_run->setattr( 'refpos', $args{'start_query'}-1 );\n            $seq_run->setattr( 'runlength', $args{'stop_query'} - $args{'start_query'} + 1 );\n            $seq_run->setattr( 'refcomplement', 0 );\n        }\n\n        #the database sequence is always 5' to 3'\n        $seq_run->setattr( 'comppos', $args{'start_hit'} -1 )                                if (defined ($args{'start_hit'}));\n        $seq_run->setattr( 'comprunlength', $args{'stop_hit'} - $args{'start_hit'} + 1 )     if ((defined ($args{'start_hit'})) and (defined ($args{'stop_hit'})));\n        $seq_run->setattr( 'compcomplement', 0 );\n        $seq_run->setattr( 'runscore', $args{'bit_score'} )                                  if (defined ($args{'bit_score'}));\n        $seq_run->setattr( 'runprob', $args{'e_value'} )                                     if (defined ($args{'e_value'}));\n        $seq_run->addBsmlAttr( 'class', 'match_part' );\n        $seq_run->addBsmlAttr( 'percent_identity', $args{'percent_identity'} )               if (defined ($args{'percent_identity'}));   \n        $seq_run->addBsmlAttr( 'percent_similarity', $args{'percent_similarity'} )           if (defined ($args{'percent_similarity'}));\n        $seq_run->addBsmlAttr( 'percent_coverage_refseq', $args{'percent_coverage_refseq'} )                 if (defined ($args{'percent_coverage_refseq'}));   \n        $seq_run->addBsmlAttr( 'percent_coverage_compseq', $args{'percent_coverage_compseq'} )                       if (defined ($args{'percent_coverage_compseq'}));   \n        $seq_run->addBsmlAttr( 'p_value', $args{'p_value'} )                                 if (defined ($args{'p_value'}));\n        $seq_run->addBsmlAttr( 'p_value', $args{'p_value'} )                                 if (defined ($args{'p_value'}));\n\n\n        return $alignment_pair;\n    }\n\n    #no alignment pair matches, add a new alignment pair and sequence run\n    #check to see if sequences exist in the BsmlDoc, if not add them with basic attributes\n    my $seq;\n    \n    if( !( $doc->returnBsmlSequenceByIDR( \"$args{'query_name'}\")) ){\n        $seq = $doc->createAndAddSequence( \"$args{'query_name'}\", \"$args{'query_name'}\", $args{'query_length'}, '', $args{'class'} );\n        $seq->addBsmlLink('analysis', '#' . $options{analysis_id}, 'input_of');\n        \n        my $defline = $deflines->{$args{'query_name'}};\n        $doc->createAndAddBsmlAttribute( $seq, 'defline', $defline );\n        \n        if ($options{'query_file_path'}) {\n            $doc->createAndAddSeqDataImport( $seq, 'fasta', $seq_data_import_file, '', \"$args{'query_name'}\");\n        }\n        \n    }\n    \n    if( !( $doc->returnBsmlSequenceByIDR( \"$args{'dbmatch_accession'}\")) ){\n        $seq = $doc->createAndAddSequence( \"$args{'dbmatch_accession'}\", \"$args{'dbmatch_header'}\", ($args{'hit_length'} || 0), '', $args{'class'} );\n        $doc->createAndAddBsmlAttribute( $seq, 'defline', \"$args{orig_dbmatch_accession} $args{dbmatch_header}\" );\n\n        ## see if the dbmatch_header format is recognized.  if so, add some cross-references\n        if (defined $args{'dbmatch_header'}) {\n            $doc->createAndAddCrossReferencesByParse( sequence => $seq, string => $args{orig_dbmatch_accession} );\n        }\n    }\n    \n    $alignment_pair = $doc->returnBsmlSeqPairAlignmentR( $doc->addBsmlSeqPairAlignment() );\n    \n    ## to the alignment pair, add a Link to the analysis\n    $alignment_pair->addBsmlLink('analysis', '#' . $options{analysis_id}, 'computed_by');\n\n    $alignment_pair->setattr( 'refseq', \"$args{'query_name'}\" )                                 if (defined ($args{'query_name'}));\n    $alignment_pair->setattr( 'compseq', \"$args{'dbmatch_accession'}\" )                         if (defined ($args{'dbmatch_accession'}));\n    \n    BSML::BsmlDoc::BsmlSetAlignmentLookup( \"$args{'query_name'}\", \"$args{'dbmatch_accession'}\", $alignment_pair );\n\n    $alignment_pair->setattr( 'refxref', ':'.$args{'query_name'})        if (defined ($args{'query_name'}));                     \n    $alignment_pair->setattr( 'refstart', 0 );\n    $alignment_pair->setattr( 'refend', $args{'query_length'} )          if (defined ($args{'query_length'}));\n    $alignment_pair->setattr( 'reflength', $args{'query_length'} )       if (defined ($args{'query_length'}));\n    $alignment_pair->setattr( 'method', $args{'blast_program'} )         if (defined ($args{'blast_program'}));\n    $alignment_pair->setattr( 'class', 'match' );\n    $alignment_pair->setattr( 'compxref', $args{'search_database'}.':'.$args{'dbmatch_accession'} )  if ((defined ($args{'search_database'})) and (defined ($args{'dbmatch_accession'})));\n\n    my $seq_run = $alignment_pair->returnBsmlSeqPairRunR( $alignment_pair->addBsmlSeqPairRun() );\n\n    if( $args{'start_query'} > $args{'stop_query'} ) {\n        $seq_run->setattr( 'refpos', $args{'stop_query'}-1 );\n        $seq_run->setattr( 'runlength', $args{'start_query'} - $args{'stop_query'} + 1 );\n        $seq_run->setattr( 'refcomplement', 1 );\n    } else {\n        $seq_run->setattr( 'refpos', $args{'start_query'} -1);\n        $seq_run->setattr( 'runlength', $args{'stop_query'} - $args{'start_query'} + 1 );\n        $seq_run->setattr( 'refcomplement', 0 );\n    }\n\n    #the database sequence is always 5' to 3'\n    $seq_run->setattr( 'comppos', $args{'start_hit'} -1)                                   if (defined  ($args{'start_hit'}));\n    $seq_run->setattr( 'comprunlength', ($args{'stop_hit'} - $args{'start_hit'} + 1))      if ((defined ($args{'start_hit'})) and (defined ($args{'stop_hit'})));\n    $seq_run->setattr( 'compcomplement', 0 );\n    $seq_run->setattr( 'runscore', $args{'bit_score'} )                                    if (defined  ($args{'bit_score'}));\n    $seq_run->setattr( 'runprob', $args{'e_value'} )                                       if (defined  ($args{'e_value'}));\n    $seq_run->addBsmlAttr( 'class', 'match_part' );\n    $seq_run->addBsmlAttr( 'percent_identity', $args{'percent_identity'} )                 if (defined  ($args{'percent_identity'}));\n    $seq_run->addBsmlAttr( 'percent_similarity', $args{'percent_similarity'} )             if (defined  ($args{'percent_similarity'}));\n    $seq_run->addBsmlAttr( 'percent_coverage_refseq', $args{'percent_coverage_refseq'} )                   if (defined ($args{'percent_coverage_refseq'}));   \n    $seq_run->addBsmlAttr( 'percent_coverage_compseq', $args{'percent_coverage_compseq'} )                         if (defined ($args{'percent_coverage_compseq'}));   \n    $seq_run->addBsmlAttr( 'chain_number', $args{'chain_number'} )                         if (defined  ($args{'chain_number'}));\n    $seq_run->addBsmlAttr( 'segment_number', $args{'segment_number'} )                     if (defined  ($args{'segment_number'}));\n    $seq_run->addBsmlAttr( 'p_value', $args{'p_value'} )                                   if (defined  ($args{'p_value'}));\n\n    return $alignment_pair;\n}\n\n\n## Returns an array reference where \n##     [0] = query percent coverage, \n## and [1] = target percent coverage\nsub getAvgBlastPPctCoverage {\n    my($hsps) = @_;\n    my $qsum = 0;\n    my $tsum = 0;\n    my $numHsps = 0;\n\n    # Group by query and target id\n    my $hspsByQuery = &groupByMulti($hsps, ['query_protein_id', 'target_protein_id']);\n\n    foreach my $queryId (keys %$hspsByQuery) {\n        my $hspsByTarget = $hspsByQuery->{$queryId};\n\n        foreach my $subjId (keys %$hspsByTarget) {\n            ++$numHsps;\n            my $shsps = $hspsByTarget->{$subjId};\n            my $querySeqLen = $shsps->[0]->{'query_seqlen'};\n            my $targetSeqLen = $shsps->[0]->{'target_seqlen'};\n\n            my @queryIntervals = map { {'fmin' => $_->{'query_fmin'}, 'fmax' => $_->{'query_fmax'}, 'strand' => $_->{'query_strand'}} } @$shsps;\n            my @targetIntervals = map { {'fmin' => $_->{'target_fmin'}, 'fmax' => $_->{'target_fmax'}, 'strand' => $_->{'target_strand'}} } @$shsps;\n\n            my $mergedQueryIntervals = &mergeOverlappingIntervals(\\@queryIntervals);\n            my $mergedTargetIntervals = &mergeOverlappingIntervals(\\@targetIntervals);\n\n            my $queryHitLen = 0;\n            my $targetHitLen = 0;\n\n            map { $queryHitLen += ($_->{'fmax'} - $_->{'fmin'}); } @$mergedQueryIntervals;\n            map { $targetHitLen += ($_->{'fmax'} - $_->{'fmin'}); } @$mergedTargetIntervals;\n\n            $qsum += $queryHitLen / $querySeqLen;\n            $tsum += $targetHitLen / $targetSeqLen;\n        }\n    }\n\n    if ($numHsps == 0) {\n        return undef;\n    } else {\n        return [($qsum/$numHsps*100.0), ($tsum/$numHsps*100.0)];\n    }\n    #return ($numHsps > 0) ? ($sum/($numHsps * 2) * 100.0) : undef;\n}\n\n# Generalized version of groupBy \nsub groupByMulti {\n    my($arrayref, $keyFields) = @_;\n    my $nKeys = scalar(@$keyFields);\n    my $groups = {};\n\n    foreach my $a (@$arrayref) {\n        my @keyValues = map { $a->{$_} } @$keyFields;\n        my $hash = $groups;\n\n        for (my $i = 0;$i < $nKeys;++$i) {\n            my $kv = $keyValues[$i];\n\n            if ($i < ($nKeys-1)) {\n                $hash->{$kv} = {} if (!defined($hash->{$kv}));\n                $hash = $hash->{$kv};\n            } else {\n                $hash->{$kv} = [] if (!defined($hash->{$kv}));\n                push(@{$hash->{$kv}}, $a);\n            }\n        }\n    }\n    return $groups;\n}\n\n# Generate a new set of intervals by merging any that overlap in the original set.\n#\nsub mergeOverlappingIntervals {\n    my($intervals) = @_;\n\n    # result set of intervals\n    my $merged = [];\n\n    # sort all intervals by fmin\n    my @sorted = sort { $a->{'fmin'} <=> $b->{'fmin'} } @$intervals;\n    \n    # current interval\n    my $current = undef;\n\n    foreach my $i (@sorted) {\n        if (!defined($current)) {\n            # case 1: no current interval\n            $current = $i;\n        } else {\n            # case 2: compare current interval to interval $i\n            if ($i->{'fmin'} > $current->{'fmax'}) {   \n                # case 2a: no overlap\n                push(@$merged, $current);\n                $current = $i;\n            } elsif ($i->{'fmax'} > $current->{'fmax'}) {\n                # case 2b: overlap, with $i ending to the right of $current\n                $current->{'fmax'} = $i->{'fmax'};\n            }\n        }\n    }\n    push(@$merged, $current) if (defined($current));\n\n    return $merged;\n}\n\n\n## retrieve deflines from a fasta file\nsub get_deflines {\n    my ($fasta_file) = @_;\n\n    my $deflines = {};\n\n    my $ifh; \n   \n    if (! -e $fasta_file) {\n        if (-e $fasta_file.\".gz\") {\n            $fasta_file .= \".gz\";\n        } elsif (-e $fasta_file.\".gzip\") {\n            $fasta_file .= \".gzip\";\n        }\n    }\n    \n    if ($fasta_file =~ /\\.(gz|gzip)$/) {\n        open ($ifh, \"<:gzip\", $fasta_file)\n          || $logger->logdie(\"can't open input file '$fasta_file': $!\");\n    } else {\n        open ($ifh, $fasta_file)\n          || $logger->logdie(\"Failed opening '$fasta_file' for reading: $!\");\n      }\n\n    while (<$ifh>) {\n        unless (/^>/) {\n            next;\n        }\n        chomp;\n        if (/^>((\\S+).*)$/) {\n            $deflines->{$2} = $1;\n        } \n    }\n    close $ifh;\n    \n    if (scalar(keys(%{$deflines})) < 1) {\n        $logger->warn(\"defline lookup failed for '$fasta_file'\");\n    }\n\n    return $deflines;\n}",
      "options": {},
      "contact": null
    },
    {
      "tool": "evmgff3",
      "converter_script": "evmgff32bsml.pl",
      "name": "evmgff32bsml.pl",
      "synopsis": "USAGE: evmgff32bsml.pl\n           --input|-i\n           --output|-o\n           --project|-p\n           --help|-h",
      "description": "This script parses GFF output from EVM and writes it out \nas BSML suitable for import into CHADO DBs.",
      "options": {
        "input": "Input gff3 format file created by EVM.",
        "output": "Output BSML file name.",
        "project": "Project/database name used to create feature identifiers.",
        "help": "This help documentation"
      },
      "contact": "Brett Whitty bwhitty@tigr.org =cut use strict; use warnings; use Getopt::Long qw(:config no_ignore_case no_auto_abbrev); use Pod::Usage; use Data::Dumper; use BSML::BsmlBuilder; use Ergatis::IdGenerator; my ($input, $help, $man, $output, $project, $id_repository); GetOptions ( 'help|h' => \\$help, 'man|m' => \\$man, 'output|o=s' => \\$output, 'input|i=s' => \\$input, 'project|p=s' => \\$project, 'id_repository=s' => \\$id_repository ) || pod2usage(); &pod2usage({-exitval => 1, -verbose => 2, -output => \\*STDOUT}) if ($man); &pod2usage({-exitval => 1, -verbose => 1, -output => \\*STDOUT}) if ($help); if (!$input){ pod2usage(\"input gff_file was not defined with --input\"); } if (!$output){ pod2usage(\"output BSML filename was not defined with --output\"); } if (!$project) { pod2usage(\"You must specify a project name with --project\"); } if (!$id_repository) { pod2usage(\"You must specify an id repository with --id_repository\"); } $project =~ tr/A-Z/a-z/; my $idcreator = Ergatis::IdGenerator->new('id_repository' => $id_repository); my $global_id_counter=0; my $nodes = {}; my @root_nodes = (); open (IN, $input) || die \"couldn't open input file '$input'\"; while (<IN>) { chomp; if (/^#/) { #process header line } elsif (/^>/ || /^#.*fasta.*/i) { last; } else { my $record = parse_record($_); ## if it has no parents it's a root node if (!$record->{'Parent'}) { push(@root_nodes, $record); } ## store records in a set of arrays indexed by ID if ($record->{'ID'}) { push(@{$nodes->{$record->{'ID'}}->{'records'}},$record); } } } close IN; ## populate children for each record foreach my $id(keys(%{$nodes})) { foreach my $record(@{$nodes->{$id}->{'records'}}) { $record->{'children'} = $nodes->{$id}->{'children'}; delete $nodes->{$id}->{'children'}; } } my $gene_nodes = []; fetch_node_type('gene', \\@root_nodes, $gene_nodes); my $doc = new BSML::BsmlBuilder(); #foreach my $root(@root_nodes) { foreach my $root(@{$gene_nodes}) { if ($root->{'_type'} eq 'gene') { my $features = {}; process_node($root, $features); $features->{'_seqid'} = $root->{'_seqid'}; gene_feature_hash_to_bsml($features); } } # add the analysis element $doc->createAndAddAnalysis( id => 'EVM_analysis', sourcename => $output, ); $doc->write($output); exit(); sub parse_record { my ($line) = @_; my $record = {}; my $attrib_hash = {}; my $record_id = ''; my $parent_id = ''; my @cols = split(\"\\t\"); ## adjust both positions so that we are numbering from zero $cols[3]--; $cols[4]--; ## change the + and - symbols in strand column to 0 and 1, respectively if ($cols[6] eq '+') { $cols[6] = 0; } elsif ($cols[6] eq '-') { $cols[6] = 1; } else { die(\"unknown value ($cols[6]) in strand column. expected + or -.\"); } $record->{'_seqid'} = $cols[0]; $record->{'_source'} = $cols[1]; $record->{'_type'} = $cols[2]; $record->{'_start'} = $cols[3]; $record->{'_end'} = $cols[4]; $record->{'_score'} = $cols[5]; $record->{'_strand'} = $cols[6]; $record->{'_phase'} = $cols[7]; my @attribs = split(\";\", $cols[8]); foreach my $attrib(@attribs) { my ($type, $val) = split(\"=\", $attrib); my @vals = split(\",\", $val); $record->{$type}=\\@vals; } if (!defined($record->{'ID'})) { #print STDERR \"no ID defined for record\\n\"; } else { $record->{'ID'} = $record->{'ID'}->[0]; } if (!defined($record->{'Parent'})) { #print STDERR \"no Parent attribute defined for record\\n\"; } else { foreach my $parent(@{$record->{'Parent'}}) { ## store record's hash reference as a child of Parent if (!defined($nodes->{$parent}->{'children'})) { $nodes->{$parent}->{'children'}->{$record->{'_type'}} = []; } push (@{$nodes->{$parent}->{'children'}->{$record->{'_type'}}},$record); } } return $record; } ## recursively traverse a node and all its children ## and process each record to create a feature hash sub process_node { my ($node, $features) = @_; ## hash of keys to ignore when extracting a record hash from a node hash my $ignore_keys = { 'children' => 1, }; ## build a record hash from values stored in the node hash my $record; foreach my $key(keys %{$node}) { if (!$ignore_keys->{$key}) { $record->{$key} = $node->{$key}; } } ## process the record hash process_record($record, $features); ## process the node's children foreach my $child_type(keys %{$node->{'children'}}) { foreach my $child_record(@{$node->{'children'}->{$child_type}}) { process_node($child_record, $features); } } return; } ## process the records and store them in the features hash sub process_record { my ($record, $features) = @_; my $feat_type_map = { 'gene' => 'gene', 'CDS' => 'CDS', 'exon' => 'exon', 'mRNA' => 'transcript', }; if ($record->{'_type'} eq 'CDS') { ## CDS records can span lines and must be merged into one CDS feature if (!$record->{'ID'}) { die \"CDS feature lacks ID -> bad form!\"; } if ($features->{'CDS'}->{$record->{'ID'}}) { if ($features->{'CDS'}->{$record->{'ID'}}->{'startpos'} > $record->{'_start'}) { $features->{'CDS'}->{$record->{'ID'}}->{'startpos'} = $record->{'_start'}; } if ($features->{'CDS'}->{$record->{'ID'}}->{'endpos'} < $record->{'_end'}) { $features->{'CDS'}->{$record->{'ID'}}->{'endpos'} = $record->{'_end'}; } } else { $features->{$feat_type_map->{'CDS'}}->{$record->{'ID'}} = { 'complement' => $record->{'_strand'}, 'startpos' => $record->{'_start'}, 'endpos' => $record->{'_end'}, }; } } else { ##handle all other feature types my $feat_type; if (!defined($feat_type_map->{$record->{'_type'}})) { print STDERR \"unexpected feature type '$record->{_type}'\\n\"; $feat_type = $record->{'_type'}; } else { $feat_type = $feat_type_map->{$record->{'_type'}}; } my $id; if (!$record->{'ID'}) { $id = getTempId(); } else { $id = $record->{'ID'}; } my $title = undef; if ($record->{'Name'}) { $title = shift(@{$record->{'Name'}}); } $features->{$feat_type}->{$id} = { 'complement' => $record->{'_strand'}, 'startpos' => $record->{'_start'}, 'endpos' => $record->{'_end'}, 'title' => $title, }; } } ## convert a gene feature hash into BSML sub gene_feature_hash_to_bsml { my ($features) = @_; my $seq_id = $features->{'_seqid'}; delete $features->{'_seqid'}; my $id_hash = {}; my %id_counts; foreach my $type(keys(%{$features})) { $id_counts{$type} = scalar(keys(%{$features->{$type}})); } $idcreator->set_pool_size(%id_counts); my $seq; ## create a sequence stub for the seq_id if it doesn't exist yet if (!($doc->returnBsmlSequenceByIDR($seq_id))){ $seq = $doc->createAndAddSequence( $seq_id, $seq_id, undef, 'dna', '' ); #if ($options{'fasta_file'}) { # $doc->createAndAddSeqDataImport($seq, 'fasta', $options{'fasta_file'}, '', \"$features->{_seqid}\"); #} $seq->addBsmlLink('analysis', '#EVM', 'input_of'); } else { $seq = $doc->returnBsmlSequenceByIDR($seq_id); } my @transcript_id = keys(%{$features->{'transcript'}}); if (scalar @transcript_id > 1) { print Dumper $features; die \"multiple transcripts encountered\"; } my $t_id = $idcreator->next_id( 'project' => $project, 'type' => 'transcript' ); $id_hash->{$transcript_id[0]} = $t_id; my $feat_table = $doc->createAndAddFeatureTable($seq); my $feat_group = $doc->createAndAddFeatureGroup($seq, '', $t_id); foreach my $type(keys(%{$features})) { foreach my $feat_id(keys(%{$features->{$type}})) { my $id; if (! defined($id_hash->{$feat_id})) { $id = $idcreator->next_id( 'project' => $project, 'type' => $type ); } else { $id = $id_hash->{$feat_id}; } my $feat = $doc->createAndAddFeature( $feat_table, $id, $feat_id, $type); $feat->addBsmlLink('analysis', '#EVM', 'computed_by'); $feat->addBsmlIntervalLoc( $features->{$type}->{$feat_id}->{'startpos'}, $features->{$type}->{$feat_id}->{'endpos'}, $features->{$type}->{$feat_id}->{'complement'}, ); $feat_group->addBsmlFeatureGroupMember( $id, $type ); } } } ## traverses an array of node references ## and returns all nodes of the specified type sub fetch_node_type { my ($type, $nodes_ref, $found_nodes) = @_; foreach my $node (@{$nodes_ref}) { if ($node->{'_type'} eq $type) { push (@{$found_nodes}, $node); } foreach my $key (keys %{$node->{'children'}}) { fetch_node_type($type, $node->{'children'}->{$key}, $found_nodes); } } return; } sub getTempId { return \"temp_id_\".$global_id_counter++; }"
    },
    {
      "tool": "fasta",
      "converter_script": "fasta2bsml.pl",
      "name": "fasta2bsml.pl - convert fasta files to BSML",
      "synopsis": "USAGE:  fasta2bsml.pl \n        --fasta_input=/path/to/fileORdir | --fasta_list=/path/to/file\n        --format=multi|single\n        --output=/path/to/somefile.fsa   | /path/to/somedir\n      [ --class=assembly\n        --output_list=/path/to/somefile.list\n        --output_subdir_size=20000\n        --output_subdir_prefix='somename'\n        --debug=debug_level \n        --log=log_file \n      ]",
      "description": "This script is used to convert fasta to BSML.  The input is meant to be as flexible \nas possible and is described below.  The output can be either a single file with \nmultiple <Sequence> entries, or separate files for each entry.",
      "options": {
        "class": "Sets the class attribute of each Sequence element created.  Default = assembly.",
        "fasta_input": "Input files or folders.  Can be a comma-separated list of mixed input types.",
        "fasta_list": "Text file that is a list of input files and/or folders.",
        "debug": "Debug level.  Use a large number to turn on verbose debugging.",
        "format": "Format.  'multi' (default) writes all sequences to a multi-entry bsml file, and 'single' writes each sequence in a separate file named like $id.bsml",
        "log": "Log file",
        "output": "Output file (if --format=multi) or directory (if --format=single)",
        "output_list": "Optional.  If passed, will create a list file containing the path to each of the\n    files created.",
        "output_subdir_size": "Optional.  Number of files to create within each output subdirectory.",
        "output_subdir_prefix": "Optional.  Rather than just plain numberical names (N), output subdirectories will\n    be named like \"prefixN\" if you pass a prefix with this.",
        "help": "This help message"
      },
      "contact": "Joshua Orvis jorvis@tigr.org =cut use strict; use Getopt::Long qw(:config no_ignore_case no_auto_abbrev pass_through); use Pod::Usage; use Ergatis::Logger; use BSML::BsmlBuilder; my %options = (); my $results = GetOptions (\\%options, 'fasta_input|i=s', 'fasta_list|s=s', 'class|c=s', 'fasta_dir|d=s', ## deprecated 'fasta_file|f=s', ## deprecated 'output|o=s', 'output_list|u=s', 'output_subdir_size|z=s', 'output_subdir_prefix|x=s', 'format|m=s', 'genus=s', 'species=s', 'log|l=s', 'debug=s', 'help|h') || pod2usage(); my $logfile = $options{'log'} || Ergatis::Logger::get_default_logfilename(); my $logger = new Ergatis::Logger('LOG_FILE'=>$logfile, 'LOG_LEVEL'=>$options{'debug'}); $logger = Ergatis::Logger::get_logger(); # display documentation if( $options{'help'} ){ pod2usage( {-exitval=>0, -verbose => 2, -output => \\*STDERR} ); } &check_parameters(\\%options); ####### ## gather the list of files we're going to processes. the user can pass file or # directory names using --fasta_input, which can be a single file, a list of # filenames, a directory of files, or a list of directories of files (lists are # comma-separated. it can even be a mixed list of file and dir names. fancy! # a file containing a list of file/dir names should be passed with --fasta_list. my @files; my @list_elements = (); ## did the user pass a list? if so, get each file/dir names out of it, check it, and add it if ( $options{fasta_list} ) { for my $list ( split(/,/, $options{fasta_list}) ) { $list =~ s/\\s//g; if (-f $list && -s $list) { open (my $fh, $list) || $logger->logdie(\"Can't open file $list\"); for ( <$fh> ) { chomp; if (-e $_ && -s $_) { push @list_elements, $_; } else { $logger->warn(\"Error reading $_ from list $list\") if ($logger->is_warn); } } } else { $logger->warn(\"Error reading $list\") if ($logger->is_warn); } } } ## loop through each input thing passed for my $thing ( split(/,/, ($options{fasta_input} || '') ), split(/,/, ($options{fasta_file} || '') ), ## backwards compatibility split(/,/, ($options{fasta_dir} || '') ), ## backwards compatibility @list_elements) { $thing =~ s/\\s//g; next unless ($thing); ## is this a directory? if (-d $thing) { opendir(my $dh, $thing) || $logger->warn(\"Unable to access $thing due to $!\"); for my $file (readdir $dh) { &add_file(\"$thing/$file\"); } ## else it's probably a file, make sure it exists and has size and add it, else warn } elsif (! &add_file($thing) ) { $logger->warn(\"Error reading $thing\") if ($logger->is_warn); } } ## die if no files found if ( scalar @files == 0 ) { $logger->logdie(\"No files found\"); } ## create an output list if passed my $olist_fh; if ($options{output_list}) { $logger->debug(\"Creating output list at $options{output_list}\") if ($logger->debug); open($olist_fh, \">$options{output_list}\") || $logger->logdie(\"couldn't create output list $options{output_list} : $!\"); } ## variables for handling output sub directory groupings (if needed) my $sub_dir_num = 0; my $seq_file_count = 0; ####### ## parse out sequences from each file my $doc; ## if we're writing out to a multi-entry file, create the doc now: if ($options{format} eq 'multi') { $doc = new BSML::BsmlBuilder; } for my $file ( @files ) { my %seqs = loadMultiSequence( $file ); for my $seqid ( sort {$a<=>$b} keys %seqs ) { ## capture the first element of the header up to the first whitespace my $id; if ($seqs{$seqid}{h} =~ /^(\\S+)/) { $id = $1; } else { $logger->warn(\"unrecognized header format: $seqs{$seqid}{h}\") if ($logger->is_warn); } ## are we writing each sequence to single files? If so, start a new doc if ($options{format} eq 'single') { $doc = new BSML::BsmlBuilder; } my $genome_id; if ((defined($options{'genus'})) && (defined($options{'species'}))){ my $genome_elem = $doc->createAndAddGenome(); if (!defined($genome_elem)){ $logger->logdie(\"Could not create <Genome> element \". \"object for organism with genus \". \"'$options{'genus'}' species \". \"'$options{'species'}'\"); } if (( exists $genome_elem->{'attr'}->{'id'} ) && ( defined ( $genome_elem->{'attr'}->{'id'} ) ) ){ $genome_id = $genome_elem->{'attr'}->{'id'}; } else { $logger->logdie(\"Genome id was not defined!\"); } my $organism_elem = $doc->createAndAddOrganism('genome' => $genome_elem, 'genus' => $options{'genus'}, 'species' => $options{'species'} ); if (!defined($organism_elem)){ $logger->logdie(\"Could not create <Organism> element \". \"object for genus '$options{'genus'}' \". \"species '$options{'species'}'\"); } } my $seq_element = $doc->createAndAddSequence( $id, $seqs{$seqid}{'h'}, length($seqs{$seqid}{'s'}), undef, $options{'class'} ); $logger->debug(\"adding id $id to the bsml doc\") if ($logger->is_debug); $doc->createAndAddSeqData( $seq_element, $seqs{$seqid}{'s'} ); if (defined($genome_id)){ ## The <Sequence> will be explicitly linked with the <Genome> my $link_elem = $doc->createAndAddLink( $seq_element, 'genome', # rel \"#$genome_id\" # href ); if (!defined($link_elem)){ $logger->logdie(\"Could not create a 'genome' <Link> \". \"element object <Sequence> with id '$id'\"); } } ## record the defline $doc->createAndAddBsmlAttribute( $seq_element, 'defline', $seqs{$seqid}{h} ); ## write this doc if we're in single mode. the only thing we can use is the id, # which needs to be made safe first. if ($options{format} eq 'single') { $id =~ s/[^a-z0-9\\.\\-]/_/gi; write_single_doc( $doc, $id ); #$doc->write( \"$options{output}/$id.bsml\" ); #if ($options{output_list}) { # print $olist_fh \"$options{output}/$id.bsml\\n\"; #} } } } if ($options{format} eq 'multi') { $doc->write( $options{output} ); if ($options{output_list}) { print $olist_fh \"$options{output}\\n\"; } } ## fin exit; sub add_file { ## adds a file to the list of those to process, checking to make sure it # exists and is populated. my $file = shift; ## only do .f?a files (.fna .fsa .faa .fasta) unless we're operating on a list if (! $options{fasta_list}) { return 0 unless ( $file =~ /\\.f.a$/ || $file =~ /\\.fasta$/); } if (-e $file && -s $file) { $logger->debug(\"Adding file $file for processing\") if ($logger->is_debug); push @files, $file; } else { $logger->warn(\"Error reading file $file\") if ($logger->is_warn); return 0; } return 1; } sub check_parameters { my ($options) = @_; ## they have to pass some form of input unless ($options{fasta_input} || $options{fasta_list} || $options{fasta_file} || $options{fasta_dir}) { $logger->logdie(\"You must specify input with --fasta_input --fasta_list --fasta_file or --fasta_dir\"); } ## output is required unless ( $options{output} ) { $logger->logdie(\"You must specify an output directory or file with --output\"); } ## check the format setting or set a default if it wasn't passed if (! $options{format}) { $options{format} = 'multi'; } elsif ( $options{format} ne 'single' && $options{format} ne 'multi' ) { $logger->logdie(\"--format must be either 'single' or 'multi'\"); } ## if format is single, output must be a directory if ($options{format} eq 'single') { unless (-d $options{output}) { $logger->logdie(\"if using --format=single then --output must point to a directory\"); } ## else if format is multi, output must NOT be a directory } elsif ($options{format} eq 'multi') { if (-d $options{output}) { $logger->logdie(\"if using --format=multi then --output must NOT point to a directory\"); } } $options{output_subdir_size} = 0 unless ($options{output_subdir_size}); $options{output_subdir_prefix} = '' unless ($options{output_subdir_prefix}); $options{class} = 'assembly' unless $options{class}; } sub loadMultiSequence { # USAGE: loadMultiSequence($filepath) # RETURNS: hash # # takes a file or path as an argument. that file should be a multiple- # sequence FASTA file. It returns a hash with a structure like: # $db{id}{'h'} = header # {'s'} = sequence without whitespace # # where id is an incrementing integer that represents that sequence's # order in the file. # ######################################################################### my ($file) = @_; my $seqid = 0; my $seq = ''; my $header; my %db; ## load the sequence file open (my $sfh, \"<$file\") || $logger->logdie(\"can't open $file because $!\"); for (<$sfh>) { ## if we find a header line ... if (/^\\>(.*)/) { $header = $1; ## don't do anything if this is the first sequence if ($seqid == 0) { $seqid++; $db{$seqid}{'h'} = $header; next; } ## remove whitespace $seq =~ s/\\s//g; ## record the previous sequence before starting the new one $db{$seqid}{'s'} = $seq; ## increment the id counter $seqid++; ## record the new header $db{$seqid}{'h'} = $header; ## reset the sequence $seq = ''; ## else we've found a sequence line } else { ## skip it if it is just whitespace next if (/^\\s*$/); ## record this portion of the sequence $seq .= $_; } } ## don't forget the last sequence $seq =~ s/\\s//g; $db{$seqid}{'s'} = $seq; ## close the sequence file close $sfh; return %db; } sub write_single_doc { my ($doc, $id) = @_; my $dirpath = ''; ## the path depends on whether we are using output subdirectories if ($options{output_subdir_size}) { $dirpath = \"$options{'output'}/$options{output_subdir_prefix}$sub_dir_num\"; } else { $dirpath = \"$options{'output'}\"; } ## if the directory doesn't exist, create it. mkdir($dirpath) unless (-e $dirpath); $seq_file_count++; $logger->debug(\"writing file $dirpath/$id.bsml\") if ($logger->is_debug); $doc->write( \"$dirpath/$id.bsml\" ); ## if we are writing multiple subdirectories and have hit our size limit, ## increase the counter to the next one if ($options{output_subdir_size} && $options{output_subdir_size} == $seq_file_count) { $sub_dir_num++; $seq_file_count = 0; } if ($options{output_list}) { print $olist_fh \"$dirpath/$id.bsml\\n\"; } }"
    },
    {
      "tool": "fgenesh",
      "converter_script": "fgenesh2bsml.pl",
      "name": "fgenesh2bsml.pl - convert fgenesh output to BSML",
      "synopsis": "USAGE: fgenesh2bsml.pl \n        --input_file=/path/to/fgenesh.raw.file \n        --output=/path/to/output.bsml\n        --project=aa1 \n        --fasta_input=/path/to/somefile.fsa \n        --id_repository=/path/to/repository\n        --sourcename=sourcename\n        --programversion='current'",
      "description": "This script is used to convert the output from a fgenesh search into BSML.",
      "options": {
        "input_file": "Input file file from a fgenesh run.  -i, --input_list, will take in a list\n    of input files, all of which will be stored in a single output bsml.",
        "output": "Output BSML file (will be created, must not exist)",
        "project": "Project ID.  Used in creating feature ids.",
        "fasta_input": "Needed to create a Seq-data-import element referencing this path.",
        "id_repository": "path to --project's id_repository",
        "programversion": "Version string to be used as value for the analysis attribute 'programversion'",
        "sourcename": "Sourcename string to be used as value for the analysis attribute 'sourcename'\n    Due to a silly hack in analysis2bsml.pl, you might need to put /dummy/dir at\n    the end of it.",
        "log": "Log file",
        "debug": "Debug level.  Use a large number to turn on verbose debugging.",
        "help": "This help message"
      },
      "contact": "Jason Inman jinman@tigr.org =cut use strict; use Getopt::Long qw(:config no_ignore_case no_auto_abbrev); use Pod::Usage; use Ergatis::Logger; use Ergatis::IdGenerator; use BSML::GenePredictionBsml; use Chado::Gene; ### Some globals my @inputFiles; my $project; my $output; my $sourcename; my $idMaker; my $bsml; my $data; my $inputFsa; my $debug; my $length; my $programversion; my %options = (); my $results = GetOptions (\\%options, 'input_list|i=s', 'input_file|f=s', 'output|o=s', 'project|p=s', 'id_repository|r=s', 'fasta_input|a=s', 'sourcename|s=s', 'programversion|v=s', 'log|l=s', 'command_id=s', ## passed by workflow 'logconf=s', ## passed by workflow (not used) 'debug=s', 'help|h') || pod2usage(); my $logfile = $options{'log'} || Ergatis::Logger::get_default_logfilename(); my $logger = new Ergatis::Logger('LOG_FILE'=>$logfile, 'LOG_LEVEL'=>$options{'debug'}); $logger = $logger->get_logger(); # display documentation if( $options{'help'} ){ pod2usage( {-exitval=>0, -verbose => 2, -output => \\*STDOUT} ); } ## make sure all passed options are peachy &check_parameters(\\%options); foreach my $file (@inputFiles) { $data = &parseFgeneshData($file); $bsml = &generateBsml($data); } $bsml->writeBsml($output); exit(0); sub parseFgeneshData { my $inFile = shift; ## open the input file for parsing open (my $ifh, \"< $inFile\") || $logger->logdie(\"Can't open input file for reading\"); my $source_seq_name = ''; my $group_name = ''; my $comp_val; my $min_exon_low = ''; my $max_exon_high = ''; my $genes; my %tmp; my @group_members = (); while (<$ifh>) { if ($_ =~ /Seq name: (\\S+)/) { $source_seq_name = $1; last; } } ## skip the rest of the headers while (<$ifh>) { last if ($_ =~ /^ G Str Feature Start End Score ORF Len/); } <$ifh>; ## go through the data now while (<$ifh>) { ## We're done if we encounter this line: last if ($_ =~ /^Predicted protein/); chomp; ## remove a leading space from the early lines. This is sometimes ## inserted to keep formatting 'pretty'. Honestly, who's reading the ## raw files? Come ON! $_ =~ s/^ +//; ## add the group if we come across a blank line if ($_ eq '') { &add_group(\\@group_members, $min_exon_low, $max_exon_high, $comp_val, \\$genes, $source_seq_name); @group_members = (); $min_exon_low = ''; $max_exon_high = ''; next; } ## See description of the columns above. ## Because we don't get start and stop at every line we have to be a little tricky my ($strand, $type, $low, $high); if (/TSS|PolA/) { ($strand, $type, $low) = (split(/\\s+/))[1,2,3]; ## have to handle the $high since it's not inlcuded (results are base-indexed) ## We'll handle conversion to gap-indexing (interbase) in a little bit. $high = $low; } elsif (/CDS/) { ($strand, $type, $low, $high) = (split(/\\s+/))[1,3,4,6]; } ##store complement flag (1 is true, meaining feature lies on reverse strand) $comp_val = ($strand eq '+') ? 0 : 1; ## count in interbase (Note that fgenesh reports all coords as l_end - r_end $low--; ## build our temporary object for this element %tmp = ('type' => $type, 'low' => $low, 'high' => $high, 'comp' => $comp_val ); push @group_members, {%tmp}; # Adjust the min/max coords for the gene and polypeptide unless ($type =~ /TSS|PolA/) { # set up initial low/highs or compare against existing low/highs $min_exon_low = ($min_exon_low eq '') ? $low : (($min_exon_low < $low ) ? $min_exon_low : $low ); $max_exon_high = ($max_exon_high eq '') ? $high : (($max_exon_high > $high) ? $max_exon_high : $high ); } } return $genes; } sub add_group { my ($grp_mems, $min, $max, $comp, $genes, $source_seq_name) = @_; ## Create a new gene object: my $tmpGene = new Chado::Gene ( $idMaker->next_id( 'type' => 'gene', 'project' => $project ), $min, $max, $comp, $source_seq_name ); ## Add the polypeptide/transcript: foreach my $type( qw( transcript polypeptide ) ) { $tmpGene->addFeature( $idMaker->next_id( 'type' => $type, 'project' => $project ), $min, $max, $comp, $type ); } ## Now add the exons and other features foreach my $feat (@$grp_mems) { my $mem_type = $feat->{'type'}; ## All kinds of CDS (CDSf, CDSi, CDSl, CDSo) get handled the same way. if ($mem_type =~ /CDS/) { foreach my $type ( qw( exon CDS ) ) { $tmpGene->addFeature( $idMaker->next_id( 'type' => $type, 'project' => $project), $$feat{'low'}, $$feat{'high'}, $$feat{'comp'}, $type ); } } elsif ($mem_type eq 'TSS') { $tmpGene->addFeature( $idMaker->next_id( 'type' => 'transcription_start_site', 'project' => $project ), $$feat{'low'}, $$feat{'high'}, $$feat{'comp'}, 'transcription_start_site' ); } elsif ($mem_type eq 'PolA') { $tmpGene->addFeature( $idMaker->next_id( 'type' => 'polyA_signal_sequence', 'project' => $project), $$feat{'low'}, $$feat{'high'}, $$feat{'comp'}, 'polyA_signal_sequence' ); } else { ## we need to at least consider each feature type in the gene object. $logger->logdie(\"unrecognized feature type: $mem_type\\n\"); } } ## Form the group now: my $count = $tmpGene->addToGroup($tmpGene->getId, {'all' => 1}); $logger->logdie(\"Nothing added to group\") unless ($count); push @{$$genes}, $tmpGene; } sub generateBsml { my $data = shift; #Create the document my $doc = new BSML::GenePredictionBsml( 'fgenesh', $sourcename, $programversion); foreach my $gene(@{$data}) { $doc->addGene($gene); } my $seqId; open(IN, \"< $inputFsa\") or $logger->logdie(\"Unable to open $inputFsa\"); while(<IN>) { #assume it's a single fasta file if(/^>([^\\s+]+)/) { $seqId = $1; last; } } close(IN); my $addedTo = $doc->setFasta('', $inputFsa); $logger->logdie(\"$seqId was not a sequence associated with the gene\") unless($addedTo); return $doc; } sub check_parameters { my $options = shift; my $error = \"\"; # Check for input file(s) if($options{'input_list'}) { $error .= \"Option input_list ($options{'input_list'}) does not exist\\n\" unless(-e $options{'input_list'}); open(IN, \"< $options{'input_list'}\") || &_die(\"Unable to open $options{'input_list'} ($!)\"); @inputFiles = <IN>; close(IN); } if($options{'input_file'}) { $error .= \"Option input_file ($options{'input_file'}) does not exist\\n\" unless(-e $options{'input_file'}); push(@inputFiles, $options{'input_file'}); } unless($options{'input_list'} || $options{'input_file'}) { $error .= \"Either option input_list or input_file is required\\n\"; } # make sure we got a project unless ($options{'project'}) { $error .= \"Option project is required.\\n\"; } else { $project = $options{'project'}; } # Check for output file unless($options{'output'}) { $error .= \"Option output is required.\\n\"; } else { $output = $options{'output'}; } # Set up the id generator unless($options{'id_repository'}) { $error .= \"Option id_repository is required. Please see Ergatis::IdGenerator \". \"for details.\\n\"; } else { $idMaker = new Ergatis::IdGenerator( 'id_repository' => $options{'id_repository'} ); $idMaker->set_pool_size( 'exon' => 20, 'transcript' => 20, 'gene' => 20, 'polypeptide' => 20, 'CDS' => 20, 'promoter' => 20, 'polyA_signal_sequence' => 20, ); } # Check for input fasta sequence: unless($options{'fasta_input'}) { $error .= \"Option fasta_input is required\\n\"; } else { $error .= \"$options{'fasta_input'} (fasta_input) does not exist\\n\" unless(-e $options{'fasta_input'}); $inputFsa = $options{'fasta_input'}; #Find the length of the sequence open(IN, \"<$options{'fasta_input'}\") or $logger->logdie(\"Can't open $options->{'fasta_input'}\"); my $seq = \"\"; my $curId; while(<IN>) { chomp; if(/^>(\\S+)/) { if(defined($curId)) { $length->{$curId} = length($seq); $seq = \"\"; } $curId = $1; } else { $seq.= $_; } } $length->{$curId} = length($seq); close(IN); } ## get sourcedir for the analysis section: if ($options{'sourcename'}) { $sourcename = $options{'sourcename'}; } else { $error .= \"--sourcename is a required option.\\n\"; } ## get programversion for the analysis section if ($options{'programversion'}) { $programversion = $options{'programversion'}; } else { $programversion = 'current'; } if($options{'debug'}) { $debug = $options{'debug'}; } unless($error eq \"\") { $logger->logdie($error); } }"
    },
    {
      "tool": "findhomopolymers",
      "converter_script": "findhomopolymers2bsml.pl",
      "name": "findhomopolymers2bsml.pl - convert findhomopolymers output to BSML",
      "synopsis": "USAGE: findhomopolymers2bsml.pl \n        --input=/path/to/somefile.out \n        --output=/path/to/output.bsml\n      [ --project=aa1 ]",
      "description": "This script is used to convert the output from an findhomopolymers run into BSML.",
      "options": {
        "input": "Input .out file from a Findhomopolymers search.",
        "debug": "Debug level.  Use a large number to turn on verbose debugging.",
        "log": "Log file",
        "output": "Output BSML file (will be created, or overwritten)",
        "project": "Project ID.  Used in creating feature ids.  Defaults to whatever the prefix of the\n    input file is (i.e. spntigr4.assembly.1.1 would be spntigr4).",
        "id_repository": "Required for creating feature identifiers.  Each project should have\n    its own id_repository directory - use the full path to it here.",
        "help": "This help message"
      },
      "contact": "David Riley driley@som.umaryland.edu =cut use strict; use Getopt::Long qw(:config no_ignore_case no_auto_abbrev); use Pod::Usage; use Ergatis::IdGenerator; use File::Basename; use Ergatis::Logger; use BSML::BsmlRepository; use BSML::BsmlBuilder; use BSML::BsmlParserTwig; my %options = (); my $results = GetOptions (\\%options, 'input|i=s', 'output|o=s', 'project|p=s', 'log|l=s', 'id_repository|r=s', 'command_id=s', ## passed by workflow 'logconf=s', ## passed by workflow (not used) 'debug=s', 'help|h') || pod2usage(); my $logfile = $options{'log'} || Ergatis::Logger::get_default_logfilename(); my $logger = new Ergatis::Logger('LOG_FILE'=>$logfile, 'LOG_LEVEL'=>$options{'debug'}); $logger = $logger->get_logger(); # display documentation if( $options{'help'} ){ pod2usage( {-exitval=>0, -verbose => 2, -output => \\*STDOUT} ); } ## make sure all passed options are peachy &check_parameters(\\%options); ## we want a new doc my $doc = new BSML::BsmlBuilder(); ## we're going to generate ids my $idcreator = new Ergatis::IdGenerator( id_repository => $options{id_repository} ); my $seq_id; my $project; ## open the input file for parsing open (my $ifh, $options{'input'}) || $logger->logdie(\"can't open input file for reading\"); my %data; my $seq; my $ft; while (<$ifh>) { if($_ =~ /^\\>(\\S+)\\s/) { $seq_id = $1; ($seq,$ft) = &add_sequence($seq_id); } else { my ($start, $stop,$bases) = split(/\\s+/, $_); if(defined($start) && defined($stop)) { ## add the island my $id = $idcreator->next_id( project => $project, type => 'repeat_region' ); my $island = $doc->createAndAddFeature($ft, $id, '', 'repeat_region'); $island->addBsmlLink('analysis', '#find_homopolymers_analysis', 'computed_by'); ## add the location of the repeat $island->addBsmlIntervalLoc( $start, $stop, 0); } } } ## add the analysis element $doc->createAndAddAnalysis( id => 'find_homopolymers_analysis', sourcename => dirname($options{'output'}), program => 'find_homopolymers', algorithm => 'find_homopolymers', programversion => 'current' ); ## now write the doc $doc->write($options{'output'}); exit; sub add_sequence { my $seq_id = shift; my $seq = $doc->createAndAddSequence($seq_id, undef, '', 'dna', 'assembly'); $seq->addBsmlLink('analysis', '#find_homopolymers_analysis', 'input_of'); my $ft = $doc->createAndAddFeatureTable($seq); $seq_id =~ /([^\\.]+)\\./; my $prefix = $1; $project = $prefix ? $prefix : $options{project}; return ($seq,$ft); } sub check_parameters { ## make sure input file exists if (! -e $options{'input'}) { $logger->logdie(\"input file $options{'input'} does not exist\") } return 1; }"
    },
    {
      "tool": "fuzznuc",
      "converter_script": "fuzznuc2bsml.pl",
      "name": "fuzznuc2bsml.pl - convert fuzznuc raw output to BSML",
      "synopsis": "USAGE: fuzznuc2bsml.pl \n        --input=/path/to/somefile.hmmpfam.raw \n        --output=/path/to/somefile.hmmpfam.bsml\n        --fasta_input=/path/to/hmmpfam/input.fsa\n        --gzip_output=1\n        --log=/path/to/some.log\n        --debug=4 \n        --help\n      ]",
      "description": "This script is used to convert the raw alignment output from an hmmpfam search into BSML.",
      "options": {
        "input": "Input raw alignment file from an hmmpfam search.",
        "output": "Output BSML file",
        "fasta_input": "Optional.  If included, will make a seq data import element and include the \n    defline with the sequences.",
        "gzip_output": "Optional.  If given a non-zero value, will compress the output and give the output\n    file a .gz extension.  If the file already contains one, it won't add another.",
        "debug": "Debug level.  Use a large number to turn on verbose debugging.",
        "log": "Log file",
        "help": "This help message"
      },
      "contact": "Joshua Orvis jorvis@tigr.org =cut use strict; use Getopt::Long qw(:config no_ignore_case no_auto_abbrev); use Pod::Usage; use Ergatis::Logger; use BSML::BsmlRepository; use BSML::BsmlBuilder; use BSML::BsmlParserTwig; my $fasta_input; my %options = (); my $results = GetOptions (\\%options, 'input|i=s', 'output|o=s', 'fasta_input|f=s', 'gzip_output|g=s', 'log|l=s', 'debug=s', 'help|h') || pod2usage(); my $logfile = $options{'log'} || Ergatis::Logger::get_default_logfilename(); my $logger = new Ergatis::Logger('LOG_FILE'=>$logfile, 'LOG_LEVEL'=>$options{'debug'}); $logger = $logger->get_logger(); # display documentation if( $options{'help'} ){ pod2usage( {-exitval=>0, -verbose => 2, -output => \\*STDOUT} ); } ## make sure all passed options are peachy &check_parameters(\\%options); ## we want a new doc my $doc = new BSML::BsmlBuilder(); ## open the input file for parsing open (my $ifh, $options{'input'}) || $logger->logdie(\"can't open input file for reading\"); ## go through the top of the file and get a few things. my ($pattern, $pattern_name,$seq_file,$pat_seq); while (<$ifh>) { if (/-pattern\\s+(\\S+)/) { $pat_seq = $1; } elsif (/pname\\s+(\\S+)/) { $pattern_name = $1; }elsif (/-sequence\\s+(\\S+)/) { $seq_file = $1; } elsif(/Report_file/) { last; } } my $pattern = $doc->createAndAddSequence($pattern_name, $pattern_name, undef, 'na', 'DNA'); $doc->createAndAddSeqData($pattern_name,$pat_seq); ## fetch deflines #my $deflines = get_deflines($sequence_file); ## check that these were successfully parsed unless ($pattern_name) { $logger->logdie(\"HMM file definition not found in input file.\") } unless ($seq_file) { $logger->logdie(\"Sequence file definition not found in input file.\") } #my $hmm_name = $hmm_file; #$hmm_name =~ s/.*\\///; #$nmm_name =~ s/\\..*//; my($seq_name,$start,$end,$score,$strand,$pattern, $seq, %alignments); while (<$ifh>) { #Feature: 1 #Name: ntnm01.assembly.81.0 #Start: 9340 #End: 9359 #Length: 20 #Score: 20 #Strand: + #Pattern_name: dRS3_repeat #Mismatch: . if(/Name:\\s(\\S+)/) { $seq_name=$1; } elsif(/Start:\\s(\\S+)/) { $start=$1; } elsif(/End:\\s(\\S+)/) { $end = $1; } elsif(/Strand:\\s(\\S+)/) { $strand=$1; } elsif(/Score:\\s(\\S+)/) { $score=$1; } elsif(/Pattern_name:\\s(\\S+)/) { # $pattern=$1; ## add this model sequence if we haven't already if( !( $doc->returnBsmlSequenceByIDR($seq_name)) ){ $seq = $doc->createAndAddSequence($seq_name, $seq_name, undef, 'na', 'DNA'); } if(!$alignments{$pattern_name}) { $alignments{$pattern_name} = $doc->createAndAddSequencePairAlignment( refseq => $seq_name, #refstart => 0, #refend => $cols[2] - 1, #reflength => $cols[2], compseq => $pattern_name, class => 'match' ); } ## add a link element inside this seq-pair-alignment $alignments{$pattern_name}->addBsmlLink('analysis', \"\\#$options{search_method}_analysis\", 'computed_by'); ## add the total_score and total_eval for this pair # $doc->createAndAddBsmlAttribute($alignments{$pattern_name}, 'total_score', $score); my $linectr=0; my $run = $doc->createAndAddSequencePairRun( alignment_pair => $alignments{$pattern_name}, runscore => $score, runlength => abs($start - $end) + 1, comprunlength => abs($start - $end) + 1, refpos => min($start, $end) - 1, refcomplement => 0, comppos => 0, compcomplement => 0, ); ## add other attributes of the run $doc->createAndAddBsmlAttribute( $run, 'class', 'match_part'); } } ## add the analysis element $doc->createAndAddAnalysis( id => \"$options{search_method}_analysis\", sourcename => $options{'output'}, program => 'fuzznuc', algorithm => 'fuzznuc', version => 'na', ); ## now write the doc $doc->write($options{'output'}, '', $options{gzip_output}); exit; sub check_parameters { ## make sure input file exists if (! -e $options{'input'}) { $logger->logdie(\"input file $options{'input'} does not exist\") } ## make user an output file was passed if (! $options{'output'}) { $logger->logdie(\"output option required!\") } ## handle defaults $options{'search_method'} = 'fuzznuc' unless ( $options{'search_method'} ); if($options{'fasta_input'}) { $fasta_input = $options{'fasta_input'}; } return 1; } sub min { my ($num1, $num2) = @_; if ($num1 < $num2) { return $num1; } else { return $num2; } } ## retrieve deflines from a fasta file sub get_deflines { my ($fasta_file) = @_; my $deflines = {}; my $ifh; if (! -e $fasta_file) { if (-e $fasta_file.\".gz\") { $fasta_file .= \".gz\"; } elsif (-e $fasta_file.\".gzip\") { $fasta_file .= \".gzip\"; } } if ($fasta_file =~ /\\.(gz|gzip)$/) { open ($ifh, \"<:gzip\", $fasta_file) || $logger->logdie(\"can't open input file '$fasta_file': $!\"); } else { open ($ifh, $fasta_file) || $logger->logdie(\"Failed opening '$fasta_file' for reading: $!\"); } while (<$ifh>) { unless (/^>/) { next; } chomp; if (/^>((\\S+).*)$/) { $deflines->{$2} = $1; } } close $ifh; if (scalar(keys(%{$deflines})) < 1) { $logger->logwarn(\"defline lookup failed for '$fasta_file'\"); } return $deflines; }"
    },
    {
      "tool": "gap2",
      "converter_script": "gap22bsml.pl",
      "name": "gap22bsml.pl - convert gap2 btab output to BSML",
      "synopsis": "USAGE: gap22bsml.pl \n    --input=/path/to/somefile.gap2.btab \n    --output=/path/to/somefile.gap2.bsml",
      "description": "This script is used to convert the btab output from a gap2 search into BSML.",
      "options": {
        "input": "Input btab file from a gap2 search.",
        "query_file_path": "Full path to FASTA file containing query sequence.",
        "query_id": "ID of query sequence",
        "debug": "Debug level.  Use a large number to turn on verbose debugging.",
        "log": "Log file",
        "output": "Output BSML file",
        "help": "This help message"
      },
      "contact": "Joshua Orvis jorvis@tigr.org =cut use strict; use Getopt::Long qw(:config no_ignore_case no_auto_abbrev); use Pod::Usage; BEGIN { use Ergatis::Logger; use BSML::BsmlRepository; use BSML::BsmlBuilder; use BSML::BsmlParserTwig; } my %options = (); my $results = GetOptions (\\%options, 'input|i=s', 'output|o=s', 'query_file_path|q=s', 'query_id=s', 'gzip_output|g=s', 'log|l=s', 'debug=s', 'help|h') || pod2usage(); my $logfile = $options{'log'} || Ergatis::Logger::get_default_logfilename(); my $logger = new Ergatis::Logger('LOG_FILE'=>$logfile, 'LOG_LEVEL'=>$options{'debug'}); $logger = $logger->get_logger(); # display documentation if( $options{'help'} ){ pod2usage( {-exitval=>0, -verbose => 2, -output => \\*STDOUT} ); } my $input = $options{'input'}; my $defline; ## make sure all passed options are peachy &check_parameters(\\%options); ## we want a new doc my $doc = new BSML::BsmlBuilder(); ## open file for reading my $ifh; if($input =~ /\\.gz$/) { open ($ifh, \"<:gzip\", $input) || $logger->logdie(\"can't open input file for reading ($!)\"); } else { open ($ifh, $input) || $logger->logdie(\"can't open input file for reading ($!)\"); } ## each chain segment = one Seq-pair-run my %seqs_found; ## this hash will hold the chainIDs as their key and a reference to its Seq-pair-alignment my %chains; while (<$ifh>) { ## ignore whitespace lines next if ( /^\\s*$/ ); chomp; ## there should be 19 elements in cols, unless we have an unrecognized format. my @cols = split(\"\\t\"); unless (scalar @cols == 19) { $logger->error(\"the following gap2 btab line was not recognized and could not be parsed (should have 19 columns, actually has \" . scalar(@cols) . \"):\\n$_\\n\") if ($logger->is_error); next; } my ($qry_id, $sbj_id) = ($cols[0], $cols[5]); ## the qry ID only counts up to the first whitespace if ($qry_id =~ /(.+?)\\s+/) { $qry_id = $1; } ## has this query sequence been added to the doc yet? if (! exists $seqs_found{$qry_id}) { my $seq = $doc->createAndAddSequence($qry_id, $cols[0], undef, 'na', 'nucleic_acid'); $doc->createAndAddBsmlAttribute($seq, 'defline', $defline) if($defline); $doc->createAndAddSeqDataImport($seq, 'fasta', $options{'query_file_path'}, '', $cols[0]); $seq->addBsmlLink('analysis', '#aat_na_analysis', 'input_of'); $seqs_found{$qry_id} = 1; } ## has this subject sequence been added to the doc yet? if (! exists $seqs_found{$sbj_id}) { my $seq = $doc->createAndAddSequence($sbj_id, $cols[5], undef, 'na', 'nucleic_acid'); my $subDefline = &getSubDefline($cols[4]); $doc->createAndAddSeqDataImport($seq, 'fasta', $cols[4], '', $cols[5]); $doc->createAndAddCrossReferencesByParse( sequence => $seq, string => $cols[5]); $seqs_found{$sbj_id} = 1; } my ($chainID, $segmentID) = ($cols[13], $cols[14]); ## if this combination doesn't exist yet, create its Seq-pair-alignment if (! exists $chains{$chainID}) { ## skipped attributes here are complength, compstart, compend and method $chains{$chainID} = $doc->createAndAddSequencePairAlignment( refseq => $qry_id, refxref => \":$qry_id\", refstart => 0, refend => $cols[2] - 1, reflength => $cols[2], compseq => $sbj_id, compxref => \"$cols[4]:$sbj_id\", class => 'match', ); $chains{$chainID}->addBsmlLink('analysis', '#aat_na_analysis', 'computed_by'); ## add the total_score (will be the same for each matching segment) $doc->createAndAddBsmlAttribute($chains{$chainID}, 'total_score', $cols[18]); } ## now add the Seq-pair-run ## skipped attributes are runprob my $run = $doc->createAndAddSequencePairRun( alignment_pair => $chains{$chainID}, runscore => $cols[12], runlength => abs($cols[7] - $cols[6]) + 1, comprunlength => abs($cols[9] - $cols[8]) + 1, refpos => min($cols[6], $cols[7]) - 1, refcomplement => $cols[17] eq 'Minus' ? 1 : 0, comppos => min($cols[8], $cols[9]) - 1, compcomplement => 0, ); $doc->createAndAddBsmlAttribute($run, 'class', 'match_part'); $doc->createAndAddBsmlAttribute($run, 'percent_identity', $cols[10]); $doc->createAndAddBsmlAttribute($run, 'percent_similarity', $cols[11]); $doc->createAndAddBsmlAttribute($run, 'chain_number', $chainID); $doc->createAndAddBsmlAttribute($run, 'segment_number', $segmentID); } ## if there were no results this will create a sequence stub my $align = &createAndAddNullResult( doc => $doc, query_name => $options{'query_id'}, query_length => '', class => 'assembly', ); ## add the analysis element $doc->createAndAddAnalysis( id => 'aat_na_analysis', sourcename => $options{'output'}, ); ## now write the doc $doc->write($options{'output'}, '', $options{'gzip_output'}); exit; sub check_parameters { ## make sure input file exists if (! -e $options{'input'}) { if(-e $options{'input'}.\".gz\") { $input = $options{'input'}.\".gz\"; } else { $logger->logdie(\"input file $options{'input'} does not exist\"); } } ## make user an output file was passed if (! $options{'output'}) { $logger->logdie(\"output option required!\") } ## record the defline if ( $options{'query_file_path'} ) { open(IN, \"$options{query_file_path}\") or $logger->logdie(\"Couldn't open $options{query_file_path} ($!)\"); ## assume there's only one sequence in the file. while(<IN>) { chomp; if(/^>(.*)/) { $defline = $1; last; } } close(IN); } return 1; } sub min { my ($num1, $num2) = @_; if ($num1 < $num2) { return $num1; } else { return $num2; } } ##Adds BSML tags for the case where ##the query sequence returned no hits sub createAndAddNullResult { my %args = @_; my $doc = $args{'doc'}; if( !( $doc->returnBsmlSequenceByIDR( \"$args{'query_name'}\")) ){ my $seq = $doc->createAndAddSequence( \"$args{'query_name'}\", \"$args{'query_name'}\", $args{'query_length'}, 'na', $args{'class'} ); $doc->createAndAddBsmlAttribute( $seq, 'defline', \"$defline\"); $doc->createAndAddSeqDataImport($seq, 'fasta', $options{'query_file_path'}, '', $args{'query_name'}); $seq->addBsmlLink('analysis', '#aat_na_analysis', 'input_of'); } } sub getSubDefline { my $filename = shift; my $retval; open(IN, \"< $filename\") or $logger->logdie(\"Unable to open $filename ($!)\"); while(<IN>) { if(/^>/) { $retval = $_; last; } } return $retval; }"
    },
    {
      "tool": "genbank",
      "converter_script": "genbank2bsml.pl",
      "name": null,
      "synopsis": null,
      "description": null,
      "options": {},
      "contact": null
    },
    {
      "tool": "geneidgff3",
      "converter_script": "geneidgff32bsml.pl",
      "name": "geneidgff32bsml.pl",
      "synopsis": "USAGE: geneidgff32bsml.pl\n           --input|-i\n           --output|-o\n           --project|-p\n           --id_repository|r\n           --help|-h",
      "description": "This script parses GFF3 output from geneid and writes it out \nas BSML suitable for import into CHADO/legacy DBs.  Note that\nthis was pretty much evmgff32bsml.pl but edited to not merge\nCDS records, allowing accurate representation of the exon structure\nwhen loaded with bsml2legacydb.pl",
      "options": {
        "input": "Input gff3 format file created by geneid.",
        "output": "Output BSML file name.",
        "project": "Project/database name used to create feature identifiers.",
        "id_repository": "Path to the id repository for the named project.",
        "help": "This help documentation"
      },
      "contact": "Brett Whitty (original author of evmgff32bsml.pl) bwhitty@tigr.org Jason Inman (copier/editor of geneid version) jinman@tigr.org =cut use strict; use warnings; use Getopt::Long qw(:config no_ignore_case no_auto_abbrev); use Pod::Usage; use Data::Dumper; use BSML::BsmlBuilder; use Ergatis::IdGenerator; my ($input, $help, $man, $output, $project, $id_repository); GetOptions ( 'help|h' => \\$help, 'man|m' => \\$man, 'output|o=s' => \\$output, 'input|i=s' => \\$input, 'project|p=s' => \\$project, 'id_repository|r=s' => \\$id_repository ) || pod2usage(); &pod2usage({-exitval => 1, -verbose => 2, -output => \\*STDOUT}) if ($man); &pod2usage({-exitval => 1, -verbose => 1, -output => \\*STDOUT}) if ($help); if (!$input){ pod2usage(\"input gff_file was not defined with --input\"); } if (!$output){ pod2usage(\"output BSML filename was not defined with --output\"); } if (!$project) { pod2usage(\"You must specify a project name with --project\"); } if (!$id_repository) { pod2usage(\"You must specify an id repository with --id_repository\"); } $project =~ tr/A-Z/a-z/; my $idcreator = Ergatis::IdGenerator->new('id_repository' => $id_repository); my $global_id_counter=0; my $nodes = {}; my @root_nodes = (); open (IN, $input) || die \"couldn't open input file '$input'\"; while (<IN>) { chomp; next if (/^#/); my $record = parse_record($_); ## if it has no parents it's a root node if (!$record->{'Parent'}) { push(@root_nodes, $record); } ## store records in a set of arrays indexed by ID if ($record->{'ID'}) { push(@{$nodes->{$record->{'ID'}}->{'records'}},$record); } } close IN; ## populate children for each record foreach my $id(keys(%{$nodes})) { foreach my $record(@{$nodes->{$id}->{'records'}}) { $record->{'children'} = $nodes->{$id}->{'children'}; delete $nodes->{$id}->{'children'}; } } my $gene_nodes = []; fetch_node_type('gene', \\@root_nodes, $gene_nodes); my $doc = new BSML::BsmlBuilder(); #foreach my $root(@root_nodes) { foreach my $root(@{$gene_nodes}) { if ($root->{'_type'} eq 'gene') { my $features = {}; process_node($root, $features); $features->{'_seqid'} = $root->{'_seqid'}; gene_feature_hash_to_bsml($features); } } # add the analysis element $doc->createAndAddAnalysis( id => 'geneid_analysis', sourcename => $output, ); $doc->write($output); exit(); sub parse_record { my ($line) = @_; my $record = {}; my $attrib_hash = {}; my $record_id = ''; my $parent_id = ''; my @cols = split(\"\\t\"); ## adjust start position so that we are in interbase $cols[3]--; ## change the + and - symbols in strand column to 0 and 1, respectively if ($cols[6] eq '+') { $cols[6] = 0; } elsif ($cols[6] eq '-') { $cols[6] = 1; } else { die(\"unknown value ($cols[6]) in strand column. expected + or -.\"); } $record->{'_seqid'} = $cols[0]; $record->{'_source'} = $cols[1]; $record->{'_type'} = $cols[2]; $record->{'_start'} = $cols[3]; $record->{'_end'} = $cols[4]; $record->{'_score'} = $cols[5]; $record->{'_strand'} = $cols[6]; $record->{'_phase'} = $cols[7]; my @attribs = split(\";\", $cols[8]); foreach my $attrib(@attribs) { my ($type, $val) = split(\"=\", $attrib); my @vals = split(\",\", $val); $record->{$type}=\\@vals; } if (!defined($record->{'ID'})) { #print STDERR \"no ID defined for record\\n\"; } else { $record->{'ID'} = $record->{'ID'}->[0]; } if (!defined($record->{'Parent'})) { #print STDERR \"no Parent attribute defined for record\\n\"; } else { foreach my $parent(@{$record->{'Parent'}}) { ## store record's hash reference as a child of Parent if (!defined($nodes->{$parent}->{'children'})) { $nodes->{$parent}->{'children'}->{$record->{'_type'}} = []; } push (@{$nodes->{$parent}->{'children'}->{$record->{'_type'}}},$record); } } return $record; } ## recursively traverse a node and all its children ## and process each record to create a feature hash sub process_node { my ($node, $features) = @_; ## hash of keys to ignore when extracting a record hash from a node hash my $ignore_keys = { 'children' => 1, }; ## build a record hash from values stored in the node hash my $record; foreach my $key(keys %{$node}) { if (!$ignore_keys->{$key}) { $record->{$key} = $node->{$key}; } } ## process the record (unless, of course, it is a cds record process_record($record, $features) unless ($record->{'_type'} eq 'CDS'); ## process the node's children foreach my $child_type(keys %{$node->{'children'}}) { foreach my $child_record(@{$node->{'children'}->{$child_type}}) { process_node($child_record, $features); } } return; } ## process the records and store them in the features hash sub process_record { my ($record, $features) = @_; my $feat_type_map = { 'gene' => 'gene', 'CDS' => 'CDS', 'exon' => 'exon', 'mRNA' => 'transcript', }; if ($record->{'_type'} eq 'exon') { ## Spoof CDS records based on each exon my $feat_type = 'CDS'; (my $id = $record->{'ID'}) =~ s/exon/cds/; $features->{$feat_type}->{$id} = { 'complement' => $record->{'_strand'}, 'startpos' => $record->{'_start'}, 'endpos' => $record->{'_end'}, }; } ##handle all other feature types including the exon itself my $feat_type; if (!defined($feat_type_map->{$record->{'_type'}})) { print STDERR \"unexpected feature type '$record->{_type}'\\n\"; $feat_type = $record->{'_type'}; } else { $feat_type = $feat_type_map->{$record->{'_type'}}; } my $id; if (!$record->{'ID'}) { $id = getTempId(); } else { $id = $record->{'ID'}; } my $title = undef; if ($record->{'Name'}) { $title = shift(@{$record->{'Name'}}); } $features->{$feat_type}->{$id} = { 'complement' => $record->{'_strand'}, 'startpos' => $record->{'_start'}, 'endpos' => $record->{'_end'}, 'title' => $title, }; } ## convert a gene feature hash into BSML sub gene_feature_hash_to_bsml { my ($features) = @_; my $seq_id = $features->{'_seqid'}; delete $features->{'_seqid'}; my $id_hash = {}; my %id_counts; foreach my $type(keys(%{$features})) { $id_counts{$type} = scalar(keys(%{$features->{$type}})); } $idcreator->set_pool_size(%id_counts); my $seq; ## create a sequence stub for the seq_id if it doesn't exist yet if (!($doc->returnBsmlSequenceByIDR($seq_id))){ $seq = $doc->createAndAddSequence( $seq_id, $seq_id, undef, 'dna', '' ); $seq->addBsmlLink('analysis', '#geneid', 'input_of'); } else { $seq = $doc->returnBsmlSequenceByIDR($seq_id); } my @transcript_id = keys(%{$features->{'transcript'}}); if (scalar @transcript_id > 1) { print Dumper $features; die \"multiple transcripts encountered\"; } my $t_id = $idcreator->next_id( 'project' => $project, 'type' => 'transcript' ); $id_hash->{$transcript_id[0]} = $t_id; my $feat_table = $doc->createAndAddFeatureTable($seq); my $feat_group = $doc->createAndAddFeatureGroup($seq, '', $t_id); foreach my $type(keys(%{$features})) { foreach my $feat_id(keys(%{$features->{$type}})) { my $id; if (! defined($id_hash->{$feat_id})) { $id = $idcreator->next_id( 'project' => $project, 'type' => $type ); } else { $id = $id_hash->{$feat_id}; } my $feat = $doc->createAndAddFeature( $feat_table, $id, $feat_id, $type); $feat->addBsmlLink('analysis', '#geneid', 'computed_by'); $feat->addBsmlIntervalLoc( $features->{$type}->{$feat_id}->{'startpos'}, $features->{$type}->{$feat_id}->{'endpos'}, $features->{$type}->{$feat_id}->{'complement'}, ); $feat_group->addBsmlFeatureGroupMember( $id, $type ); } } } ## traverses an array of node references ## and returns all nodes of the specified type sub fetch_node_type { my ($type, $nodes_ref, $found_nodes) = @_; foreach my $node (@{$nodes_ref}) { if ($node->{'_type'} eq $type) { push (@{$found_nodes}, $node); } foreach my $key (keys %{$node->{'children'}}) { fetch_node_type($type, $node->{'children'}->{$key}, $found_nodes); } } return; } sub getTempId { return \"temp_id_\".$global_id_counter++; }"
    },
    {
      "tool": "genemark",
      "converter_script": "genemark2bsml.pl",
      "name": null,
      "synopsis": null,
      "description": null,
      "options": {},
      "contact": null
    },
    {
      "tool": "genemarkes",
      "converter_script": "genemarkes2bsml.pl",
      "name": null,
      "synopsis": null,
      "description": null,
      "options": {},
      "contact": null
    },
    {
      "tool": "genewise",
      "converter_script": "genewise2bsml.pl",
      "name": "genewise2bsml.pl",
      "synopsis": "USAGE: genewise2bsml.pl\n             --input_file|-i\n             --input_seq|-s\n             --output|-o\n             --project|-p\n             --id_repository|r\n             --help|-h\n             --log|-l",
      "description": "This script parses GFF output from genewise and writes it out \nas BSML suitable for import into CHADO/legacy DBs.  Specifically,\nthis 2bsml script is meant to accompany the genewise executable in\nthe genewise_best_loc pipeline.  It expects the input fasta to contain\nthe coordinates mapping it back to the larger genome molecule, as such is the\nway genewise_best_loc works.  It splits the genomic data into regions around previously\ndescribed aat search hits, then uses those proteins and the respective regions\nthey hit on as the input for genewise.  Because of this, we must stitch\nthe hits back into the overall assemblies by adjusting the coords\nto compensate for the truncation of the sequence by the script\n'prepare_for_genwise_best_loc.pl'.",
      "options": {
        "input_file": "Input is a genewise raw file.",
        "input_seq": "File used as input to genewise and containing the genomic fasta sequence.",
        "output": "Output BSML file name.",
        "project": "Project/database name used to create feature identifiers.",
        "id_repository": "Path to the id repository for the named project.",
        "help": "This help documentation",
        "log": "Path to intended log file."
      },
      "contact": "Jason Inman jinman@jcvi.org =cut use strict; use warnings; use Getopt::Long qw(:config no_ignore_case no_auto_abbrev); use Pod::Usage; use Data::Dumper; use Chado::Gene; use BSML::GenePredictionBsml; use BSML::BsmlBuilder; use Ergatis::Logger; use Ergatis::IdGenerator; my $input; my $project; my $output; my $idMaker; my $bsml; my $data; my $input_seq; my $seq_id; my %options = (); my $results = GetOptions ( \\%options, 'input_file|i=s', 'output|o=s', 'project|p=s', 'id_repository|r=s', 'input_seq|s=s', 'log|l=s', 'debug=s', 'help|h', ) || pod2usage(); &pod2usage({-exitval => 1, -verbose => 2, -output => \\*STDOUT}) if ($options{'help'}); my $logfile = $options{'log'} || Ergatis::Logger::get_default_logfilename(); my $logger = new Ergatis::Logger('LOG_FILE'=>$logfile, 'LOG_LEVEL'=>$options{'debug'}); $logger = $logger->get_logger(); &check_params(\\%options); $data = &parseGenewiseData($input); $bsml = &generateBsml($data); $bsml->writeBsml($output); exit(0); #### Subroutines ### sub parseGenewiseData { my $file = shift; ## Get orientation: my ($strand, $lend, $chunk_len) = &get_info_from_src; open(IN, \"<$file\") or $logger->logdie(\"Unable to open raw genewise output: $file: $!\"); my $genes; my $section = 0; my $match_id = ''; my $tmp; while (<IN>) { # Skip ahead until we reach the section with the evidence lines if (/^\\/\\//) { $section++; next; } next if ($section < 2); # Now, the fun begins. chomp; my @fields = split(/\\t/,$_); # Get the id and score my $type_id = $fields[2]; my $score = $fields[5]; # Get coords settled. Start by getting the start and end. my $start = $strand ? $fields[4] : $fields[3]; my $end = $strand ? $fields[3] : $fields[4]; # If we're reversed, switch the distance between the front and back # of the source sequence to make adjusting for the offset possible. if ($strand) { $start = $chunk_len - $start + 1; $end = $chunk_len - $end + 1; } ## Next, compensate for the offset from the beginning of the # actual assembly sequence $start = $lend + $start - 1; $end = $lend + $end - 1; # Finally, convert to base 0. $start--; # If this is a new 'match', we'll start a new 'gene'. if ($match_id ne $fields[8]) { # If this isn't our first time through here, add what is in $tmp to # the array in $genes if ($match_id) { my $count = $tmp->addToGroup($tmp->getId, { 'all' => 1 }); $logger->logdie(\"Nothing was added to group\") unless($count); push(@{$genes}, $tmp); undef $tmp; } $match_id = $fields[8]; $logger->logdie(\"Unexpected start of new prediction at line $.\") unless $type_id eq 'match'; $tmp = new Chado::Gene( $idMaker->next_id( 'type' => 'gene', 'project' => $project ), $start, $end, $strand, $seq_id, $score ); # Add transcript and polypeptide for the match foreach my $type ('transcript', 'polypeptide') { my $featid = $idMaker->next_id ('type' => $type, 'project' => $project ); $tmp->addFeature($featid, $start, $end, $strand, $type); } } elsif ($type_id eq 'cds') { # if this is a 'cds' we'll add a 'CDS' and 'exon' foreach my $type ('exon', 'CDS') { my $featid = $idMaker->next_id ('type' => $type, 'project' => $project ); $tmp->addFeature($featid, $start, $end, $strand, $type); } } elsif ($type_id eq 'intron') { next; } else { $logger->warn(\"Found unrecognized feature type. Skipping: $type_id at line $.\"); } } close IN; # Catch the last gene... if ($match_id) { my $count = $tmp->addToGroup($tmp->getId, { 'all' => 1 }); $logger->logdie(\"Nothing was added to group\") unless($count); push(@{$genes}, $tmp); } # and send them on the way! return $genes; } sub generateBsml { my $data = shift; #Create the document my $doc = new BSML::GenePredictionBsml( 'genewise', $input_seq ); foreach my $gene(@{$data}) { $doc->addGene($gene); } my $addedTo = $doc->setFasta($seq_id, $input_seq); $logger->logdie(\"$seq_id was not a sequence associated with the gene\") unless($addedTo); return $doc; } sub check_params { # Make sure we have what we expect to get my $error = ''; if ($options{'input_file'}) { $input = $options{'input_file'}; } else { $error .= \"input genewise raw was not defined with --input\\n\"; } if ($options{'input_seq'}) { $input_seq = $options{'input_seq'}; open(IN, \"< $input_seq\") or $logger->logdie(\"Unable to open $input_seq\"); while(<IN>) { #assume it's a single fasta file if(/^>([^\\s+]+)/) { $seq_id = $1; last; } } close(IN); } else { $error .= \"input sequence was not defined with --input_seq\\n\"; } if ($options{'output'}) { $output = $options{'output'}; } else { $error .= \"output BSML filename was not defined with --output\\n\"; } if ($options{'project'}) { $project = $options{'project'}; } else { $error .= \"You must specify a project name with --project\\n\"; } if ($options{'id_repository'}) { $idMaker = new Ergatis::IdGenerator('id_repository' => $options{'id_repository'}); $idMaker->set_pool_size( 'exon' => 20, 'transcript' => 20, 'gene' => 20, 'polypeptide' => 20, 'CDS' => 20 ); } else { $error .= \"You must specify an id repository with --id_repository\\n\"; } if ($error) { $logger->logdie($error); } } sub get_info_from_src { # pull the coords of the genome source and determine if these are on the forward # or reverse strands. my $ori; # open the input sequence open (my $src,\"<$input_seq\") || $logger->logdie(\"Unable to open genomic source: $input_seq: $!\"); # yank out the defline my $defline; while (<$src>) { if (/^>(\\S+)/) { $defline = $1; last; } } close $src; # We need to have a defline. die \"No defline found in input sequence: $input_seq\\n\" unless $defline; # pull out the coords and determine the orientation, also determine the # 'chunk_len' for adjusting coords on the reverse my ($lend, $rend, $chunk_len); if ($defline =~ /\\.?\\d+\\.(\\d+)\\.(\\d+)$/) { my ($end5, $end3) = ($1, $2); die \"Can't get coords from defline: $defline\\n\" unless ($end5 && $end3); $ori = ($end5 < $end3) ? 0 : 1; ($lend, $rend) = sort {$a <=> $b} ($end5, $end3); $chunk_len = $rend - $lend + 1; } return $ori, $lend, $chunk_len; }"
    },
    {
      "tool": "genezilla",
      "converter_script": "genezilla2bsml.pl",
      "name": "genezilla2bsml.pl - convert genezilla GFF output to BSML",
      "synopsis": "USAGE: genezilla2bsml.pl \n        --input_file=/path/to/genezilla.output.file.raw\n        --output=/path/to/output.bsml\n        --project=aa1 \n        --fasta_file=/path/to/somefile.fsa \n        --id_repository=/path/to/repository\n        --sourcename=sourcename",
      "description": "This script is used to convert the output from an genezilla search into BSML.",
      "options": {
        "input_file": "Input file from an genezilla scan.  -i, --input_list, will take\n    in a list of input files, all of which will be stored in a single\n    output bsml.",
        "output": "Output BSML file",
        "project": "Project ID.  Used in creating feature ids.",
        "fasta_file": "Needed tp create a Seq-data-import element referencing this path.",
        "id_repository": "path to --project's id_repository",
        "sourcename": "Value to be used for the sourcename, required for the analysis section.  Most\n    often should be the output_directory for the run.",
        "log": "Log file",
        "help": "This help message",
        "debug": "Debug level.  Use a large number to turn on verbose debugging."
      },
      "contact": "Jason Inman jinman@tigr.org =cut use strict; use Getopt::Long qw(:config no_ignore_case no_auto_abbrev); use Pod::Usage; use Ergatis::Logger; use Ergatis::IdGenerator; use BSML::GenePredictionBsml; use Chado::Gene; my @inputFiles; my $project; my $output; my $idMaker; my $bsml; my $data; my $inputFsa; my $sourcename; my $debug; my $length; my %options = (); my $results = GetOptions (\\%options, 'input_list|i=s', 'input_file|f=s', 'output|o=s', 'project|p=s', 'id_repository|r=s', 'fasta_input|a=s', 'sourcename|s=s', 'log|l=s', 'command_id=s', ## passed by workflow 'logconf=s', ## passed by workflow (not used) 'debug=s', 'help|h') || pod2usage(); my $logfile = $options{'log'} || Ergatis::Logger::get_default_logfilename(); my $logger = new Ergatis::Logger('LOG_FILE'=>$logfile, 'LOG_LEVEL'=>$options{'debug'}); $logger = $logger->get_logger(); # display documentation if( $options{'help'} ){ pod2usage( {-exitval=>0, -verbose => 2, -output => \\*STDOUT} ); } ## make sure all passed options are peachy &check_parameters(\\%options); foreach my $file (@inputFiles) { $data = &parseGenezillaData($file); $bsml = &generateBsml($data); } $bsml->writeBsml($output); exit(0); # Store all the info we need in the data hash, sub parseGenezillaData { my $inFile = shift; ## open the input file for parsing open (my $ifh,\"< $inFile\") || $logger->logdie(\"can't open input file for reading\"); my $source_seq_name = ''; my $current_group_name = ''; my $current_transcript_id = ''; my $previous_group_name = ''; my $first_in_group = 1; my $last_gene_found = 0; my $comp_val; my $poly_end = ''; my $min_exon_low = ''; my $max_exon_high = ''; my $genes; my %tmp; my @group_members = (); ## go through the file while (<$ifh>) { ## skip comment lines next if (/^##/); ## set flag for having passed out of gene data: $last_gene_found++ if /^#/; my @cols = (); ## grab/modify a few values for later use unless ($last_gene_found) { chomp; @cols = split(/\\t/); ## Get the group id. if ($cols[8] =~ /transgrp=(\\d+)\\;/) { $current_group_name = $1; } else { $logger->logdie(\"unrecognized format in attributes column: $cols[8]\"); } } ## if column 9 (group, $cols[8]) is defined and is different than the last one we need to ## add the gene to our list, after also adding the polypeptide and transcript. ## Also, if we hit a # then we should add the gene, too, as it indicates we've ## reached the end of the gene calls. if ( ($last_gene_found) || (!$first_in_group && $current_group_name ne $previous_group_name) ) { ## Take care of the polypeptide my $type = 'polypeptide'; my $typeid = $idMaker->next_id( 'type' => $type, 'project' => $project ); %tmp = ('typeid'=> $typeid, 'low' => $min_exon_low, 'high' => $max_exon_high, 'comp' => $comp_val, 'type' => $type); push @group_members, {%tmp}; ## Take care of the transcript. Make sure we account for the possibility ## of a poly-A-signal. $type = 'transcript'; my $low = 0; my $high = 0; if ($poly_end ne '') { $low = ($comp_val) ? $poly_end : $min_exon_low; $high = ($comp_val) ? $max_exon_high : $poly_end; } else { $low = $min_exon_low; $high = $max_exon_high; } $typeid = $idMaker->next_id( 'type' => $type, 'project' => $project); %tmp = ('typeid' => $typeid, 'low' => $low, 'high' => $high, 'comp' => $comp_val, 'type' => $type); push @group_members, {%tmp}; ## Create the gene object here my $tmpGene = new Chado::Gene( $idMaker->next_id( 'type' => 'gene', 'project' => $project ), $low, $high, $comp_val, $source_seq_name ); ## Add the features to the gene object here: foreach my $feat (@group_members) { $tmpGene->addFeature($$feat{'typeid'},$$feat{'low'},$$feat{'high'}, $$feat{'comp'},$$feat{'type'}); } ## Form the group here. my $count = $tmpGene->addToGroup($tmpGene->getId, { 'all' => 1 }); $logger->logdie(\"Nothing added to group\") unless ($count); push (@{$genes}, $tmpGene); last if $last_gene_found; # reset flag for to generate new Chado::Gene object with next line $first_in_group = 1; } if ($first_in_group) { # we'll need to make a new Chado::Gene for each new transgrp set. $first_in_group = 0; $min_exon_low = ''; $max_exon_high = ''; $comp_val = ''; $poly_end = ''; @group_members = (); } ## remember this group name $previous_group_name = $current_group_name; ## grab/modify a few values for later use unless ($last_gene_found) { ## store the source sequence name $source_seq_name = $cols[0]; ## count in interbase: $cols[3]--; ## store complement flag (1 is true, this is on reverse) $comp_val = ($cols[6] eq '+') ? 0 : 1; if ($cols[2] =~ /poly-A-signal/) { $poly_end = ($comp_val) ? $cols[3] : $cols[4]; } } # Handle exons: if ($cols[2] =~ /-exon$/) { foreach my $type( qw(exon CDS) ) { my $typeid = $idMaker->next_id( 'type' => $type, 'project' => $project); %tmp = ('typeid' => $typeid, 'low' => $cols[3], 'high' => $cols[4], 'comp' => $comp_val, 'type' => $type); push @group_members, {%tmp}; } # Adjust the boundaries for the transcript and possibly, polypeptide $min_exon_low = ($min_exon_low eq '') ? $cols[3] : (($min_exon_low < $cols[3] ) ? $min_exon_low : $cols[3] ); $max_exon_high = ($max_exon_high eq '') ? $cols[4] : (($max_exon_high > $cols[4]) ? $max_exon_high : $cols[4]); } # Handle poly-A-signal sequences if ($cols[2] =~ /poly-A-signal/) { my $type = 'polyA_signal_sequence'; my $typeid = $idMaker->next_id( 'type' => $type, 'project' => $project); %tmp = ('typeid' => $typeid, 'low' => $cols[3], 'high' => $cols[4], 'comp' => $comp_val, 'type' => $type); push @group_members, {%tmp}; } } return $genes; } sub generateBsml { my $data = shift; #Create the document my $doc = new BSML::GenePredictionBsml( 'genezilla', $sourcename); foreach my $gene(@{$data}) { $doc->addGene($gene); } my $seqId; open(IN, \"< $inputFsa\") or $logger->logdie(\"Unable to open $inputFsa\"); while(<IN>) { #assume it's a single fasta file if(/^>([^\\s+]+)/) { $seqId = $1; last; } } close(IN); my $addedTo = $doc->setFasta('', $inputFsa); $logger->logdie(\"$seqId was not a sequence associated with the gene\") unless($addedTo); return $doc; } sub check_parameters { my $options = shift; my $error = \"\"; if($options{'input_list'}) { $error .= \"Option input_list ($options{'input_list'}) does not exist\\n\" unless(-e $options{'input_list'}); open(IN, \"< $options{'input_list'}\") || $logger->logdie(\"Unable to open $options{'input_list'} ($!)\"); @inputFiles = <IN>; close(IN); } if($options{'input_file'}) { $error .= \"Option input_file ($options{'input_file'}) does not exist\\n\" unless(-e $options{'input_file'}); push(@inputFiles, $options{'input_file'}); } unless($options{'input_list'} || $options{'input_file'}) { $error .= \"Either option input_list or input_file is required\\n\"; } unless($options{'project'}) { $error .= $options{'project'}; } else { $project = $options{'project'}; } unless($options{'output'}) { $error .= \"Option output is required\\n\"; } else { $output = $options{'output'}; } unless($options{'id_repository'}) { $error .= \"Option id_repository is required. Please see Ergatis::IdGenerator \". \"for details.\\n\"; } else { $idMaker = new Ergatis::IdGenerator( 'id_repository' => $options{'id_repository'} ); $idMaker->set_pool_size( 'exon' => 20, 'transcript' => 20, 'gene' => 20, 'polypeptide' => 20, 'CDS' => 20 ); } unless($options{'fasta_input'}) { $error .= \"Option fasta_input is required\\n\"; } else { $error .= \"$options{'fasta_input'} (fasta_input) does not exist\\n\" unless(-e $options{'fasta_input'}); $inputFsa = $options{'fasta_input'}; #Find the length of the sequence open(IN, \"<$options{'fasta_input'}\") or $logger->logdie(\"Can't open $options->{'fasta_input'}\"); my $seq = \"\"; my $curId; while(<IN>) { chomp; if(/^>(\\S+)/) { if(defined($curId)) { $length->{$curId} = length($seq); $seq = \"\"; } $curId = $1; } else { $seq.= $_; } } $length->{$curId} = length($seq); close(IN); } ## get sourcedir for the analysis section: if ($options{'sourcename'}) { $sourcename = $options{'sourcename'}; } else { $error .= \"--sourcename is a required option.\\n\"; } if($options{'debug'}) { $debug = $options{'debug'}; } unless($error eq \"\") { $logger->logdie($error); } }"
    },
    {
      "tool": "genie",
      "converter_script": "genie2bsml.pl",
      "name": "genie2bsml.pl - convert genie GFF output to BSML",
      "synopsis": "USAGE: genie2bsml.pl \n        --input=/path/to/genie.output.file.gff \n        --output=/path/to/output.bsml\n      [ --project=aa1 \n        --fasta_file=/path/to/somefile.fsa \n      ]",
      "description": "This script is used to convert the output from a genie search into BSML.",
      "options": {
        "input": "Input file file from a genie scan.",
        "debug": "Debug level.  Use a large number to turn on verbose debugging.",
        "fasta_file": "If passed, will create a Seq-data-import element referencing this\n    path.",
        "project": "Project ID.  Used in creating feature ids.  Defaults to 'unknown' if\n    not passed.",
        "log": "Log file",
        "output": "Output BSML file (will be created, must not exist)",
        "help": "This help message"
      },
      "contact": "Joshua Orvis jorvis@tigr.org =cut use strict; use Getopt::Long qw(:config no_ignore_case no_auto_abbrev); use Pod::Usage; BEGIN { use Ergatis::Logger; use BSML::BsmlRepository; use Papyrus::TempIdCreator; use BSML::BsmlBuilder; use BSML::BsmlParserTwig; } my %options = (); my $results = GetOptions (\\%options, 'input|i=s', 'output|o=s', 'fasta_file|f=s', 'project|p=s', 'log|l=s', 'command_id=s', ## passed by workflow 'logconf=s', ## passed by workflow (not used) 'debug=s', 'help|h') || pod2usage(); my $logfile = $options{'log'} || Ergatis::Logger::get_default_logfilename(); my $logger = new Ergatis::Logger('LOG_FILE'=>$logfile, 'LOG_LEVEL'=>$options{'debug'}); $logger = $logger->get_logger(); # display documentation if( $options{'help'} ){ pod2usage( {-exitval=>0, -verbose => 2, -output => \\*STDOUT} ); } ## make sure all passed options are peachy &check_parameters(\\%options); ## we want a new doc my $doc = new BSML::BsmlBuilder(); ## we're going to generate ids my $idcreator = new Papyrus::TempIdCreator(); ## open the input file for parsing open (my $ifh, $options{'input'}) || $logger->logdie(\"can't open input file for reading\"); my $seq_id; my ($seq, $ft, $fg); my ($last_group_name, $current_group_name, $current_transcript_id); my ($thing, $id); ## we have to hold each cds in an array so that we can add 3 bases to the last ## one (genie doesn't include the stop codon within the cds) my @cds; ## go through the file while (<$ifh>) { chomp; my @cols = split(/\\t/); ## has the sequence been defined yet? it's in the first column ## this should happen on the first row only unless ($seq_id) { $seq_id = $cols[0]; $seq_id =~ s/\\s//g; $logger->debug(\"processing seq_id: $seq_id\\n\") if $logger->is_debug(); ## create this sequence, an analysis link, and a feature table $seq = $doc->createAndAddSequence($seq_id, undef, '', 'dna', 'assembly'); $seq->addBsmlLink('analysis', '#genie_analysis', 'input_of'); $ft = $doc->createAndAddFeatureTable($seq); ## also add a link to the fasta file (Seq-data-import) if requested if ($options{'fasta_file'}) { $logger->debug(\"adding link to fasta_file: $options{'fasta_file'}\\n\") if $logger->is_debug(); $doc->createAndAddSeqDataImport( $seq, 'fasta', $options{'fasta_file'}, '', $seq_id); } } $current_group_name = $cols[8] || ''; ## if column 9 (group) is defined and is different than the last one we need to ## create a new feature group if ($current_group_name && $current_group_name ne $last_group_name) { ## remember this group name $last_group_name = $current_group_name; ## add 3 bases to the last CDS, if any were found if (scalar @cds) { ## if on the reverse strand, we need to take three from column 2 ## if on the forward add three to column 3 ## assumes (obviously) that all CDS in this group are on the same strand if ($cds[-1][3]) { ## here we need to sort the CDS array because the terminal one isn't ## explicitly defined and the software can write them in any order. ## reverse strand, sort descending @cds = sort { $b->[1] <=> $a->[1] } @cds; $logger->debug(\"manually shifting 3 from reverse CDS coordinate $cds[-1][1] on $seq_id\\n\") if $logger->is_debug(); $cds[-1][1] -= 3; } else { ## here we need to sort the CDS array because the terminal one isn't ## explicitly defined and the software can write them in any order. ## reverse strand, sort descending @cds = sort { $a->[2] <=> $b->[2] } @cds; $logger->debug(\"manually pushing 3 onto forward CDS coordinate $cds[-1][2] on $seq_id\\n\") if $logger->is_debug(); $cds[-1][2] += 3; } for my $cd ( @cds ) { &add_feature( @{$cd} ); } undef @cds; } ## pull a new gene id (in genie this = primary transcript) $current_transcript_id = $idcreator->new_id( db => $options{project}, so_type => 'gene', prefix => $options{command_id} ); $fg = $doc->createAndAddFeatureGroup( $seq, '', $current_transcript_id ); } ## adjust both positions so that we are numbering from zero $cols[3]--; $cols[4]--; ## change the + and - symbols in strand column to 0 and 1, respectively if ($cols[6] eq '+') { $cols[6] = 0; } elsif ($cols[6] eq '-') { $cols[6] = 1; } else { $logger->logdie(\"unknown value ($cols[6]) in strand column. expected + or -.\"); } ## Exon if ($cols[2] eq 'Exon') { &add_feature('exon', $cols[3], $cols[4], $cols[6], ($cols[8] || 0) ); ## Intron } elsif ($cols[2] eq 'Intron') { &add_feature('intron', $cols[3], $cols[4], $cols[6], ($cols[8] || 0) ); ## Splice3 } elsif ($cols[2] eq 'Splice3') { &add_feature('splice_site', $cols[3], $cols[4], $cols[6], ($cols[8] || 0) ); ## Splice5 } elsif ($cols[2] eq 'Splice5') { &add_feature('splice_site', $cols[3], $cols[4], $cols[6], ($cols[8] || 0) ); ## CDS } elsif ($cols[2] eq 'CDS') { push @cds, [ 'CDS', $cols[3], $cols[4], $cols[6], ($cols[8] || 0) ]; #&add_feature('CDS', $cols[3], $cols[4], $cols[6], ($cols[8] || 0) ); ## Prim_Trans } elsif ($cols[2] eq 'Prim_Trans') { &add_feature('primary_transcript', $cols[3], $cols[4], $cols[6], ($cols[8] || 0) ); ## Stop } elsif ($cols[2] eq 'Stop') { &add_feature('transcription_end_site', $cols[3], $cols[4], $cols[6], ($cols[8] || 0) ); ## Start } elsif ($cols[2] eq 'Start') { &add_feature('transcription_start_site', $cols[3], $cols[4], $cols[6], ($cols[8] || 0) ); ## UTR5 } elsif ($cols[2] eq 'UTR5') { &add_feature('five_prime_UTR', $cols[3], $cols[4], $cols[6], ($cols[8] || 0) ); ## UTR3 } elsif ($cols[2] eq 'UTR3') { &add_feature('three_prime_UTR', $cols[3], $cols[4], $cols[6], ($cols[8] || 0) ); ## IG } elsif ($cols[2] eq 'IG') { &add_feature('intergenic_region', $cols[3], $cols[4], $cols[6], ($cols[8] || 0) ); } else { $logger->logdie(\"unrecognized type: $cols[2]\"); } } ## add the analysis element $doc->createAndAddAnalysis( id => 'genie_analysis', sourcename => $options{'output'}, ); ## now write the doc $doc->write($options{'output'}); exit; sub add_feature { my ($type, $start, $stop, $strand, $group) = @_; $logger->debug(\"add_feature($type, $start, $stop, $strand, $group)\\n\") if $logger->is_debug(); $id = $idcreator->new_id( db => $options{project}, so_type => $type, prefix => $options{command_id} ); $thing = $doc->createAndAddFeature( $ft, $id, '', $idcreator->so_used($type) ); $thing->addBsmlLink('analysis', '#genie_analysis', 'computed_by'); $thing->addBsmlIntervalLoc($start, $stop, $strand); ## some features aren't added to a group if ($group) { $fg->addBsmlFeatureGroupMember( $id, $idcreator->so_used($type) ); } ## if type is a primary_transcript we need to add a gene too if ($type eq 'primary_transcript') { $thing = $doc->createAndAddFeature( $ft, $current_transcript_id, '', $idcreator->so_used('gene') ); $thing->addBsmlLink('analysis', '#genie_analysis', 'computed_by'); $thing->addBsmlIntervalLoc($start, $stop, $strand); $fg->addBsmlFeatureGroupMember( $current_transcript_id, $idcreator->so_used('gene') ); } } sub check_parameters { ## make sure input file exists if (! -e $options{'input'}) { $logger->logdie(\"input file $options{'input'} does not exist\") } $options{'fasta_file'} = '' unless ($options{'fasta_file'}); $options{'project'} = 'unknown' unless ($options{'project'}); $options{'command_id'} = '0' unless ($options{'command_id'}); return 1; }"
    },
    {
      "tool": "genscan",
      "converter_script": "genscan2bsml.pl",
      "name": "genscan2bsml.pl - convert genscan output to BSML",
      "synopsis": "USAGE: genscan2bsml.pl \n        --input_file=/path/to/genscan.raw.file \n        --output=/path/to/output.bsml\n        --project=aa1 \n        --fasta_input=/path/to/somefile.fsa \n        --id_repository=/path/to/repository\n        --sourcename=sourcename\n        --programversion='current'",
      "description": "This script is used to convert the output from a genscan search into BSML.",
      "options": {
        "input_file": "Input file file from a genscan run.  -i, --input_list, will take in a list\n    of input files, all of which will be stored in a single output bsml.",
        "output": "Output BSML file (will be created, must not exist)",
        "project": "Project ID.  Used in creating feature ids.",
        "fasta_input": "Needed to create a Seq-data-import element referencing this path.",
        "id_repository": "path to --project's id_repository",
        "programversion": "Version string to be used as value for the analysis attribute 'programversion'",
        "sourcename": "Sourcename string to be used as value for the analysis attribute 'sourcename'\n    Due to a silly hack in analysis2bsml.pl, you might need to put /dummy/dir at\n    the end of it.",
        "log": "Log file",
        "debug": "Debug level.  Use a large number to turn on verbose debugging.",
        "help": "This help message"
      },
      "contact": "Jason Inman jinman@tigr.org =cut use strict; use Getopt::Long qw(:config no_ignore_case no_auto_abbrev); use Pod::Usage; use Ergatis::Logger; use Ergatis::IdGenerator; use BSML::GenePredictionBsml; use Chado::Gene; ### Some globals my @inputFiles; my $project; my $output; my $sourcename; my $idMaker; my $bsml; my $data; my $inputFsa; my $debug; my $length; my $programversion; my %options = (); my $results = GetOptions (\\%options, 'input_list|i=s', 'input_file|f=s', 'output|o=s', 'project|p=s', 'id_repository|r=s', 'fasta_input|a=s', 'sourcename|s=s', 'programversion|v=s', 'log|l=s', 'command_id=s', ## passed by workflow 'logconf=s', ## passed by workflow (not used) 'debug=s', 'help|h') || pod2usage(); my $logfile = $options{'log'} || Ergatis::Logger::get_default_logfilename(); my $logger = new Ergatis::Logger('LOG_FILE'=>$logfile, 'LOG_LEVEL'=>$options{'debug'}); $logger = $logger->get_logger(); # display documentation if( $options{'help'} ){ pod2usage( {-exitval=>0, -verbose => 2, -output => \\*STDOUT} ); } ## make sure all passed options are peachy &check_parameters(\\%options); foreach my $file (@inputFiles) { $data = &parseGenscanData($file); $bsml = &generateBsml($data); } $bsml->writeBsml($output); exit(0); sub parseGenscanData { my $inFile = shift; ## open the input file for parsing open (my $ifh, \"< $inFile\") || $logger->logdie(\"Can't open input file for reading\"); my $source_seq_name = ''; my $source_seq_len = 0; my $group_name = ''; my $comp_val; my $min_exon_low = ''; my $max_exon_high = ''; my $genes; my %tmp; my @group_members = (); while (<$ifh>) { if ($_ =~ /^Sequence (\\S+) : (\\d+) bp/) { $source_seq_name = $1; $source_seq_len = $2; last; } } ## skip the rest of the headers while (<$ifh>) { last if ($_ =~ /^[- ]+\\n/); } <$ifh>; ## go through the data now while (<$ifh>) { ## We're done if we encounter this line: last if ($_ =~ /Predicted peptide sequence/); chomp; ## remove a leading space from the early lines. This is sometimes ## inserted to keep formatting 'pretty'. Honestly, who's reading the ## raw files? Come ON! $_ =~ s/^ +//; ## add the group if we come across a blank line if ($_ eq '' && scalar(@group_members)) { # Sometimes, genscan predicts exon-less 'genes' such as a # lone poly a signal. Skip those stupid things. if (&count_exons(\\@group_members)){ &add_group(\\@group_members, $min_exon_low, $max_exon_high, $comp_val, \\$genes, $source_seq_name); } @group_members = (); $min_exon_low = ''; $max_exon_high = ''; next; } ## See description of the columns above. my @cols = split(/\\s+/); ##store complement flag (1 is true, meaining feature lies on reverse strand) $comp_val = ($cols[2] eq '+') ? 0 : 1; # set our low/high for this feature my $low = ($comp_val) ? $cols[4] : $cols[3]; my $high = ($comp_val) ? $cols[3] : $cols[4]; ## count in interbase: $low--; ## build our temporary object for this element %tmp = ('type' => $cols[1], 'low' => $low, 'high' => $high, 'comp' => $comp_val ); # add this to the group array. push @group_members, {%tmp}; # Adjust the min/max coords for the gene and polypeptide unless ($cols[1] =~ /Prom|PlyA/) { # set up initial low/highs or compare against existing low/highs $min_exon_low = ($min_exon_low eq '') ? $low : (($min_exon_low < $low ) ? $min_exon_low : $low ); $max_exon_high = ($max_exon_high eq '') ? $high : (($max_exon_high > $high) ? $max_exon_high : $high ); } } return $genes; } sub count_exons { my $grp_mems = shift; my $count = 0; foreach my $feat (@$grp_mems) { $count++ if ($feat->{'type'} =~ /Init|Intr|Term|Sngl/); } return $count; } sub add_group { my ($grp_mems, $min, $max, $comp, $genes, $source_seq_name) = @_; ## Create a new gene object: my $tmpGene = new Chado::Gene ( $idMaker->next_id( 'type' => 'gene', 'project' => $project ), $min, $max, $comp, $source_seq_name ); ## Add the polypeptide/transcript: foreach my $type( qw( transcript polypeptide ) ) { $tmpGene->addFeature( $idMaker->next_id( 'type' => $type, 'project' => $project ), $min, $max, $comp, $type ); } ## Now add the exons and other features foreach my $feat (@$grp_mems) { my $mem_type = $feat->{'type'}; if ($mem_type =~ /Init|Intr|Term|Sngl/) { foreach my $type ( qw( exon CDS ) ) { $tmpGene->addFeature( $idMaker->next_id( 'type' => $type, 'project' => $project), $$feat{'low'}, $$feat{'high'}, $$feat{'comp'}, $type ); } } elsif ($mem_type eq 'Prom') { $tmpGene->addFeature( $idMaker->next_id( 'type' => 'promoter', 'project' => $project), $$feat{'low'}, $$feat{'high'}, $$feat{'comp'}, 'promoter' ); } elsif ($mem_type eq 'PlyA') { $tmpGene->addFeature( $idMaker->next_id( 'type' => 'polyA_signal_sequence', 'project' => $project), $$feat{'low'}, $$feat{'high'}, $$feat{'comp'}, 'polyA_signal_sequence' ); } else { $logger->logdie(\"unrecognized feature type: $mem_type\\n\"); } } ## Form the group now: my $count = $tmpGene->addToGroup($tmpGene->getId, {'all' => 1}); $logger->logdie(\"Nothing added to group\") unless ($count); push @{$$genes}, $tmpGene; } sub generateBsml { my $data = shift; #Create the document my $doc = new BSML::GenePredictionBsml( 'genscan', $sourcename, $programversion); foreach my $gene(@{$data}) { $doc->addGene($gene); } my $seqId; open(IN, \"< $inputFsa\") or $logger->logdie(\"Unable to open $inputFsa\"); while(<IN>) { #assume it's a single fasta file if(/^>([^\\s+]+)/) { $seqId = $1; last; } } close(IN); my $addedTo = $doc->setFasta('', $inputFsa); $logger->logdie(\"$seqId was not a sequence associated with the gene\") unless($addedTo); return $doc; } sub check_parameters { my $options = shift; my $error = \"\"; # Check for input file(s) if($options{'input_list'}) { $error .= \"Option input_list ($options{'input_list'}) does not exist\\n\" unless(-e $options{'input_list'}); open(IN, \"< $options{'input_list'}\") || &_die(\"Unable to open $options{'input_list'} ($!)\"); @inputFiles = <IN>; close(IN); } if($options{'input_file'}) { $error .= \"Option input_file ($options{'input_file'}) does not exist\\n\" unless(-e $options{'input_file'}); push(@inputFiles, $options{'input_file'}); } unless($options{'input_list'} || $options{'input_file'}) { $error .= \"Either option input_list or input_file is required\\n\"; } # make sure we got a project unless ($options{'project'}) { $error .= \"Option project is required.\\n\"; } else { $project = $options{'project'}; } # Check for output file unless($options{'output'}) { $error .= \"Option output is required.\\n\"; } else { $output = $options{'output'}; } # Set up the id generator unless($options{'id_repository'}) { $error .= \"Option id_repository is required. Please see Ergatis::IdGenerator \". \"for details.\\n\"; } else { $idMaker = new Ergatis::IdGenerator( 'id_repository' => $options{'id_repository'} ); $idMaker->set_pool_size( 'exon' => 20, 'transcript' => 20, 'gene' => 20, 'polypeptide' => 20, 'CDS' => 20, 'promoter' => 20, 'polyA_signal_sequence' => 20, ); } # Check for input fasta sequence: unless($options{'fasta_input'}) { $error .= \"Option fasta_input is required\\n\"; } else { $error .= \"$options{'fasta_input'} (fasta_input) does not exist\\n\" unless(-e $options{'fasta_input'}); $inputFsa = $options{'fasta_input'}; #Find the length of the sequence open(IN, \"<$options{'fasta_input'}\") or $logger->logdie(\"Can't open $options->{'fasta_input'}\"); my $seq = \"\"; my $curId; while(<IN>) { chomp; if(/^>(\\S+)/) { if(defined($curId)) { $length->{$curId} = length($seq); $seq = \"\"; } $curId = $1; } else { $seq.= $_; } } $length->{$curId} = length($seq); close(IN); } ## get sourcedir for the analysis section: if ($options{'sourcename'}) { $sourcename = $options{'sourcename'}; } else { $error .= \"--sourcename is a required option.\\n\"; } ## get programversion for the analysis section if ($options{'programversion'}) { $programversion = $options{'programversion'}; } else { $programversion = 'current'; } if($options{'debug'}) { $debug = $options{'debug'}; } unless($error eq \"\") { $logger->logdie($error); } }"
    },
    {
      "tool": "gff",
      "converter_script": "gff2bsml.pl",
      "name": "gff32bsml.pl - Convert GFF3 annotation data into BSML.",
      "synopsis": "gff32bsml.pl\n         --input=/path/to/annotation.gff3\n         --output=/path/to/results.bsml\n         --project=rca1\n         --id_repository=/usr/local/projects/rca1/workflow/project_id_repository\n         --organism='Aspergillus nidulans'\n        [--peptide_fasta=/path/to/peptide-seqs.fsa\n         --peptide_id_regex='^>(\\S+)'\n         --peptide_id_prefix=''\n         --peptide_id_suffix='-Protein'\n         --peptide_no_seqdata\n         --dna_fasta=/path/to/dna-seqs.fsa\n         --dna_id_regex='^>(\\S+)'\n         --dna_id_prefix='Chr'\n         --dna_id_suffix=''\n         --dna_no_seqdata\n         --gene_type=gene\n         --organism_genetic_code=1\n         --organism_mt_genetic_code=4\n         --use_cds_parent_ids\n         --insert_missing_mrnas\n         --insert_missing_exons\n         --insert_polypeptides\n         --inserted_polypeptide_id_type=CDS\n         --default_seq_class=assembly\n         --default_seq_attributes='SO:contig'\n         --feat_attribute_mappings='Name:gene_product_name,comment:comment'\n         --clone_feat_attribute_mappings='gene:gene_product_name:transcript,gene:gene_product_name:CDS'\n         --feat_xref_mappings='ID:mydb:accession,Name:mydb:pub_locus'\n         --clone_feat_xref_mappings='gene:NCBILocus:transcript,gene:NCBILocus:CDS'\n         --seq_xref_mappings='ID:mydb:seq_id'\n         --atts_with_unescaped_commas='ID,Name'\n         --allow_genes_with_no_cds\n         --sofa_type_mappings='transcript=>CDS,ORF=>gene'\n         --log=/path/to/some.log\n         --debug=4\n         --help\n         --man ]",
      "description": "This script parses a single GFF input file containing annotation data (for one or more\ngenomic sequences) and writes it out as a BSML document that can be subsequently fed \ninto bsml2chado to load it into a Chado database.  This script was originally created \nby copying and then generalizing Brett Whitty's evmgff32bsml.pl utility.",
      "options": {
        "input": "path to the input GFF file.",
        "peptide_fasta": "optional.  path to a multi-FASTA file containing the polypeptides for the genes in the GFF file.\n    if this argument is supplied then the named file _must_ contain all the sequences for the \n    polypeptide/protein features in the input GFF file, _except_ those that appear in the ##FASTA\n    section of the GFF file.",
        "peptide_id_regex": "optional.  regular expression used to parse peptide unique id from FASTA deflines in --peptide_fasta\n    and the FASTA section of the GFF file itself.  in the latter case, the regular expression must NOT\n    match any non-peptide ids, otherwise --peptide_id_prefix and --peptide_id_suffix may be misapplied.\n    default = ^>(\\S+)",
        "peptide_id_prefix": "optional. prefix to prepend to the id parsed by --peptide_id_regex to produce the polypeptide ID \n    used by the corresponding GFF feature.",
        "peptide_id_suffix": "optional. suffix to append to the id parsed by --peptide_id_regex to produce the polypeptide ID \n    used by the corresponding GFF feature.",
        "peptide_no_seqdata": "do not create Seq-data or Seq-data-import entries for the polypeptide sequences; use --peptide_fasta,\n    if specified, only to determine the sequence length(s).",
        "dna_fasta": "optional.  path to a multi-FASTA file containing the DNA sequences for the reference sequences\n    in the GFF file.  if this argument is supplied then the named file _must_ contain all of the \n    sequences for the genomic sequence features in the input GFF file, _except_ those that appear\n    in the ##FASTA section of the GFF file.",
        "dna_id_regex": "optional.  regular expression used to parse the sequence unique id from FASTA deflines in \n    --dna_fasta and the FASTA section of the GFF file itself.  in the latter case, the regular \n    expression must NOT match any non-peptide ids, otherwise --dna_id_prefix and --dna_id_suffix \n    may be misapplied..   default = ^>(\\S+)",
        "dna_id_prefix": "optional. prefix to prepend to the id parsed by --dna_id_regex to produce the sequence ID \n    used by the corresponding GFF feature.",
        "dna_id_suffix": "optional. suffix to append to the id parsed by --dna_id_regex to produce the sequence ID \n    used by the corresponding GFF feature.",
        "dna_no_seqdata": "do not create Seq-data or Seq-data-import entries for the DNA/reference sequences; use --dna_fasta,\n    if specified, or the sequences present in the GFF file, only to determine the sequence length(s).",
        "gene_type": "optional.  specifies a SO type in the input GFF file that should be replaced with \"gene\".  this can\n    be used to handle nonstandard inputs in which, for example, the term \"match\" is used as the parent\n    of one or more CDS features (e.g., as in GeneWise GFF output)  Note that the SO types _are_\n    case-sensitive.",
        "organism_genetic_code": "optional.  specifies a genetic code value to appear in the BSML <Organism> element for --organism\n    see http://www.ncbi.nlm.nih.gov/Taxonomy/Utils/wprintgc.cgi?mode=c#SG1 for values",
        "organism_mt_genetic_code": "optional.  specifies a mitochondrial genetic code value to appear in the BSML <Organism> element \n    for --organism.  see http://www.ncbi.nlm.nih.gov/Taxonomy/Utils/wprintgc.cgi?mode=c#SG1 for values",
        "output": "output BSML file (which should not exist before running the script.)",
        "project": "project/database name used to create unique feature identifiers.",
        "id_repository": "path to the Ergatis project_id_repository for the current project.",
        "organism": "organism to place in the BSML <Genomes> section.  the first word will be used as the BSML genus,\n    and the rest of the string will be placed in the BSML species attribute.",
        "use_cds_parent_ids": "optional.  whether to use the GFF parent id to identify CDS features that lack an ID of their own.",
        "insert_missing_mrnas": "optional.  automatically insert missing mRNA features wherever they are missing from the GFF \n    (i.e., anytime a CDS feature is found hanging directly off a gene feature)",
        "insert_missing_exons": "optional.  automatically inserts missing exon features in any gene model that does not have _any_\n    exons but does have CDS features.  in this case a single exon will be created to exactly span each\n    CDS.",
        "insert_polypeptides": "optional.  automatically inserts a polypeptide feature in any gene model that has one or more CDS\n    features but no polypeptide feature.",
        "inserted_polypeptide_id_type": "optional. specifies which feature ('CDS', 'gene', 'transcript', or 'mRNA') the newly-inserted\n    polypeptide ids should be based on (default = 'gene')  the id of the new polypeptide will be \n    formed by taking the GFF id of the corresponding named feature and appending \"-Protein\"  \n    Note that \"transcript\" and \"mRNA\" are synonymous for the purposes of this option.",
        "default_seq_class": "optional.  default sequence class/SO type (e.g., 'assembly', 'supercontig') to use for sequences \n    for which the type cannot be parsed from the GFF file.",
        "default_seq_attributes": "optional.  comma-delimited list of BSML attributes (in colon-delimited key:value form) to associate\n    with each genomic sequence in the GFF file.",
        "feat_attribute_mappings": "optional.  a comma-delimited list of GFF attribute -> BSML Attribute mappings, each of which is\n    defined by a source (GFF) attribute name and a target (BSML) attribute name, separated by a colon,\n    for example \"Name:gene_product_name\" will take each BSML 'Name' value and insert it into the \n    BSML document as an <Attribute> with name=\"Name\" and content=the corresponding GFF attribute value.\n    Any embedded colons may be escaped with a backslash (\"\\:\")",
        "clone_feat_attribute_mappings": "optional.  a comma-delimited list of colon-separated values.  each member of the list is a colon-\n    separated triplet that contains 1. a source SOFA type, 2. a BSML attribute name, and 3. a target \n    SOFA type.  e.g., \"gene:gene_product_name:CDS,gene:gene_product_name:transcript\"  This particular\n    example specifies that--within each gene model/feature group--any gene_product_name BSML Attributes\n    attached to the gene feature will be copied over to the associated transcript and CDS features\n    (without introducing duplicate attribute values).  This cloning/copying is done _after_ any applicable \n    --feat_attribute_mappings have been processed for all of the involved features.",
        "feat_xref_mappings": "optional.  a comma-delimited list of GFF attribute -> BSML Cross-reference mappings, each of which\n    is defined by a set of 3 values separated by colons, as in 'ID:mydb:accession', which specifies\n    that each BSML 'ID' value should be inserted into the BSML document as a <Cross-reference> \n    element with database=\"mydb\" and identifier-type=\"accession\" (and identifier set to the ID value.)\n    Any embedded colons may be escaped with a backslash (\"\\:\")",
        "clone_feat_xref_mappings": "optional.  behaves similarly to --clone_feat_attribute_mappings, but copying BSML <Cross-references>\n    instead of <Attributes>",
        "seq_xref_mappings": "optional.  identical to --xref_mappings except that it defines cross-reference mappings for the \n    reference _sequences_ in the GFF files (i.e., those things whose IDs appear in GFF column 1)\n    in the case where the sequences are not themselves defined as GFF features the only attribute for\n    which a mapping may be specified is 'ID'.",
        "atts_with_unescaped_commas": "optional.  a comma-delimited list of GFF3 attributes whose values (incorrectly) contain unescaped\n    commas.  instead of parsing these values as comma-delimited lists the program will treat each as\n    a single value and will parse it as though the commas embedded in the value had been correctly \n    URL-escaped.",
        "allow_genes_with_no_cds": "optional.  normally the script expects that any non-protein-coding gene will either: 1. be assigned\n    an explicit SO type of 'pseudogene' instead of 'gene' or 2. have a non-coding RNA SO type at the\n    transcript level (e.g., ncRNA, tRNA, etc.)  therefore if the script is running with --insert_polypeptides\n    and finds a gene for which neither of these things are true, it will fail with an error if the gene\n    lacks a CDS.  use this flag to permit the conversion to continue with a warning instead.",
        "sofa_type_mappings": "optional.  a comma-delimited list of SOFA id or name mappings, in the form id1=>id2 or name1=>name2.\n    each occurrence of id1 or name1 in the GFF3 SOFA feature type column (GFF3 column #3) will be\n    replaced by id2/name2 prior to performing any subsequent parsing.  this option can be useful for\n    making a GFF3 file more closely match the canonical gene encoding.  for example, if a GFF3 file\n    uses the term \"ORF\" instead of \"gene\" it can be rectified by specifying\n    --sofa_type_mappings='ORF=>gene'",
        "log": "optional.  path to a log file the script should create.  will be overwritten if\n    it already exists.",
        "debug": "optional.  the debug level for the logger (an integer)",
        "help": "print usage/help documentation",
        "man": "print detailed usage/help documentation"
      },
      "contact": "Jonathan Crabtree jonathancrabtree@gmail.com =cut use strict; use warnings; use Getopt::Long qw(:config no_ignore_case no_auto_abbrev); use Pod::Usage; use Data::Dumper; use BSML::BsmlBuilder; use Ergatis::IdGenerator; use Ergatis::Logger; use FileHandle; use File::Spec; use URI::Escape; ## global/default values my $DEFAULT_SEQ_CLASS = 'assembly'; my $DEFAULT_PEPTIDE_ID_REGEX = '^>(\\S+)'; my $DEFAULT_DNA_ID_REGEX = '^>(\\S+)'; my $GFF_SEQID_REGEX = '^(>\\S.*)'; my $GLOBAL_ID_COUNTER = 0; my $NODES = {}; # mapping from GFF sequence id to BSML sequence id. these need not be the same. my $GFF2BSML_SEQID_MAP = {}; # mapping from GFF3 feature type to Chado cvterm. if the script encounters # a GFF type not found in this hashref it will fail my $FEAT_TYPE_MAP = { 'gene' => 'gene', 'ORF' => 'gene', 'CDS' => 'CDS', 'cds' => 'CDS', 'exon' => 'exon', 'intron' => 'intron', 'mRNA' => 'transcript', 'tmRNA' => 'tmRNA', 'transcript' => 'transcript', 'miRNA' => 'miRNA', 'protein' => 'polypeptide', 'polypeptide' => 'polypeptide', 'tRNA' => 'tRNA', 'ncRNA' => 'ncRNA', 'snoRNA' => 'snoRNA', 'snRNA' => 'snRNA', 'rRNA' => 'rRNA', 'three_prime_UTR' => 'three_prime_UTR', 'five_prime_UTR' => 'five_prime_UTR', 'three_prime_utr' => 'three_prime_UTR', 'five_prime_utr' => 'five_prime_UTR', 'gap' => 'gap', 'pseudogene' => 'pseudogene', 'contig' => 'contig', 'supercontig' => 'supercontig', 'chromosome' => 'chromosome', }; # list of types that are allowed for the mRNA; must be a subset of those # listed _as values_ in $FEAT_TYPE_MAP my $MRNA_TYPES = { 'transcript' => 1, 'miRNA' => 1, 'tRNA' => 1, 'ncRNA' => 1, 'snoRNA' => 1, 'snRNA' => 1, 'rRNA' => 1, 'tmRNA' => 1, }; # TODO - add all posible mRNA types from SO? my $NONCODING_RNA_TYPES = { 'miRNA' => 1, 'tRNA' => 1, 'ncRNA' => 1, 'snoRNA' => 1, 'snRNA' => 1, 'rRNA' => 1, # not exactly true, but it wouldn't be handled correctly in the other category: 'tmRNA' => 1, }; ## input/options my $options = {}; my $results = GetOptions($options, 'input|g=s', 'peptide_fasta=s', 'peptide_id_regex=s', 'peptide_id_prefix=s', 'peptide_id_suffix=s', 'peptide_no_seqdata', 'dna_fasta=s', 'dna_id_regex=s', 'dna_id_prefix=s', 'dna_id_suffix=s', 'dna_no_seqdata', 'gene_type=s', 'organism_genetic_code=i', 'organism_mt_genetic_code=i', 'output|o=s', 'project|p=s', 'id_repository|i=s', 'organism|r=s', 'use_cds_parent_ids|c', 'insert_missing_mrnas', 'insert_missing_exons', 'insert_polypeptides', 'inserted_polypeptide_id_type=s', 'default_seq_class|e=s', 'default_seq_attributes|e=s', 'feat_attribute_mappings=s', 'clone_feat_attribute_mappings=s', 'feat_xref_mappings|x=s', 'clone_feat_xref_mappings|x=s', 'seq_xref_mappings=s', 'atts_with_unescaped_commas=s', 'allow_genes_with_no_cds', 'sofa_type_mappings=s', 'log|l=s', 'debug|d=i', 'help|h', 'man|m' ) || pod2usage(); &pod2usage({-exitval => 1, -verbose => 1, -output => \\*STDOUT}) if ($options->{'help'}); &pod2usage({-exitval => 1, -verbose => 2, -output => \\*STDOUT}) if ($options->{'man'}); &check_parameters($options); my $unescaped_comma_atts = {}; if (defined($options->{'atts_with_unescaped_commas'})) { map { $unescaped_comma_atts->{$_} = 1; } split(/\\s*,\\s*/, $options->{'atts_with_unescaped_commas'}); } if (defined($options->{'gene_type'})) { $FEAT_TYPE_MAP->{$options->{'gene_type'}} = $FEAT_TYPE_MAP->{'gene'}; } ## initialize logging my $logfile = $options->{'log'} || Ergatis::Logger::get_default_logfilename(); my $logger = new Ergatis::Logger('LOG_FILE'=>$logfile, 'LOG_LEVEL'=>$options->{'debug'}); $logger = Ergatis::Logger::get_logger(); if (defined($options->{'sofa_type_mappings'})) { my @mappings = split(/,/, $options->{'sofa_type_mappings'}); foreach my $mapping (@mappings) { my($from,$to) = ($mapping =~ /^(\\S+)\\s*\\=\\>\\s*(\\S+)$/); $logger->logdie(\"unable to parse sofa_type_mapping from $mapping\") if (!defined($to)); $FEAT_TYPE_MAP->{$from} = $to; $logger->debug(\"sofa_type_mapping: $from => $to\"); } } ## MAIN SECTION my $idcreator = Ergatis::IdGenerator->new('id_repository' => $options->{'id_repository'}); my @root_nodes = (); my($genus, $species) = ($options->{'organism'} =~ /^(\\S+) (.*)$/); ## parse peptide FASTA (optional) my $peptides = undef; my $pep_prefix = $options->{'peptide_id_prefix'}; my $pep_suffix = $options->{'peptide_id_suffix'}; if (defined($options->{'peptide_fasta'})) { my $pep_id_fn = sub { my($id) = @_; my $new_id = (defined($pep_prefix)) ? $pep_prefix . $id : $id; $new_id .= $pep_suffix if (defined($pep_suffix)); return $new_id; }; $peptides = &read_sequence_lengths($options->{'peptide_fasta'}, $options->{'peptide_id_regex'}, $pep_id_fn); } ## parse genomic DNA FASTA (optional) my $dna_seqs = undef; my $dna_prefix = $options->{'dna_id_prefix'}; my $dna_suffix = $options->{'dna_id_suffix'}; if (defined($options->{'dna_fasta'})) { my $dna_id_fn = sub { my($id) = @_; my $new_id = (defined($dna_prefix)) ? $dna_prefix . $id : $id; $new_id .= $dna_suffix if (defined($dna_suffix)); return $new_id; }; $dna_seqs = &read_sequence_lengths($options->{'dna_fasta'}, $options->{'dna_id_regex'}, $dna_id_fn); } ## parse GFF open (IN, $options->{'input'}) || die \"couldn't open input file '$options->{input}'\"; my $lnum = 0; my $found_fasta_header = 0; while (<IN>) { chomp; ++$lnum; # fasta-format sequences if (/^>/ || /^\\#.*fasta.*/i) { $found_fasta_header = 1; last; } # ignore blank lines and those beginning with '#' elsif (/^\\#|^\\s*$/) { # no-op } else { my $record = parse_record($_, $lnum); # if it has no parents it's a root node if ((!$record->{'Parent'}) && (!$record->{'Derives_from'})) { push(@root_nodes, $record); } # store records in a set of arrays indexed by ID if ($record->{'ID'}) { push(@{$NODES->{$record->{'ID'}}->{'records'}},$record); } } } # write FASTA sequences from GFF directly to an external file my $gff_seqs = undef; my $gff_seq_file = undef; if ($found_fasta_header) { $gff_seq_file = $options->{'output'} . \".fsa\"; $logger->logdie(\"$gff_seq_file already exists; please remove it and rerun\") if (-e $gff_seq_file); my $ffh = FileHandle->new(); $ffh->open(\">$gff_seq_file\") || die \"\"; while (my $line = <IN>) { $ffh->print($line); } $ffh->close(); my $pep_regex = $options->{'peptide_id_regex'}; my $dna_regex = $options->{'dna_id_regex'}; # then parse that file back to get the sequences my $gff_seqid_fn = sub { my($id) = @_; if (($pep_regex ne $DEFAULT_PEPTIDE_ID_REGEX) && ($id =~ /$pep_regex/)) { my $new_id = (defined($pep_prefix)) ? $pep_prefix . $1 : $1; $new_id .= $pep_suffix if (defined($pep_suffix)); return $new_id; } elsif (($dna_regex ne $DEFAULT_DNA_ID_REGEX) && ($id =~ /$dna_regex/)) { my $new_id = (defined($dna_prefix)) ? $dna_prefix . $1 : $1; $new_id .= $dna_suffix if (defined($dna_suffix)); return $new_id; } # default my ($new_id) = ($id =~ /^>(\\S+)/); return $new_id; }; $gff_seqs = &read_sequence_lengths($gff_seq_file, $GFF_SEQID_REGEX, $gff_seqid_fn); } close IN; # populate children for each record foreach my $id(keys(%{$NODES})) { foreach my $record(@{$NODES->{$id}->{'records'}}) { if (defined($record->{'children'})) { $logger->warn(\"about to overwrite children field of record $record with id=$id)\"); } $record->{'children'} = $NODES->{$id}->{'children'}; delete $NODES->{$id}->{'children'}; } } my $gene_nodes = []; fetch_node_type('gene', \\@root_nodes, $gene_nodes); my $num_genes = scalar(@$gene_nodes); $logger->debug(\"found $num_genes gene(s)\"); my $doc = new BSML::BsmlBuilder(); my $seq2feat_table = undef; # global var # add Genomes my $genome = $doc->createAndAddGenome(); my $genome_id = $genome->{attr}->{id}; my $organism = $doc->createAndAddOrganism('genome' => $genome, 'genus' => $genus, 'species' => $species); my $code = $options->{'organism_genetic_code'}; my $mt_code = $options->{'organism_mt_genetic_code'}; my $code_att = $doc->createAndAddBsmlAttribute($organism, 'genetic_code', $code) if (defined($code)); my $mt_code_att = $doc->createAndAddBsmlAttribute($organism, 'mt_genetic_code', $mt_code) if (defined($mt_code)); # copied this from legacy2bsml.pl. not clear why this isn't handled internally to the BsmlDoc # (or why 'xrefctr' is used for an id shared by both x-refs and genomes) $doc->{'xrefctr'}++; # database cross-reference mappings, indexed by GFF attribute my $feat_xref_mappings = &parse_xref_mappings($options->{'feat_xref_mappings'}); my $seq_xref_mappings = &parse_xref_mappings($options->{'seq_xref_mappings'}); # GFF -> BSML Attribute mappings my $feat_att_mappings = &parse_attribute_mappings($options->{'feat_attribute_mappings'}); # feature xrefs and attributes that must be cloned my $clone_feat_att_mappings = &parse_clone_attribute_mappings($options->{'clone_feat_attribute_mappings'}); my $clone_feat_xref_mappings = &parse_clone_xref_mappings($options->{'clone_feat_xref_mappings'}); foreach my $root (@{$gene_nodes}) { if ($root->{'_type'} eq 'gene') { # insert missing features if the appropriate options are set my ($cds_type, $mrna_type, $exon_type, $intron_type, $utr3_type, $utr5_type) = map {$FEAT_TYPE_MAP->{$_}} ('CDS', 'mRNA', 'exon', 'intron', 'three_prime_UTR', 'five_prime_UTR'); # insert mRNA, if none and --insert_missing_mrnas set if ((!defined($root->{'children'}->{$mrna_type}) && $options->{'insert_missing_mrnas'})) { $logger->debug(\"inserting missing mRNA for \" . $root->{'ID'}); my $trans_id = $root->{'ID'} . \"-mRNA\"; my $cds_list = $root->{'children'}->{$cds_type}; my $exon_list = $root->{'children'}->{$exon_type}; my $intron_list = $root->{'children'}->{$intron_type}; my $mrna_list = $root->{'children'}->{$mrna_type} = []; my $utr3_list = $root->{'children'}->{$utr3_type}; my $utr5_list = $root->{'children'}->{$utr5_type}; # extent of mRNA should = extent of exons (if present), of CDS feats if not my $feat_list = defined($exon_list) ? $exon_list : $cds_list; my($m_start, $m_end, $m_strand) = &union_feat_intervals($feat_list); if (!defined($exon_list) && !defined($cds_list)) { $logger->warn(\"Trying to insert mRNA $trans_id for gene \" . $root->{'ID'} . \" but no CDS or exons could be found: using gene coords instead.\"); ($m_start, $m_end, $m_strand) = ($root->{_start}, $root->{_end}, $root->{_strand}); } elsif (($m_start != $root->{_start}) || ($m_end != $root->{_end}) || ($m_strand != $root->{_strand})) { $logger->debug($root->{'ID'} . \": mrna coords=$m_start-$m_end/$m_strand gene coords=\" . $root->{_start} . \"-\" . $root->{_end} . \"/\" . $root->{_strand} . \"\\n\"); } push(@$mrna_list, { 'ID' => $trans_id, '_seqid' => $root->{'_seqid'}, '_type' => $mrna_type, 'children' => {}, 'Parent' => [ $root->{'ID'} ], '_source' => $root->{'_source'}, '_score' => '.', '_strand' => $m_strand, '_start' => $m_start, '_end' => $m_end, # TODO - propagation of cross-references to automatically-inserted features should be optional: '_record' => $feat_list->[0]->{'_record'}, }); # make mRNA the parent of the CDS, exon, and intron features map { push(@{$_->{'Parent'}}, $trans_id); } @$cds_list if (defined($cds_list)); map { push(@{$_->{'Parent'}}, $trans_id); } @$exon_list if (defined($exon_list)); map { push(@{$_->{'Parent'}}, $trans_id); } @$intron_list if (defined($intron_list)); map { push(@{$_->{'Parent'}}, $trans_id); } @$utr3_list if (defined($utr3_list)); map { push(@{$_->{'Parent'}}, $trans_id); } @$utr5_list if (defined($utr5_list)); } # insert exons, if none and --insert_missing_exons set my $exon_list = $root->{'children'}->{$exon_type}; my $num_exons = defined($exon_list) ? scalar(@$exon_list) : 0; if (($num_exons == 0) && $options->{'insert_missing_exons'}) { my $cds_list = $root->{'children'}->{$cds_type}; my $mrna_list = $root->{'children'}->{$mrna_type}; my $nm = scalar(@$mrna_list); if (defined($cds_list)) { if (scalar(@$mrna_list) != 1) { $logger->error(\"can't insert exons for \" . $root->{'ID'} . \": gene has $nm mRNAs\"); } else { my $exon_list = $root->{'children'}->{$exon_type} = []; my $nc = scalar(@$cds_list); my $mrna_id = $mrna_list->[0]->{'ID'}; $logger->debug(\"inserting $nc missing exon(s) for \" . $root->{'ID'}); my $mrna_exons = $mrna_list->[0]->{'children'}->{$exon_type}; if (!defined($mrna_exons)) { $mrna_exons = $mrna_list->[0]->{'children'}->{$exon_type} = []; } my $enum = 1; foreach my $cds (@$cds_list) { my $exon_id = $mrna_id . \"-e\" . $enum++; my $exon = { 'ID' => $exon_id, '_seqid' => $cds->{'_seqid'}, '_type' => $exon_type, 'children' => {}, 'Parent' => [ $mrna_id ], '_source' => $cds->{'_source'}, '_score' => '.', '_strand' => $cds->{'_strand'}, '_start' => $cds->{'_start'}, '_end' => $cds->{'_end'}, # TODO - propagation of cross-references to automatically-inserted features should be optional: '_record' => $cds->{'_record'}, }; push(@$exon_list, $exon); push(@$mrna_exons, $exon); } } } else { $logger->debug(\"not inserting exons for $root->{ID}: no CDS seqs found\"); } } my $features = {}; process_node($root, $features); gene_feature_hash_to_bsml($NODES, $features, $gff_seqs, $peptides, $dna_seqs, $root->{'_seqid'}); } } # add the analysis element # TODO - need a way to specify which features get linked to an analysis #$doc->createAndAddAnalysis( # id => 'EVM_analysis', # sourcename => $options->{'output'}, # ); $doc->write($options->{'output'}); exit(0); ## subroutines sub parse_xref_mappings { my($mapping_str) = @_; return &parse_mappings($mapping_str, 'xref', ['db_name', 'id_type']); } sub parse_attribute_mappings { my($mapping_str) = @_; return &parse_mappings($mapping_str, 'attribute', ['bsml_att']); } sub parse_clone_attribute_mappings { my($mapping_str) = @_; return &parse_mappings($mapping_str, 'cloned attribute', ['bsml_att', 'target_type']); } sub parse_clone_xref_mappings { my($mapping_str) = @_; return &parse_mappings($mapping_str, 'cloned xrefs', ['db_name', 'target_type']); } sub parse_mappings { my($mapping_str, $type, $fieldnames) = @_; my $mappings = {}; my $nfn = scalar(@$fieldnames); if (defined($mapping_str)) { my @mstrs = split(',', $mapping_str); foreach my $mstr (@mstrs) { my($key, @fields) = split(':', $mstr); $key =~ s/\\://g; my $list = $mappings->{$key}; $list = $mappings->{$key} = [] if (!defined($list)); my $val = {}; my $ff = scalar(@fields); die \"expected $nfn fields, only found $ff in '$mstr'\" if ($nfn != scalar(@fields)); for (my $i = 0;$i < $nfn;++$i) { $val->{$fieldnames->[$i]} = $fields[$i]; } push(@$list, $val); $logger->info(\"parsed $type mapping for key: $key, \" . join(\", \", map {$_ . \"=\" . $val->{$_}} @$fieldnames)); } } return $mappings; } sub union_feat_intervals { my($feats) = @_; my $min_start = undef; my $max_end = undef; my $strand = undef; foreach my $feat (@$feats) { my($fs, $fe, $fstr) = map { $feat->{$_} } ('_start', '_end', '_strand'); die \"feature $feat->{ID} has no _start\" if (!defined($fs)); die \"feature $feat->{ID} has no _end\" if (!defined($fe)); die \"feature end < start in feature $feat->{ID}\" if ($fe < $fs); die \"feature $feat->{ID} has no _strand\" if (!defined($fstr)); if (!defined($min_start)) { $min_start = $fs; $max_end = $fe; $strand = $fstr; } else { die \"strand mismatch ($strand vs $fstr) in feature $feat->{ID}\" if ($strand != $fstr); $min_start = $fs if ($fs < $min_start); $max_end = $fe if ($fe > $max_end); } } return($min_start, $max_end, $strand); } sub check_parameters { my $options = shift; ## make sure required parameters were passed my @required = qw(input output project id_repository organism); for my $option ( @required ) { unless ( defined $options->{$option} ) { die \"--$option is a required option\"; } } ## default values $options->{'default_seq_class'} = $DEFAULT_SEQ_CLASS if (!defined($options->{'default_seq_class'})); $options->{'project'} =~ tr/A-Z/a-z/; $options->{'dna_id_regex'} = $DEFAULT_DNA_ID_REGEX if (!defined($options->{'dna_id_regex'})); $options->{'peptide_id_regex'} = $DEFAULT_PEPTIDE_ID_REGEX if (!defined($options->{'peptide_id_regex'})); $options->{'inserted_polypeptide_id_type'} = 'gene' if (!defined($options->{'inserted_polypeptide_id_type'})); ## check files my $input = $options->{'input'}; die \"input GFF file ($input) does not exist\" if (!-e $input); die \"input GFF file ($input) is not readable\" if (!-r $input); my $peps = $options->{'peptide_fasta'}; if (defined($peps)) { die \"input peptide FASTA file ($peps) does not exist\" if (!-e $peps); die \"input peptide FASTA file ($peps) is not readable\" if (!-r $peps); } my $dnas = $options->{'dna_fasta'}; if (defined($dnas)) { die \"input DNA sequence FASTA file ($dnas) does not exist\" if (!-e $dnas); die \"input DNA sequence FASTA file ($dnas) is not readable\" if (!-r $dnas); } if ($options->{'organism'} !~ /^\\S+\\s\\S+/) { die \"--organism must specify a species and genus, e.g., --organism='Aspergillus nidulans'\"; } if ($options->{'inserted_polypeptide_id_type'} !~ /^gene|CDS|mRNA|transcript$/) { die \"--inserted_polypeptide_id_type must be one of the following: gene,CDS,mRNA,transcript\"; } } # Parse a single GFF3 record. # # $line - A chomp'ed GFF3 feature line. # sub parse_record { my ($line, $linenum) = @_; my $record = {}; my $attrib_hash = {}; my $record_id = ''; my $parent_id = ''; my @cols = split(\"\\t\"); # convert to interbase coordinates: $cols[3]--; # change the + and - symbols in strand column to 0 and 1, respectively if ($cols[6] eq '+') { $cols[6] = 0; } elsif ($cols[6] eq '-') { $cols[6] = 1; } elsif ($cols[6] eq '.') { $cols[6] = 0; $logger->warn(\"converting feature with strand='.' to BSML feature with complement=false on line $linenum\"); } else { die(\"unknown value ($cols[6]) in strand column on line $linenum: expected '+', '-', or '.'.\"); } $record->{'_seqid'} = uri_unescape($cols[0]); $record->{'_source'} = uri_unescape($cols[1]); $record->{'_type'} = uri_unescape($cols[2]); # URI-unescaping should not be necessary for these columns: $record->{'_start'} = $cols[3]; $record->{'_end'} = $cols[4]; $record->{'_score'} = $cols[5]; $record->{'_strand'} = $cols[6]; $record->{'_phase'} = $cols[7]; # swap start/end if necessary if ($record->{'_start'} > $record->{'_end'}) { $logger->warn(\"start > end on line $linenum, $cols[8]\"); $logger->logdie(\"start > end but strand is not '-' on line $linenum, $cols[8]\") if ($record->{_strand} != 1); my $tmp = $record->{'_start'}; $record->{'_start'} = $record->{'_end'}; $record->{'_end'} = $tmp; } # apply $FEAT_TYPE_MAP to _type if (!defined($FEAT_TYPE_MAP->{$record->{'_type'}})) { $logger->error(\"unexpected feature type '$record->{_type}'\"); } else { $record->{'_type'} = $FEAT_TYPE_MAP->{$record->{'_type'}}; } my @attribs = split(\";\", $cols[8]); foreach my $attrib(@attribs) { my ($type, $val) = split(\"=\", $attrib); $type = uri_unescape($type); if (defined($unescaped_comma_atts->{$type})) { # treat $val as a single value, but other parts of the code assume that all attribute values are in lists $record->{$type}=[uri_unescape($val)]; } else { my @vals = map { uri_unescape($_) } split(\",\", $val); $record->{$type}=\\@vals; } } if (!defined($record->{'ID'})) { $logger->debug(\"no ID defined for record $line\"); } else { $record->{'ID'} = $record->{'ID'}->[0]; } my $parents = []; if (!defined($record->{'Parent'})) { if (defined($record->{'Derives_from'})) { push(@$parents, @{$record->{'Derives_from'}}); } $logger->debug(\"no Parent defined for record $line\"); } else { push(@$parents, @{$record->{'Parent'}}); } foreach my $parent(@$parents) { # store record's hash reference as a child of Parent if (!defined($NODES->{$parent}->{'children'})) { $NODES->{$parent}->{'children'}->{$record->{'_type'}} = []; } push (@{$NODES->{$parent}->{'children'}->{$record->{'_type'}}},$record); } return $record; } # recursively traverse a node and all its children # and process each record to create a feature hash # # $node - # $features - # sub process_node { my ($node, $features) = @_; # hash of keys to ignore when extracting a record hash from a node hash my $ignore_keys = { 'children' => 1, }; # build a record hash from values stored in the node hash my $record; foreach my $key(keys %{$node}) { if (!$ignore_keys->{$key}) { $record->{$key} = $node->{$key}; } } # process the record hash process_record($record, $features); # process the node's children foreach my $child_type(keys %{$node->{'children'}}) { foreach my $child_record(@{$node->{'children'}->{$child_type}}) { process_node($child_record, $features); } } return; } # process the records and store them in the features hash sub process_record { my ($record, $features) = @_; my $cds_type = $FEAT_TYPE_MAP->{'CDS'}; if ($record->{'_type'} eq $cds_type) { # CDS records can span lines and must be merged into one CDS feature if (!$record->{'ID'}) { if ($options->{'use_cds_parent_ids'}) { if ($record->{'Parent'}) { my $trans_id = &get_parent_id_by_type({'parent' => $record->{'Parent'}}, $features, $MRNA_TYPES); if (!defined($trans_id)) { print Dumper $record; die \"no mRNA parent id found for CDS feature: try running with --insert_missing_mrnas\"; } $record->{'ID'} = $trans_id . \"-CDS\"; } else { die \"CDS feature lacks ID and also has no Parent ID for --use_cds_parent_ids!\"; } } else { die \"CDS feature lacks ID -> bad form!\"; } } if ($features->{$cds_type}->{$record->{'ID'}}) { if ($features->{$cds_type}->{$record->{'ID'}}->{'startpos'} > $record->{'_start'}) { $features->{$cds_type}->{$record->{'ID'}}->{'startpos'} = $record->{'_start'}; } if ($features->{$cds_type}->{$record->{'ID'}}->{'endpos'} < $record->{'_end'}) { $features->{$cds_type}->{$record->{'ID'}}->{'endpos'} = $record->{'_end'}; } } else { $features->{$cds_type}->{$record->{'ID'}} = { 'complement' => $record->{'_strand'}, 'startpos' => $record->{'_start'}, 'endpos' => $record->{'_end'}, 'parent' => $record->{'Parent'}, 'type' => $record->{'_type'}, '_record' => $record, }; } } else { #handle all other feature types my $id; if (!$record->{'ID'}) { $id = getTempId(); } else { $id = $record->{'ID'}; } my $title = undef; if ($record->{'Name'}) { my $name = shift(@{$record->{'Name'}}); $title = $name if ($name !~ /^temp_id/); } $features->{$record->{'_type'}}->{$id} = { 'complement' => $record->{'_strand'}, 'startpos' => $record->{'_start'}, 'endpos' => $record->{'_end'}, 'title' => $title, 'parent' => $record->{'Parent'} || $record->{'Derives_from'}, 'type' => $record->{'_type'}, '_record' => $record, }; } } # find the parent of a feature, checking only those parents in a specified # set of parent types. returns undef if a unique parent of one of the specified # types cannot be found # # $feat - feature whose parent to find # $features - all features # $types - hashref whose keys are the types of parents to check # sub get_parent_id_by_type { my($feat, $features, $types) = @_; my $parent_list = $feat->{'parent'}; my $matches = []; foreach my $type (keys %$types) { my $type_list = $features->{$type}; foreach my $parent_id (@$parent_list) { if (defined($type_list->{$parent_id})) { push(@$matches, $parent_id); } } } my $nm = scalar(@$matches); if ($nm != 1) { $logger->warn(\"multiple parents found for feature $feat->{title}: \" . join(',', @$parent_list)) if ($nm > 1); return undef; } return $matches->[0]; } # convert a gene feature hash into BSML sub gene_feature_hash_to_bsml { my ($nodes, $features, $gff_seqs, $peptides, $dna_seqs, $seq_id) = @_; my $id_hash = {}; my %id_counts; $logger->debug(\"gene_feature_hash_to_bsml\"); foreach my $type(keys(%{$features})) { my $tc = scalar(keys(%{$features->{$type}})); $id_counts{$type} = $tc; $logger->debug(\"$type: $tc\"); } $idcreator->set_pool_size(%id_counts); my $seq; my $bsml_seq_id = $GFF2BSML_SEQID_MAP->{$seq_id}; # create a sequence stub for the seq_id if it doesn't exist yet if (!defined($bsml_seq_id)) { # determine length of sequence from feature in GFF, if present my $gff_seq = $nodes->{$seq_id}; my $gff_seqlen = undef; my $gff_seq_record = undef; if (defined($gff_seq)) { my $records = $gff_seq->{'records'}; my $nr = scalar(@$records); if ($nr != 1) { $logger->warn(\"$nr GFF record(s) found for sequence with id = $seq_id\"); } else { # interbase coords in effect here $gff_seq_record = $records->[0]; $gff_seqlen = $gff_seq_record->{'_end'} - $gff_seq_record->{'_start'}; } } my $dseq = undef; my $dseq_file = undef; if (defined($dna_seqs) || defined($gff_seqs)) { $dseq = $dna_seqs->{$seq_id}; $dseq_file = $options->{'dna_fasta'}; my $dseq_i = defined($gff_seqs) ? $gff_seqs->{$seq_id} : undef; # look in both --dna_fasta and the file containing the sequences from the GFF itself if (defined($dseq) && defined($dseq_i)) { $logger->logdie(\"ambiguous sequence id: '$seq_id' was found in both the input GFF and --dna_fasta\"); } # use the sequence from the GFF if --peptide_fasta does not define one if (!defined($dseq)) { $dseq = $dseq_i; $dseq_file = $gff_seq_file; } die \"couldn't find DNA sequence for $seq_id\" if (!defined($dseq)); $gff_seqlen = $dseq->{'seqlen'}; } if (!defined($gff_seqlen)) { if (defined($dna_seqs)) { $logger->warn(\"unable to determine length of Sequence $seq_id: not found in GFF or --dna_fasta file\"); } else { $logger->warn(\"unable to determine length of Sequence $seq_id: feature not found in GFF and --dna_fasta not specified\"); } } my $bsml_id = $idcreator->next_id('project' => $options->{'project'}, 'type' => $options->{'default_seq_class'}); $GFF2BSML_SEQID_MAP->{$seq_id} = $bsml_id; $seq = $doc->createAndAddSequence( $bsml_id, $seq_id, $gff_seqlen, 'dna', $options->{'default_seq_class'} ); my $genome_link = $doc->createAndAddLink($seq, 'genome', '#' . $genome_id); my $default_atts = $options->{'default_seq_attributes'}; if (defined($default_atts) && ($default_atts =~ /:/)) { foreach my $def_att (split(/,/, $default_atts)) { my($key, $val) = split(/:/, $def_att); if (defined($key) && defined($val)) { $doc->createAndAddBsmlAttribute($seq, $key, $val); } } } if (defined($dseq)) { if (!$options->{'dna_no_seqdata'}) { my $path = File::Spec->rel2abs($dseq_file); my $seq_data_import_elem = $doc->createAndAddSeqDataImport($seq, 'fasta', $path, undef, $dseq->{'bsml_identifier'}); } $doc->createAndAddBsmlAttribute($seq, 'defline', $dseq->{'defline'}); } # handle cross-references foreach my $att (keys %$seq_xref_mappings) { my $mappings = $seq_xref_mappings->{$att}; my $att_val; if (defined($gff_seq_record)) { $att_val = $gff_seq_record->{$att}; unshift(@$att_val, $gff_seq_record->{'title'}) if (($att eq 'Name') && (defined($gff_seq_record->{'title'})) && ($gff_seq_record->{'title'} =~ /\\S+/)); } elsif ($att eq 'ID') { $att_val = $seq_id; } next unless (defined($att_val)); my $att_vals = ((ref $att_val) eq 'ARRAY') ? $att_val : [$att_val]; foreach my $mapping (@$mappings) { foreach my $av (@$att_vals) { my $xref_elem = $doc->createAndAddCrossReference('parent' => $seq, 'id' => $doc->{'xrefctr'}++, 'database' => $mapping->{'db_name'}, 'identifier' => $av, 'identifier-type' => $mapping->{'id_type'}, ); } } } # TODO - need a way to specify which features get linked to an analysis # $seq->addBsmlLink('analysis', '#EVM', 'input_of'); } else { $seq = $doc->returnBsmlSequenceByIDR($bsml_seq_id); } # each of the feature types listed in $MRNA_TYPES can be used as a transcript-level feature my @transcript_ids = (); foreach my $ttype (keys %$MRNA_TYPES) { my @mrna_ids = map {{'id' => $_, 'type' => $ttype}} keys(%{$features->{$ttype}}); push(@transcript_ids, @mrna_ids); } # create at most one feature table per sequence my $feat_table = $seq2feat_table->{$seq}; if (!defined($feat_table)) { $feat_table = $seq2feat_table->{$seq} = $doc->createAndAddFeatureTable($seq); } # $feat_groups indexed by transcript id my $feat_groups = {}; foreach my $trans_id(@transcript_ids) { my $t_id = $idcreator->next_id( 'project' => $options->{'project'}, 'type' => $trans_id->{'type'}, ); if (defined($feat_groups->{$trans_id->{'id'}})) { die \"duplicate transcript id ($trans_id->{id}) encountered\"; } else { $id_hash->{$trans_id->{'id'}} = $t_id; $feat_groups->{$trans_id->{'id'}} = $doc->createAndAddFeatureGroup($seq, '', $t_id); # create reference for parent of transcript also my $trans = $features->{$trans_id->{'type'}}->{$trans_id->{'id'}}; foreach my $parent_id (@{$trans->{'parent'}}) { $feat_groups->{$parent_id} = $feat_groups->{$trans_id->{'id'}}; } } } my $get_singleton_feat = sub { my($type, $return_arrays) = @_; my @feats = values %{$features->{$type}}; my @ids = keys %{$features->{$type}}; my $nf = scalar(@feats); # not using wantarray because the return value is always an array/pair if ($return_arrays) { return (\\@ids, \\@feats); } if ($nf != 1) { print Dumper $features; die \"unable to find unique $type feature associated with $seq_id ($nf $type feature(s) found)\"; } return ($ids[0], $feats[0]); }; my $cds_type = $FEAT_TYPE_MAP->{'CDS'}; my $pep_type = $FEAT_TYPE_MAP->{'polypeptide'}; my $added_pep = 0; if ($options->{'insert_polypeptides'} && (!defined($id_counts{$pep_type}))) { my($gene_id, $gene) = &$get_singleton_feat('gene'); my($trans_ids, $transs) = &$get_singleton_feat('transcript', 1); # check whether this is a protein-coding gene my $is_protein_coding = 1; my $nc_mrna_type = undef; my $nc_mrna_count = 0; if (scalar(@$trans_ids) == 0) { foreach my $mrna_type (keys %$NONCODING_RNA_TYPES) { my($ids, $ts) = &$get_singleton_feat($mrna_type, 1); if (scalar(@$ids) == 1) { $nc_mrna_type = $mrna_type; ++$nc_mrna_count; } } if ($nc_mrna_count == 1) { $is_protein_coding = 0; } else { die \"gene $gene_id may be noncoding but has $nc_mrna_count noncoding mRNA feature(s)\"; } } elsif (scalar(@$trans_ids) > 1) { die \"gene $gene_id has multiple mRNA feature(s)\"; } my($trans_id, $trans) = ($trans_ids->[0], $transs->[0]); if ($is_protein_coding) { my($cds_ids, $cdss) = &$get_singleton_feat($cds_type, 1); if (scalar(@$cds_ids) > 1) { $logger->logdie(\"gene $gene_id has multiple CDS feature(s) after merging\"); } # not protein coding after all (or an error) elsif (scalar(@$cds_ids) == 0) { my $msg = \"gene $gene_id has no CDS feature and it does not appear to be an RNA gene\"; if ($options->{'allow_genes_with_no_cds'}) { $logger->warn($msg); $is_protein_coding = 0; } else { $logger->logdie($msg); } } if ($is_protein_coding) { my($cds_id, $cds) = ($cds_ids->[0], $cdss->[0]); my $pep_id = undef; my $id_type = $options->{'inserted_polypeptide_id_type'}; if ($id_type eq 'gene') { $pep_id = $gene_id . '-Protein'; } elsif ($id_type eq $cds_type) { $pep_id = $cds_id . '-Protein'; } else { # mrna/transcript $pep_id = $trans_id . '-Protein'; } $features->{$pep_type}->{$pep_id} = { 'parent' => [ $cds_id ], 'type' => $pep_type, 'startpos' => $cds->{'startpos'}, 'endpos' => $cds->{'endpos'}, 'complement' => $cds->{'complement'}, # TODO - propagation of cross-references and attributes to automatically-inserted features should be optional/explicit: '_record' => $cds->{'_record'}, }; $added_pep = 1; } } } # track BSML features for attribute/xref cloning my $id2bsmlfeat = {}; foreach my $type(keys(%{$features})) { foreach my $feat_id(keys(%{$features->{$type}})) { my $id; if (! defined($id_hash->{$feat_id})) { $id = $idcreator->next_id( 'project' => $options->{'project'}, 'type' => $type ); } else { $id = $id_hash->{$feat_id}; } my $feat_title = ($feat_id =~ /temp_id/) ? undef : $feat_id; my $feat = $doc->createAndAddFeature( $feat_table, $id, $feat_title, $type); $id2bsmlfeat->{$feat_id} = $feat; # link polypeptides to Sequences in --peptide_fasta or the input GFF file if (($type eq 'polypeptide') && (defined($peptides) || defined($gff_seqs))) { my $fseq = $peptides->{$feat_id}; my $fseq_file = $options->{'peptide_fasta'}; my $fseq_i = defined($gff_seqs) ? $gff_seqs->{$feat_id} : undef; # look in both --peptide_fasta and the file containing the sequences from the GFF itself if (defined($fseq) && defined($fseq_i)) { $logger->logdie(\"ambiguous sequence id: '$feat_id' was found in both the input GFF and --peptide_fasta\"); } # use the sequence from the GFF if --peptide_fasta does not define one if (!defined($fseq)) { $fseq = $fseq_i; $fseq_file = $gff_seq_file; } if (!defined($fseq)) { if ($added_pep) { $logger->warn(\"couldn't find peptide sequence for '$feat_id'\"); } else { die \"couldn't find peptide sequence for '$feat_id'\"; } } else { my $pep_seq = $doc->createAndAddSequence($id . \"_seq\", undef, $fseq->{'seqlen'}, 'aa', 'polypeptide'); my $seq_genome_link = $doc->createAndAddLink($pep_seq, 'genome', '#' . $genome_id); my $feat_seq_link = $doc->createAndAddLink($feat, 'sequence', '#'.$id.'_seq'); if (!$options->{'peptide_no_seqdata'}) { my $path = File::Spec->rel2abs($fseq_file); my $seq_data_import_elem = $doc->createAndAddSeqDataImport($pep_seq, 'fasta', $path, undef, $fseq->{'bsml_identifier'}); } $doc->createAndAddBsmlAttribute($pep_seq, 'defline', $fseq->{'defline'}); } } # TODO - need a way to specify which features get linked to an analysis # $feat->addBsmlLink('analysis', '#EVM', 'computed_by'); $feat->addBsmlIntervalLoc( $features->{$type}->{$feat_id}->{'startpos'}, $features->{$type}->{$feat_id}->{'endpos'}, $features->{$type}->{$feat_id}->{'complement'}, ); # add attributes foreach my $att (keys %$feat_att_mappings) { my $feature = $features->{$type}->{$feat_id}; my $mappings = $feat_att_mappings->{$att}; my $att_val = $feature->{'_record'}->{$att}; unshift(@$att_val, $feature->{'title'}) if (($att eq 'Name') && (defined($feature->{'title'})) && ($feature->{'title'} =~ /\\S+/)); if (defined($att_val)) { my $att_vals = ((ref $att_val) eq 'ARRAY') ? $att_val : [$att_val]; foreach my $mapping (@$mappings) { foreach my $av (@$att_vals) { $doc->createAndAddBsmlAttribute($feat, $mapping->{'bsml_att'}, $av); } } } } # add cross-references foreach my $att (keys %$feat_xref_mappings) { my $feature = $features->{$type}->{$feat_id}; my $mappings = $feat_xref_mappings->{$att}; my $att_val = $feature->{'_record'}->{$att}; unshift(@$att_val, $feature->{'title'}) if (($att eq 'Name') && (defined($feature->{'title'})) && ($feature->{'title'} =~ /\\S+/)); if (defined($att_val)) { my $att_vals = ((ref $att_val) eq 'ARRAY') ? $att_val : [$att_val]; foreach my $mapping (@$mappings) { foreach my $av (@$att_vals) { my $xref_elem = $doc->createAndAddCrossReference('parent' => $feat, 'id' => $doc->{'xrefctr'}++, 'database' => $mapping->{'db_name'}, 'identifier' => $av, 'identifier-type' => $mapping->{'id_type'}, ); } } } } # determine which feat_group this feature belongs with my $feat_group = undef; if (defined($feat_groups->{$feat_id})) { $feat_group = $feat_groups->{$feat_id}; } else { # polypeptides _should_ be linked through CDS my $cds_id = undef; my $cds_type = undef; if ($type eq $pep_type) { $cds_type = $FEAT_TYPE_MAP->{'CDS'}; $cds_id = &get_parent_id_by_type($features->{$type}->{$feat_id}, $features, { $cds_type => 1 }); } my $trans_id = undef; if (defined($cds_id)) { $trans_id = &get_parent_id_by_type($features->{$cds_type}->{$cds_id}, $features, $MRNA_TYPES); } else { $trans_id = &get_parent_id_by_type($features->{$type}->{$feat_id}, $features, $MRNA_TYPES); } if (!defined($trans_id)) { print Dumper $features; die \"no mRNA parent id found for $type feature $feat_id\"; } $feat_group = $feat_groups->{$trans_id}; if (!defined($feat_group)) { print Dumper $features; die \"no feat_group found for transcript=$trans_id\"; } } $feat_group->addBsmlFeatureGroupMember( $id, $type ); } } # clone BSML attributes specified by --clone_feat_attribute_mappings, --clone_feat_xref_mappings my $all_clone_mappings = {}; foreach my $key (keys %$clone_feat_att_mappings, keys %$clone_feat_xref_mappings) { next if defined($all_clone_mappings->{$key}); my $fam = $clone_feat_att_mappings->{$key}; my $fxm = $clone_feat_xref_mappings->{$key}; map { $_->{'mapping_type'} = 'attribute'; } @$fam; map { $_->{'mapping_type'} = 'xref'; } @$fxm; $all_clone_mappings->{$key} = [@$fam, @$fxm]; } foreach my $st (keys %$all_clone_mappings) { my $mappings = $all_clone_mappings->{$st}; # get features of type $st my @src_feat_ids = keys %{$features->{$st}}; $logger->debug(\"got src feats of type $st: @src_feat_ids\"); foreach my $cfm (@$mappings) { my($att, $xref_db, $tt, $mt) = map {$cfm->{$_}} ('bsml_att', 'db_name', 'target_type', 'mapping_type'); # get features of type $tt my @tgt_feat_ids = keys %{$features->{$tt}}; $logger->debug(\"got tgt feats of type $tt: @tgt_feat_ids\"); # clone foreach my $sfid (@src_feat_ids) { foreach my $tfid (@tgt_feat_ids) { my $sf = $id2bsmlfeat->{$sfid} || $logger->logdie(\"no feature found for id=$sfid\"); my $tf = $id2bsmlfeat->{$tfid} || $logger->logdie(\"no feature found for id=$tfid\"); # clone attribute if ($mt eq 'attribute') { $logger->debug(\"cloning $att from $st to $tt\"); my $tvh = {}; # track target atts to avoid duplication my ($sval, $tval) = map { $_->returnBsmlAttr($att) || []; } ($sf, $tf); map {$tvh->{$_} = 1;} @$tval; foreach my $sv (@$sval) { if (!defined($tvh->{$sv})) { $doc->createAndAddBsmlAttribute($tf, $att, $sv); $logger->debug(\"cloning $att value of $sv from $sfid ($st) to $tfid ($tt)\"); } } } # clone cross-reference elsif ($mt eq 'xref') { $logger->debug(\"cloning $xref_db xref from $st to $tt\"); my $trefh = {}; # track target xrefs to avoid duplication my $trefs = $tf->returnBsmlCrossReferenceListR(); foreach my $tr (@$trefs) { my($tdb,$tid_type,$tid) = map { $tr->returnattr($_) || \"\"; } ('database', 'identifier-type', 'identifier'); $trefh->{join(\"\\0\",$tdb,$tid_type,$tid)} = 1; } # TODO - make this more efficient my $srefs = $sf->returnBsmlCrossReferenceListR(); foreach my $sr (@$srefs) { my($sdb,$sid_type,$sid) = map { $sr->returnattr($_); } ('database', 'identifier-type', 'identifier'); next unless ($sdb eq $xref_db); # add it if the target doesn't have it already if (!defined($trefh->{join(\"\\0\", $sdb,$sid_type,$sid)})) { my $cind = $tf->addBsmlCrossReference(); my $cr = $tf->returnBsmlCrossReferenceR($cind); $cr->addattr('database', $sdb); $cr->addattr('identifier-type', $sid_type); $cr->addattr('identifier', $sid); $logger->debug(\"adding cross ref from target feature $tfid to db=$sdb idtype=$sid_type, id=$sid\"); } else { $logger->debug(\"target feature $tfid already has cross ref with db=$sdb idtype=$sid_type, id=$sid from source feature $sfid\"); } } } else { $logger->logdie(\"attempt to clone unknown BSML component '$mt'\"); } } } } } # TODO - clone BSML cross-references specified by --clone_feat_xref_mappings } # traverses an array of node references # and returns all nodes of the specified type sub fetch_node_type { my ($type, $nodes_ref, $found_nodes) = @_; foreach my $node (@{$nodes_ref}) { if ($node->{'_type'} eq $type) { push (@{$found_nodes}, $node); } foreach my $key (keys %{$node->{'children'}}) { fetch_node_type($type, $node->{'children'}->{$key}, $found_nodes); } } return; } # read deflines and sequence lengths from a multi-FASTA file # # $file - a multi-FASTA sequence file # $id_regex - regular expression to extract a sequence id from each defline of $file # $id_fn - function to apply to the id parsed by $id_regex before using it as a key in the result hash # # returns a hashref mapping sequence id to { 'seqlen' => sequence length, 'defline' => sequence defline } # sub read_sequence_lengths { my($file, $id_regex, $id_fn) = @_; my $result = {}; my $fh = FileHandle->new(); my $bsml_idents = {}; my $process_seq = sub { my($defline, $seq, $lnum) = @_; my($id) = ($defline =~ /$id_regex/); die \"unable to parse id from line $lnum of $file using regex '$id_regex': $defline\" if (!defined($id)); $seq =~ s/\\s+//g; $id = &$id_fn($id) if (defined($id_fn)); die \"sequence id '$id' is not unique in $file\" if (defined($result->{$id})); # this must mirror the hard-coded regex in BSML::BsmlReader::parse_multi_fasta: my($bsml_ident) = ($defline =~ /^>([^\\s]+)/); die \"unable to parse BSML identifier from the following defline in $file: $defline\" if (!defined($bsml_ident)); die \"BSML identifier '$bsml_ident' is not unique in $file\" if (defined($bsml_idents->{$bsml_ident})); $bsml_idents->{$bsml_ident} = 1; $defline =~ s/^>//; $result->{$id} = { 'id' => $id, 'seqlen' => length($seq), 'defline' => $defline, 'bsml_identifier' => $bsml_ident }; }; my $defline = undef; my $defline_lnum = undef; my $seq = undef; my $lnum = 0; my $openCmd = $file; if ($file =~ /\\.gz$/) { $openCmd = \"zcat $file |\"; $logger->warn(\"FASTA file $file is compressed, which may cause bsml2chado to fail to load sequences from it.\"); } $fh->open($openCmd) || die \"unable to open $openCmd for file $file\"; while (my $line = <$fh>) { chomp($line); ++$lnum; if ($line =~ /^>/) { &$process_seq($defline, $seq, $defline_lnum) if (defined($defline)); $defline = $line; $defline_lnum = $lnum; $seq = \"\"; } else { $seq .= $line; } } &$process_seq($defline, $seq, $defline_lnum) if (defined($defline)); $fh->close(); return $result; } sub getTempId { return \"temp_id_\".$GLOBAL_ID_COUNTER++; }"
    },
    {
      "tool": "glimmer3",
      "converter_script": "glimmer32bsml.pl",
      "name": "glimmer32bsml.pl - Creates a bsml document from glimmer3 raw\n    output",
      "synopsis": "USAGE: glimmer32bsml.pl\n            --input_list=/path/to/some/glimmer3.raw.list\n            --input_file=/path/to/some/glimmer3.raw\n            --output=/path/to/transterm.bsml\n            --id_repository=/path/to/id_repository\n            --fasta_input=/path/to/glimmer3/input.fsa\n          [ --log=/path/to/file.log\n            --debug=4\n            --help\n          ]",
      "description": "This script is used to convert the output from a glimmer3 search into BSML.",
      "options": {
        "input_list": "Input list of glimmer3 raw output files (.predict)",
        "input_file": "Input glimmer3 raw file (.predict)",
        "output": "The output bsml file.",
        "id_repository": "Id repository for use by Workflow::IdGenerator.pm",
        "fasta_input": "The input file that was used as input for the glimmer3 run",
        "log": "Logfile.",
        "help": "Print this message"
      },
      "contact": "Kevin Galens kgalens@tigr.org =cut use strict; use warnings; use Getopt::Long qw(:config no_ignore_case no_auto_abbrev pass_through); use Pod::Usage; use Chado::Gene; use BSML::GenePredictionBsml; use Ergatis::IdGenerator; use Ergatis::Logger; use XML::Simple; ####### GLOBALS AND CONSTANTS ########### my @inputFiles; #Holds input files my $project; #The project (ex aa1) my $output; #Output file my $idMaker; #The Workflow::IdGenerator my $bsml; #BSML::BsmlBuilder object object. my $data; #Holds parsed glimmer3 information my $inputFsa; #The fasta file input to glimmer3 my $debug; #The debug variable my $length; ######################################## my %options = (); my $results = GetOptions (\\%options, 'input_list|i=s', 'input_file|f=s', 'output|o=s', 'project|p=s', 'id_repository|r=s', 'fasta_input|a=s', 'log|l=s', 'debug=s', 'help|h') || &_pod; #Setup the logger my $logfile = $options{'log'} || Ergatis::Logger::get_default_logfilename(); my $logger = new Ergatis::Logger('LOG_FILE'=>$logfile, 'LOG_LEVEL'=>$options{'debug'}); $logger = $logger->get_logger(); # Check the options. &check_parameters(\\%options); foreach my $file (@inputFiles) { $data = &parseGlimmer3Data($file); $bsml = &generateBsml($data); } $bsml->writeBsml($output); ## Double-check to ensure that our BSML is well-formed before moving on. ## Avoids a situation where we move on from this step and have retry attempts ## occuring on the wrong step of the component. XMLin($output); exit(0); ######################## SUB ROUTINES ####################################### sub parseGlimmer3Data { my ($file) = @_; my $genes; my $foundId = 0; open(IN, \"<$file\") or &_die(\"Unable to open $file\"); while(<IN>) { if(/^>(.*?)\\s/) { $foundId = $1; if( $project eq 'parse' ) { $project = $1 if($foundId =~ /^(\\w+?)\\./); $logger->logdie(\"Could not parse project name out of id $foundId.\") unless($project); } } elsif($foundId) { my @cols = split(/\\s+/,$_); if($cols[3] > 0 && $cols[1] > $cols[2]) { die(\"Couldn't find this id $foundId in length hash\") unless(defined($length->{$foundId})); $cols[1] = 0 - (($length->{$foundId} - $cols[1]) - 1); } elsif( $cols[3] < 0 && $cols[1] > $cols[2]) { ($cols[1], $cols[2]) = ($cols[2], $cols[1]); } elsif( $cols[3] < 0 && $cols[1] < $cols[2]) { die(\"Couldn't find this id $foundId in length hash\") unless(defined($length->{$foundId})); $cols[2] = 0 - (($length->{$foundId} - $cols[1]) - 1); ($cols[1], $cols[2]) = ($cols[2], $cols[1]); } #Create some genes and push them ontot he $genes array my $tmp = new Chado::Gene( $idMaker->next_id( 'type' => 'gene', 'project' => $project), $cols[1]-1, $cols[2], ($cols[3] > 0) ? 0 : 1, $foundId); foreach my $type(qw(exon CDS transcript polypeptide)) { my $typeid =$idMaker->next_id( 'type' => $type, 'project' => $project); $tmp->addFeature($typeid, $cols[1]-1, $cols[2], ($cols[3] > 0) ? 0 : 1, $type); } my $count = $tmp->addToGroup($tmp->getId, { 'all' => 1 }); &_die(\"Nothing was added to group\") unless($count); push(@{$genes}, $tmp); } else { &_die(\"Didn't find the id\"); } } close(IN); return $genes; } sub generateBsml { my $data = shift; #Create the document my $doc = new BSML::GenePredictionBsml( 'glimmer3', $inputFsa ); foreach my $gene(@{$data}) { $doc->addGene($gene); } my $seqId; open(IN, \"< $inputFsa\") or &_die(\"Unable to open $inputFsa\"); while(<IN>) { #assume it's a single fasta file if(/^>([^\\s+]+)/) { $seqId = $1; last; } } close(IN); my $addedTo = $doc->setFasta($seqId, $inputFsa); &_die(\"$seqId was not a sequence associated with the gene\") unless($addedTo); return $doc; } sub check_parameters { my $options = shift; my $error = \"\"; &_pod if($options{'help'}); if($options{'input_list'}) { $error .= \"Option input_list ($options{'input_list'}) does not exist\\n\" unless(-e $options{'input_list'}); open(IN, \"< $options{'input_list'}\") || &_die(\"Unable to open $options{'input_list'} ($!)\"); @inputFiles = <IN>; close(IN); } if($options{'input_file'}) { $error .= \"Option input_file ($options{'input_file'}) does not exist\\n\" unless(-e $options{'input_file'}); push(@inputFiles, $options{'input_file'}); } unless($options{'input_list'} || $options{'input_file'}) { $error .= \"Either option input_list or input_file is required\\n\"; } unless($options{'output'}) { $error .= \"Option output is required\\n\"; } else { $output = $options{'output'}; } unless($options{'id_repository'}) { $error .= \"Option id_repository is required. Please see Ergatis::IdGenerator \". \"for details.\\n\"; } else { $idMaker = new Ergatis::IdGenerator( 'id_repository' => $options{'id_repository'} ); $idMaker->set_pool_size( 'exon' => 20, 'transcript' => 20, 'gene' => 20, 'polypeptide' => 20, 'CDS' => 20 ); } unless($options{'fasta_input'}) { $error .= \"Option fasta_input is required\\n\"; } else { $error .= \"$options{'fasta_input'} (fasta_input) does not exist\\n\" unless(-e $options{'fasta_input'}); $inputFsa = $options{'fasta_input'}; #Find the length of the sequence open(IN, \"<$options{'fasta_input'}\") or $logger->logdie(\"Can't open $options->{'fasta_input'}\"); my $seq = \"\"; my $curId; while(<IN>) { chomp; if(/^>(\\S+)/) { if(defined($curId)) { $length->{$curId} = length($seq); $seq = \"\"; } $curId = $1; } else { $seq.= $_; } } $length->{$curId} = length($seq); close(IN); } if( $options{'project'} ) { $project = $options->{'project'}; } else { $project = \"parse\"; } if($options{'debug'}) { $debug = $options{'debug'}; } unless($error eq \"\") { &_die($error); } } sub _pod { pod2usage( {-exitval => 0, -verbose => 2, -output => \\*STDERR} ); } sub _die { my $msg = shift; $logger->logdie($msg); }"
    },
    {
      "tool": "glimmerHMM",
      "converter_script": "glimmerHMM2bsml.pl",
      "name": "glimmerHMM2bsml.pl - convert glimmerHMM output to BSML",
      "synopsis": "USAGE: glimmerHMM2bsml.pl \n        --input=/path/to/glimmerHMM.output.file \n        --output=/path/to/output.bsml\n       [ --project=aa1 ]",
      "description": "This script is used to convert the output from a glimmerHMM search into BSML.",
      "options": {
        "input": "Input file file from a glimmerHMM scan.",
        "debug": "Debug level.  Use a large number to turn on verbose debugging.",
        "fasta_file": "If passed, will create a Seq-data-import element referencing this\n    path.",
        "project": "Project ID.  Used in creating feature ids.  Defaults to 'unknown' if\n    not passed.",
        "log": "Log file",
        "output": "Output BSML file (will be created, must not exist)",
        "help": "This help message"
      },
      "contact": "Joshua Orvis jorvis@tigr.org =cut use strict; use Getopt::Long qw(:config no_ignore_case no_auto_abbrev); use Pod::Usage; BEGIN { use Ergatis::Logger; use BSML::BsmlRepository; use Papyrus::TempIdCreator; use BSML::BsmlBuilder; use BSML::BsmlParserTwig; } my %options = (); my $results = GetOptions (\\%options, 'input|i=s', 'output|o=s', 'fasta_file|f=s', 'project|p=s', 'log|l=s', 'command_id=s', ## passed by workflow 'logconf=s', ## passed by workflow (not used) 'debug=s', 'help|h') || pod2usage(); my $logfile = $options{'log'} || Ergatis::Logger::get_default_logfilename(); my $logger = new Ergatis::Logger('LOG_FILE'=>$logfile, 'LOG_LEVEL'=>$options{'debug'}); $logger = $logger->get_logger(); # display documentation if( $options{'help'} ){ pod2usage( {-exitval=>0, -verbose => 2, -output => \\*STDOUT} ); } ## make sure all passed options are peachy &check_parameters(\\%options); ## we want to creating ids unique to this document, which will be replaced later. they must ## contain the prefix that will be used to look up a real id, such as ath1.exon.15 my $next_id = 1; ## we want a new doc my $doc = new BSML::BsmlBuilder(); ## we're going to generate ids my $idcreator = new Papyrus::TempIdCreator(); ## open the input file for parsing open (my $ifh, $options{'input'}) || $logger->logdie(\"can't open input file for reading\"); ## go forward until we get to the sequence name (id) my $seq_id; while (<$ifh>) { if ( /^Sequence name: (.+)\\s*.*$/ ) { $seq_id = $1; last; } } ## make sure we found an id unless (defined $seq_id) { $logger->logdie(\"unable to pull seq id from $options{'input'}\"); } ## create this sequence, an analysis link, and a feature table my $seq = $doc->createAndAddSequence($seq_id, undef, '', 'dna', 'assembly'); $seq->addBsmlLink('analysis', '#glimmerHMM_analysis'); my $ft = $doc->createAndAddFeatureTable($seq); ## also add a link to the fasta file (Seq-data-import) if requested if ($options{'fasta_file'}) { $doc->createAndAddSeqDataImport( $seq, 'fasta', $options{'fasta_file'}, '', $seq_id); } ## now look for datalines (exon defs) my (@cols, $fg, $gene); my $last_gene_num = 0; my ($gene_start, $gene_stop, $gene_dir); my $at_least_one_found = 0; while (<$ifh>) { ## matches lines like \"1 1 - Initial 2522 2729 208\" if (/^\\s*\\d+\\s+\\d+\\s+.\\s+.+\\s+\\d+\\s+\\d+\\s+\\d+$/) { @cols = split(); ## if this gene number is different than the last one we need to # add it and start a new feature group if ($cols[0] ne $last_gene_num) { ## if last_gene_num > 0 we must not be doing the first one. add ## the interval loc of the last gene before we move on. if ($last_gene_num > 0) { if ($gene_dir eq '+') { &add_interval_loc($gene, $gene_start, $gene_stop); } elsif ($gene_dir eq '-') { &add_interval_loc($gene, $gene_stop, $gene_start); } else { $logger->logdie(\"unrecognized gene direction ($gene_dir)\"); } } $gene = $doc->createAndAddFeature($ft, $idcreator->new_id( db => $options{project}, so_type => 'gene', prefix => $options{command_id} ), '', 'gene' ); $fg = $doc->createAndAddFeatureGroup( $seq, '', $gene->returnattr('id') ); $fg->addBsmlFeatureGroupMember( $gene->returnattr('id'), $gene->returnattr('class') ); $gene->addBsmlLink('analysis', '#glimmerHMM_analysis'); $last_gene_num = $cols[0]; ## set the new gene start and direction $gene_start = $cols[4] - 1; $gene_dir = $cols[2]; } ## set the gene stop (gets overridden each time) $gene_stop = $cols[5]; ## add this exon feature my $exon = $doc->createAndAddFeature($ft, $idcreator->new_id( db => $options{project}, so_type => 'exon', prefix => $options{command_id} ), '', 'exon' ); $exon->addBsmlLink('analysis', '#glimmerHMM_analysis'); $fg->addBsmlFeatureGroupMember( $exon->returnattr('id'), $exon->returnattr('class') ); ## make a CDS feature to match the exon, since glimmerHMM doesn't call them. my $cds = $doc->createAndAddFeature($ft, $idcreator->new_id( db => $options{project}, so_type => 'CDS', prefix => $options{command_id} ), '', 'CDS' ); $cds->addBsmlLink('analysis', '#glimmerHMM_analysis'); $fg->addBsmlFeatureGroupMember( $cds->returnattr('id'), $cds->returnattr('class') ); if ($cols[2] eq '+') { &add_interval_loc($exon, $cols[4] - 1, $cols[5]); &add_interval_loc($cds, $cols[4] - 1, $cols[5]); } elsif ($cols[2] eq '-') { &add_interval_loc($exon, $cols[5], $cols[4] - 1); &add_interval_loc($cds, $cols[5], $cols[4] - 1); } else { $logger->logdie(\"unknown value ($cols[2]) in column 3 of input file\"); } $at_least_one_found = 1; } } if ($at_least_one_found) { ## add the last gene interval loc if ($gene_dir eq '+') { &add_interval_loc($gene, $gene_start, $gene_stop); } elsif ($gene_dir eq '-') { &add_interval_loc($gene, $gene_stop, $gene_start); } else { $logger->logdie(\"unrecognized gene direction ($gene_dir)\"); } } ## add the analysis element $doc->createAndAddAnalysis( id => 'glimmerHMM_analysis', sourcename => $options{'output'}, ); ## now write the doc $doc->write($options{'output'}); exit; sub add_interval_loc { my ($feat, $n, $m) = @_; ## was it found on the forward or reverse strand? if ($n <= $m) { $feat->addBsmlIntervalLoc($n, $m, 0); } else { $feat->addBsmlIntervalLoc($m, $n, 1); } } sub check_parameters { ## make sure input file exists if (! -e $options{'input'}) { $logger->logdie(\"input file $options{'input'} does not exist\") } ## make sure output file doesn't exist yet if (-e $options{'output'}) { $logger->logdie(\"can't create $options{'output'} because it already exists\") } $options{'fasta_file'} = '' unless ($options{'fasta_file'}); $options{'project'} = 'unknown' unless ($options{'project'}); $options{'command_id'} = '' unless ($options{'command_id'}); return 1; }"
    },
    {
      "tool": "hmmls",
      "converter_script": "hmmls2bsml.pl",
      "name": "hmmls2bsml.pl - convert hmmpfam raw output to BSML",
      "synopsis": "USAGE: hmmls2bsml.pl \n        --input=/path/to/somefile.hmmls.raw \n        --output=/path/to/somefile.hmmls.bsml\n        --model_name=boxA_repeat\n      [ --search_method=hmmls\n        --query_mol_type=aa\n        --query_mol_class=polypeptide\n        --model_mol_type=aa\n        --model_mol_class=polypeptide\n        --fasta_input=/path/to/hmmls/input.fsa\n        --gzip_output=1\n        --log=/path/to/some.log\n        --debug=4 \n        --help\n      ]",
      "description": "This script is used to convert the raw alignment output from an hmmls search into BSML.",
      "options": {
        "input": "Input raw alignment file from an hmmls search.",
        "output": "Output BSML file",
        "model_name": "Uniquename of the model searched.",
        "query_mol_type": "Query molecule type (like 'aa' or 'dna').",
        "query_mol_class": "Query molecule type (like 'polypeptide' or 'DNA').",
        "model_mol_type": "Model molecule type (like 'aa' or 'dna').",
        "model_mol_class": "Query molecule type (like 'polypeptide' or 'DNA').",
        "fasta_input": "Optional.  If included, will make a seq data import element and include the \n    defline with the sequences.",
        "gzip_output": "Optional.  If given a non-zero value, will compress the output and give the output\n    file a .gz extension.  If the file already contains one, it won't add another.",
        "debug": "Debug level.  Use a large number to turn on verbose debugging.",
        "log": "Log file",
        "help": "This help message"
      },
      "contact": "Joshua Orvis jorvis@tigr.org =cut use strict; use Getopt::Long qw(:config no_ignore_case no_auto_abbrev); use Pod::Usage; use Ergatis::Logger; use BSML::BsmlRepository; use BSML::BsmlBuilder; use BSML::BsmlParserTwig; my $fasta_input; my %options = (); my $results = GetOptions (\\%options, 'input|i=s', 'output|o=s', 'model_name|m=s', 'query_mol_type|qt=s', 'query_mol_class|qc=s', 'model_mol_type|mt=s', 'model_mol_class|mc=s', 'fasta_input|f=s', 'gzip_output|g=s', 'log|l=s', 'debug=s', 'help|h') || pod2usage(); my $logfile = $options{'log'} || Ergatis::Logger::get_default_logfilename(); my $logger = new Ergatis::Logger('LOG_FILE'=>$logfile, 'LOG_LEVEL'=>$options{'debug'}); $logger = $logger->get_logger(); # display documentation if( $options{'help'} ){ pod2usage( {-exitval=>0, -verbose => 2, -output => \\*STDOUT} ); } ## make sure all passed options are peachy &check_parameters(\\%options); ## we want a new doc my $doc = new BSML::BsmlBuilder(); ## open the input file for parsing open (my $ifh, $options{'input'}) || $logger->logdie(\"can't open input file for reading\"); ## go through the top of the file and get a few things. my ($hmm_file, $sequence_file); while (<$ifh>) { if (/HMM file\\:\\s+(\\S+)/) { $hmm_file = $1; } elsif (/Sequence database\\:\\s+(\\S+)/) { $sequence_file = $1; last; } } ## fetch deflines my $deflines = get_deflines($sequence_file); my $model = $options{'model_name'}; ## check that these were successfully parsed unless ($hmm_file) { $logger->logdie(\"HMM file definition not found in input file.\") } unless ($sequence_file) { $logger->logdie(\"Sequence file definition not found in input file.\") } my $seq = $doc->createAndAddSequence($model, $model, undef, $options{'model_mol_type'}, $options{'model_mol_class'}); $seq->addBsmlLink('analysis', \"\\#$options{search_method}_analysis\", 'input_of'); my %alignments; my $qry_id; while (<$ifh>) { # Expected format: # 43.78 (bits) f:157245 t:157289 Target: sp187300.assembly.6002.0 if (/(\\S+)\\s+\\(bits\\)\\s+f:(\\S+)\\s+t:(\\S+)\\s+Target:\\s+(\\S+)/) { my($score, $qry_start, $qry_stop, $qry_id) = ($1, $2, $3, $4); print STDERR \"$model $score $qry_start $qry_stop $qry_id\\n\"; ## the query sequence only counts up the first whitespace if ($qry_id =~ /(.+?)\\s+/) { $qry_id = $1; } unless ($qry_id) { $logger->logdie(\"Query sequence definition not found in input file.\") } ## add the query sequence file to the doc ## the use of 'aa' is not guaranteed here, but we're not using it anyway in loading my $identifier = $qry_id; #$doc->createAndAddSeqDataImport($seq, 'fasta', $fasta_input, '', $1) if($options{'fasta_input'}); #$doc->createAndAddBsmlAttribute($seq, 'defline', $deflines->{$qry_id}) if($deflines->{$qry_id}); # If we have a seq-pair run we'll make sure we have an alignment to add the run to. If not we'll create it here. if(!$alignments{$qry_id}) { $doc->createAndAddSequence($qry_id, $qry_id, undef, $options{'query_mol_type'}, $options{'model_mol_class'}); $alignments{$qry_id} = $doc->createAndAddSequencePairAlignment( refseq => $qry_id, refstart => 0, #refend => $cols[2] - 1, #reflength => $cols[2], compseq => $model, class => 'match' ); ## add a link element inside this seq-pair-alignment $alignments{$qry_id}->addBsmlLink('analysis', \"\\#$options{search_method}_analysis\", 'computed_by'); } # NOTE: The position of the comppos and comprunlength is a HACK. The position of the hit in the model is not # reported for hmmls. my $run = $doc->createAndAddSequencePairRun( alignment_pair => $alignments{$qry_id}, runscore => $score, runlength => abs($qry_stop - $qry_start) + 1, comprunlength => abs($qry_stop - $qry_start) + 1, refpos => min($qry_start, $qry_stop) - 1, refcomplement => ($qry_stop > $qry_start) ? 0 : 1, comppos => 0, compcomplement => ($qry_stop > $qry_start) ? 0 : 1, ); ## add other attributes of the run $doc->createAndAddBsmlAttribute( $run, 'class', 'match_part'); $doc->createAndAddBsmlAttributes( $run, ); } } ## add the analysis element $doc->createAndAddAnalysis( id => \"$options{search_method}_analysis\", sourcename => $options{'output'}, program => 'hmmls', algorithm => 'hmmls', ); ## now write the doc $doc->write($options{'output'}, '', $options{gzip_output}); exit; sub check_parameters { ## make sure input file exists if (! -e $options{'input'}) { $logger->logdie(\"input file $options{'input'} does not exist\") } ## make user an output file was passed if (! $options{'output'}) { $logger->logdie(\"output option required!\") } ## handle defaults $options{'search_method'} = 'hmmls' unless ( $options{'search_method'} ); if($options{'fasta_input'}) { $fasta_input = $options{'fasta_input'}; } return 1; } sub min { my ($num1, $num2) = @_; if ($num1 < $num2) { return $num1; } else { return $num2; } } ## retrieve deflines from a fasta file sub get_deflines { my ($fasta_file) = @_; my $deflines = {}; my $ifh; if (! -e $fasta_file) { if (-e $fasta_file.\".gz\") { $fasta_file .= \".gz\"; } elsif (-e $fasta_file.\".gzip\") { $fasta_file .= \".gzip\"; } } if ($fasta_file =~ /\\.(gz|gzip)$/) { open ($ifh, \"<:gzip\", $fasta_file) || $logger->logdie(\"can't open input file '$fasta_file': $!\"); } else { open ($ifh, $fasta_file) || $logger->logdie(\"Failed opening '$fasta_file' for reading: $!\"); } while (<$ifh>) { unless (/^>/) { next; } chomp; if (/^>((\\S+).*)$/) { $deflines->{$2} = $1; } } close $ifh; if (scalar(keys(%{$deflines})) < 1) { $logger->warn(\"defline lookup failed for '$fasta_file'\"); } return $deflines; }"
    },
    {
      "tool": "hmmpfam",
      "converter_script": "hmmpfam2bsml.pl",
      "name": "hmmpfam2bsml.pl - convert hmmpfam raw output to BSML",
      "synopsis": "USAGE: hmmpfam2bsml.pl \n        --input=/path/to/somefile.hmmpfam.raw \n        --output=/path/to/somefile.hmmpfam.bsml\n      [ --search_method=hmmpfam\n        --query_mol_type=aa\n        --query_mol_class=polypeptide\n        --model_mol_type=aa\n        --model_mol_class=polypeptide\n        --fasta_input=/path/to/hmmpfam/input.fsa\n        --gzip_output=1\n        --log=/path/to/some.log\n        --debug=4 \n        --help\n      ]",
      "description": "This script is used to convert the raw alignment output from an hmmpfam search into BSML.",
      "options": {
        "input": "Input raw alignment file from an hmmpfam search.",
        "output": "Output BSML file",
        "search_method": "Optional. Search method used with hmmpfam.  default is 'hmmpfam' but others\n    include 'hmmsmart', 'hmmpir', etc.",
        "query_mol_type": "Query molecule type (like 'aa' or 'dna').",
        "query_mol_class": "Query molecule type (like 'polypeptide' or 'DNA').",
        "model_mol_type": "Model molecule type (like 'aa' or 'dna').",
        "model_mol_class": "Query molecule type (like 'polypeptide' or 'DNA').",
        "fasta_input": "Optional.  If included, will make a seq data import element and include the \n    defline with the sequences.",
        "gzip_output": "Optional.  If given a non-zero value, will compress the output and give the output\n    file a .gz extension.  If the file already contains one, it won't add another.",
        "debug": "Debug level.  Use a large number to turn on verbose debugging.",
        "log": "Log file",
        "help": "This help message"
      },
      "contact": "Joshua Orvis jorvis@tigr.org =cut use strict; use Getopt::Long qw(:config no_ignore_case no_auto_abbrev); use Pod::Usage; use Ergatis::Logger; use BSML::BsmlRepository; use BSML::BsmlBuilder; use BSML::BsmlParserTwig; my $fasta_input; my %options = (); my $results = GetOptions (\\%options, 'input|i=s', 'output|o=s', 'search_method|m=s', 'query_mol_type|qt=s', 'query_mol_class|qc=s', 'model_mol_type|mt=s', 'model_mol_class|mc=s', 'fasta_input|f=s', 'gzip_output|g=s', 'log|l=s', 'debug=s', 'help|h') || pod2usage(); my $logfile = $options{'log'} || Ergatis::Logger::get_default_logfilename(); my $logger = new Ergatis::Logger('LOG_FILE'=>$logfile, 'LOG_LEVEL'=>$options{'debug'}); $logger = $logger->get_logger(); # display documentation if( $options{'help'} ){ pod2usage( {-exitval=>0, -verbose => 2, -output => \\*STDOUT} ); } ## make sure all passed options are peachy &check_parameters(\\%options); ## we want a new doc my $doc = new BSML::BsmlBuilder(); ## open the input file for parsing open (my $ifh, $options{'input'}) || $logger->logdie(\"can't open input file for reading\"); ## go through the top of the file and get a few things. my ($hmm_file, $sequence_file); while (<$ifh>) { if (/HMM file\\:\\s+(\\S+)/) { $hmm_file = $1; } elsif (/Sequence file\\:\\s+(\\S+)/) { $sequence_file = $1; last; } } ## fetch deflines my $deflines = get_deflines($sequence_file); ## check that these were successfully parsed unless ($hmm_file) { $logger->logdie(\"HMM file definition not found in input file.\") } unless ($sequence_file) { $logger->logdie(\"Sequence file definition not found in input file.\") } my $qry_id; while (<$ifh>) { if (/Query sequence\\:\\s+(\\S+)/) { $qry_id = $1; ## the query sequence only counts up the first whitespace if ($qry_id =~ /(.+?)\\s+/) { $qry_id = $1; } unless ($qry_id) { $logger->logdie(\"Query sequence definition not found in input file.\") } my %alignments; my $alignment_data; my ($model, $description, $score, $eval); ## add the query sequence file to the doc ## the use of 'aa' is not guaranteed here, but we're not using it anyway in loading my $seq = $doc->createAndAddSequence($qry_id, $qry_id, undef, $options{'query_mol_type'}, $options{'query_mol_class'}); $seq->addBsmlLink('analysis', \"\\#$options{search_method}_analysis\", 'input_of'); my $identifier = $qry_id; $doc->createAndAddSeqDataImport($seq, 'fasta', $fasta_input, '', $1) if($options{'fasta_input'}); $doc->createAndAddBsmlAttribute($seq, 'defline', $deflines->{$qry_id}) if($deflines->{$qry_id}); ## for each model matched, create a Seq-pair-alignment and record the overall score and ## overall E-value while (<$ifh>) { ## datalines here look like this: # PF00933 Glyco_hydro_3: Glycosyl hydrolase family 3 320.7 3e-93 1 # PF01915 Glyco_hydro_3_C: Glycosyl hydrolase family 152.2 1.7e-42 1 # PF07691 PA14: PA14 domain 25.5 0.00022 1 # TIGR02148 Fibro_Slime: fibro-slime domain -33.6 1.1 1 # PF02014 Reeler: Reeler domain -46.3 5.9 1 # PF06325 PrmA: ribosomal protein L11 methyltransfera -198.1 8.5 1 if (/^(\\S+)\\s+(.+?)\\s+([0-9\\.\\-e]+)\\s+([0-9\\.\\-e]+)\\s+\\d+\\s*$/) { ($model, $description, $score, $eval) = ($1, $2, $3, $4); ## add this model sequence if we haven't already if( !( $doc->returnBsmlSequenceByIDR($model)) ){ my $seq = $doc->createAndAddSequence($model, $description, undef, $options{'model_mol_type'}, $options{'model_mol_class'}); } # If we do not have any hits above the domain cutoff then we don't want to add this seq-pair aligment cause we # will have no seq-pair runs. As a result we only add a seq-pair alignment if we have a run. # $alignments{$model} = $doc->createAndAddSequencePairAlignment( # refseq => $qry_id, # refstart => 0, # #refend => $cols[2] - 1, # #reflength => $cols[2], # compseq => $model, # class => 'match' # ); # ## add a link element inside this seq-pair-alignment # $alignments{$model}->addBsmlLink('analysis', \"\\#$options{search_method}_analysis\", 'computed_by'); # ## add the total_score and total_eval for this pair # $doc->createAndAddBsmlAttribute($alignments{$model}, 'total_score', $score); # $doc->createAndAddBsmlAttribute($alignments{$model}, 'total_e_value', $eval); $alignment_data->{$model}->{'score'} = $score; $alignment_data->{$model}->{'eval'} = $eval; } ## quit once we hit domain section last if (/Parsed for domains/); } ## we should now be in the region where the domain hits are described. We'll add Seq-pair-runs ## to each of our Seq-pair-alignments here my $linectr=0; while (<$ifh>) { chomp; ## these rows should look like this: # PF00933 1/1 39 254 .. 1 243 [] 320.7 3e-93 # PF01915 1/1 331 702 .. 1 308 [] 152.2 1.7e-42 # PF02014 1/1 345 465 .. 1 150 [] -46.3 5.9 # PF07691 1/1 406 539 .. 1 178 [] 25.5 0.00022 # TIGR02148 1/1 432 525 .. 1 92 [] -33.6 1.1 # PF06325 1/1 449 682 .. 1 312 [] -198.1 8.5 my ($model, $domain_num, $domain_of, $qry_start, $qry_stop, $sbj_start, $sbj_stop, $score, $eval); if (/^(\\S+)\\s+([0-9]+)\\/([0-9]+)\\s+(\\d+)\\s+(\\d+).+(\\d+)\\s+(\\d+).+?([0-9\\-][0-9\\.\\-e]+)\\s+([0-9\\.\\-e\\+]+)\\s*$/) { $linectr++; ($model, $domain_num, $domain_of, $qry_start, $qry_stop, $sbj_start, $sbj_stop, $score, $eval) = ($1, $2, $3, $4, $5, $6, $7, $8, $9); # If we have a seq-pair run we'll make sure we have an alignment to add the run to. If not we'll create it here. if(!$alignments{$model}) { $alignments{$model} = $doc->createAndAddSequencePairAlignment( refseq => $qry_id, refstart => 0, #refend => $cols[2] - 1, #reflength => $cols[2], compseq => $model, class => 'match' ); ## add a link element inside this seq-pair-alignment $alignments{$model}->addBsmlLink('analysis', \"\\#$options{search_method}_analysis\", 'computed_by'); ## add the total_score and total_eval for this pair $doc->createAndAddBsmlAttribute($alignments{$model}, 'total_score', $alignment_data->{$model}->{'score'}); $doc->createAndAddBsmlAttribute($alignments{$model}, 'total_e_value', $alignment_data->{$model}->{'eval'}); } my $run = $doc->createAndAddSequencePairRun( alignment_pair => $alignments{$model}, runscore => $score, runlength => abs($qry_stop - $qry_start) + 1, comprunlength => abs($sbj_stop - $sbj_start) + 1, refpos => min($qry_start, $qry_stop) - 1, refcomplement => 0, comppos => min($sbj_start, $sbj_stop) - 1, compcomplement => 0, ); ## add other attributes of the run $doc->createAndAddBsmlAttribute( $run, 'class', 'match_part'); $doc->createAndAddBsmlAttributes( $run, e_value => $eval, domain_num => $domain_num, domain_of => $domain_of ); } else { ## Skip the headers and blank lines next if (/^Model\\s+Domain\\s+/i); next if (/^----/); next if (/^\\s*$/); ## do nothing if no matches were found next if (/no hits above thresholds/); last if (/Alignments of top-scoring domains/); die \"Could not parse line number '$linectr': '$_'\"; } ## quit once we've read the alignments section last if (/Alignments of top-scoring domains/); } } } ## add the analysis element $doc->createAndAddAnalysis( id => \"$options{search_method}_analysis\", sourcename => $options{'output'}, program => 'hmmpfam', algorithm => 'hmmpfam', ); ## now write the doc $doc->write($options{'output'}, '', $options{gzip_output}); exit; sub check_parameters { ## make sure input file exists if (! -e $options{'input'}) { $logger->logdie(\"input file $options{'input'} does not exist\") } ## make user an output file was passed if (! $options{'output'}) { $logger->logdie(\"output option required!\") } ## handle defaults $options{'search_method'} = 'hmmpfam' unless ( $options{'search_method'} ); if($options{'fasta_input'}) { $fasta_input = $options{'fasta_input'}; } return 1; } sub min { my ($num1, $num2) = @_; if ($num1 < $num2) { return $num1; } else { return $num2; } } ## retrieve deflines from a fasta file sub get_deflines { my ($fasta_file) = @_; my $deflines = {}; my $ifh; if (! -e $fasta_file) { if (-e $fasta_file.\".gz\") { $fasta_file .= \".gz\"; } elsif (-e $fasta_file.\".gzip\") { $fasta_file .= \".gzip\"; } } if ($fasta_file =~ /\\.(gz|gzip)$/) { open ($ifh, \"<:gzip\", $fasta_file) || $logger->logdie(\"can't open input file '$fasta_file': $!\"); } else { open ($ifh, $fasta_file) || $logger->logdie(\"Failed opening '$fasta_file' for reading: $!\"); } while (<$ifh>) { unless (/^>/) { next; } chomp; if (/^>((\\S+).*)$/) { $deflines->{$2} = $1; } } close $ifh; if (scalar(keys(%{$deflines})) < 1) { $logger->warn(\"defline lookup failed for '$fasta_file'\"); } return $deflines; }"
    },
    {
      "tool": "hmmpfam3",
      "converter_script": "hmmpfam32bsml.pl",
      "name": "hmmer2bsml.pl - convert hmmpfam or hmmscan raw output to BSML",
      "synopsis": "USAGE: hmmer2bsml.pl \n        --input=/path/to/somefile.hmmer.raw \n        --output=/path/to/somefile.hmmer.bsml\n      [ --search_method=hmmpfam or hmmpfam3\n        --query_mol_type=aa\n        --query_mol_class=polypeptide\n        --model_mol_type=aa\n        --model_mol_class=polypeptide\n        --fasta_input=/path/to/hmmer/input.fsa\n        --gzip_output=1\n        --log=/path/to/some.log\n        --debug=4 \n        --help\n      ]",
      "description": "This script is used to convert the raw alignment output from an hmmpfam or hmmscan search into BSML.",
      "options": {
        "input": "Input raw alignment file from an hmmpfam or hmmscan search.",
        "output": "Output BSML file",
        "search_method": "Optional. Search method used with hmmpfam.  Default is 'hmmscan' but others\n    include 'hmmsmart', 'hmmpir', etc.",
        "query_mol_type": "Query molecule type (like 'aa' or 'dna').",
        "query_mol_class": "Query molecule type (like 'polypeptide' or 'DNA').",
        "model_mol_type": "Model molecule type (like 'aa' or 'dna').",
        "model_mol_class": "Query molecule type (like 'polypeptide' or 'DNA').",
        "fasta_input": "Optional.  If included, will make a seq data import element and include the \n    defline with the sequences.",
        "gzip_output": "Optional.  If given a non-zero value, will compress the output and give the output\n    file a .gz extension.  If the file already contains one, it won't add another.",
        "debug": "Debug level.  Use a large number to turn on verbose debugging.",
        "log": "Log file",
        "help": "This help message"
      },
      "contact": "Sonia Agrawal sagrawal@som.umaryland.edu =cut use strict; use warnings; use Getopt::Long qw(:config no_ignore_case no_auto_abbrev); use Pod::Usage; use Ergatis::Logger; use HmmTools; use BSML::BsmlRepository; use BSML::BsmlBuilder; use BSML::BsmlParserTwig; use Data::Dumper; my $fasta_input; my $data; my %options = (); my $results = GetOptions (\\%options, 'input|i=s', 'output|o=s', 'search_method|m=s', 'query_mol_type|qt=s', 'query_mol_class|qc=s', 'model_mol_type|mt=s', 'model_mol_class|mc=s', 'fasta_input|f=s', 'gzip_output|g=s', 'log|l=s', 'debug=s', 'help|h') || pod2usage(); my $logfile = $options{'log'} || Ergatis::Logger::get_default_logfilename(); my $logger = new Ergatis::Logger('LOG_FILE'=>$logfile, 'LOG_LEVEL'=>$options{'debug'}); $logger = $logger->get_logger(); # display documentation if( $options{'help'} ){ pod2usage( {-exitval=>0, -verbose => 2, -output => \\*STDOUT} ); } ## make sure all passed options are peachy &check_parameters(\\%options); ## we want a new doc my $doc = new BSML::BsmlBuilder(); ## open the input file for parsing open (my $ifh, $options{'input'}) || $logger->logdie(\"can't open input file for reading\"); if ($options{'search_method'} eq 'hmmpfam') { $data = &read_hmmer2_output($options{'input'}); } elsif ($options{'search_method'} eq 'hmmpfam3') { $data = &read_hmmer3_output($options{'input'}); } ## check that these were successfully parsed unless($data->{'info'}->{'hmm_file'}) { $logger->logdie(\"HMM file definition not found in input file.\") } unless($data->{'info'}->{'sequence_file'}) { $logger->logdie(\"Sequence file definition not found in input file.\") } ## fetch deflines my $deflines = get_deflines($data->{'info'}->{'sequence_file'}); ## This will hold all the alignments we've added to the document so far my %alignments; foreach my $qry_id ( keys %{$data->{'queries'}} ) { my ($model, $description, $score, $eval, $domain_cnt, $alignment_data); ## add the query sequence file to the doc my $seq = $doc->createAndAddSequence($qry_id, $qry_id, undef, $options{'query_mol_type'}, $options{'query_mol_class'}); $seq->addBsmlLink('analysis', \"\\#$options{search_method}_analysis\", 'input_of'); $doc->createAndAddSeqDataImport($seq, 'fasta', $fasta_input, '', $qry_id) if($options{'fasta_input'}); $doc->createAndAddBsmlAttribute($seq, 'defline', $deflines->{$qry_id}) if($deflines->{$qry_id}); ## for each model matched, create a Seq-pair-alignment and record the overall score and ## overall E-value foreach my $hit_id (keys %{$data->{'queries'}->{$qry_id}->{'hits'}} ) { my $hit = $data->{'queries'}->{$qry_id}->{'hits'}->{$hit_id}; next if (scalar keys %{$hit->{'domains'}} == 0); #skip model hits that have no domain hits ## add this model sequence if we haven't already unless( $doc->returnBsmlSequenceByIDR($hit_id) ) { $doc->createAndAddSequence($hit_id, $hit->{'hit_description'}, undef, $options{'model_mol_type'}, $options{'model_mol_class'}); } # Store all the hits as Seq-pair-alignments and all the domains as Seq-pair-runs if( exists( $hit->{'domains'} ) ) { my $aln_obj = $doc->createAndAddSequencePairAlignment(refseq => $qry_id, refstart => 0, compseq => $hit_id, class => 'match'); $aln_obj->addBsmlLink('analysis', \"\\#$options{search_method}_analysis\", 'computed_by'); $doc->createAndAddBsmlAttribute($aln_obj, 'total_score', $hit->{'total_score'}); $doc->createAndAddBsmlAttribute($aln_obj, 'total_e_value', $hit->{'total_evalue'}); foreach my $domain ( sort { $a <=> $b } keys %{$hit->{'domains'}} ) { my $dh = $hit->{'domains'}->{$domain}; my %options = ( 'alignment_pair' => $aln_obj, 'runscore' => $dh->{'domain_score'}, 'runlength' => abs($dh->{'seq_t'} - $dh->{'seq_f'}) + 1, 'comprunlength' => abs($dh->{'hmm_t'} - $dh->{'hmm_f'}) + 1, 'refpos' => min($dh->{'seq_f'}, $dh->{'seq_t'}) - 1, 'refcomplement' => 0, 'comppos' => min($dh->{'hmm_f'}, $dh->{'hmm_t'}) - 1, 'compcomplement' => 0, ); my $run = $doc->createAndAddSequencePairRun( %options ); $doc->createAndAddBsmlAttribute( $run, 'class', 'match_part'); $doc->createAndAddBsmlAttributes($run, 'e_value' => $dh->{'domain_evalue'}, 'domain_num' => $domain, 'domain_of' => $hit->{'domain_count'} ); } } } } ## add the analysis element $doc->createAndAddAnalysis('id' => \"$options{search_method}_analysis\", 'sourcename' => $options{'output'}, 'program' => $data->{'info'}->{'program'}, 'algorithm' => $data->{'info'}->{'program'} ); ## now write the doc $doc->write($options{'output'}, '', $options{gzip_output}); sub check_parameters { ## make sure input file exists if (! -e $options{'input'}) { $logger->logdie(\"input file $options{'input'} does not exist\") } ## make user an output file was passed if (! $options{'output'}) { $logger->logdie(\"output option required!\") } ## handle defaults $options{'search_method'} = 'hmmpfam3' unless ( $options{'search_method'} ); if($options{'fasta_input'}) { $fasta_input = $options{'fasta_input'}; } return 1; } sub min { my ($num1, $num2) = @_; if ($num1 < $num2) { return $num1; } else { return $num2; } } ## retrieve deflines from a fasta file sub get_deflines { my ($fasta_file) = @_; die(\"Pass in fasta_file\") unless( defined( $fasta_file ) ); my $deflines = {}; my $ifh; if (! -e $fasta_file) { if (-e $fasta_file.\".gz\") { $fasta_file .= \".gz\"; } elsif (-e $fasta_file.\".gzip\") { $fasta_file .= \".gzip\"; } } if ($fasta_file =~ /\\.(gz|gzip)$/) { open ($ifh, \"<:gzip\", $fasta_file) || $logger->logdie(\"can't open input file '$fasta_file': $!\"); } else { open ($ifh, $fasta_file) || $logger->logdie(\"Failed opening '$fasta_file' for reading: $!\"); } while (<$ifh>) { unless (/^>/) { next; } chomp; if (/^>((\\S+).*)$/) { $deflines->{$2} = $1; } } close $ifh; if (scalar(keys(%{$deflines})) < 1) { $logger->warn(\"Defline lookup failed for '$fasta_file'\"); } return $deflines; }"
    },
    {
      "tool": "hmmpir",
      "converter_script": "hmmpir2bsml.pl",
      "name": "hmmpir2bsml.pl - convert hmmpir raw output to BSML",
      "synopsis": "USAGE: hmmpir2bsml.pl \n        --input=/path/to/somefile.hmmpir.raw \n        --output=/path/to/somefile.hmmpir.bsml\n      [ --fasta_input=/path/to/hmmpir/input.fsa\n        --gzip_output=1\n        --log=/path/to/some.log\n        --debug=4 \n        --help\n      ]",
      "description": "This script is used to convert the raw alignment output from an hmmpir search into BSML.",
      "options": {
        "input": "Input raw alignment file from an hmmpir search.",
        "output": "Output BSML file",
        "fasta_input": "Optional.  The input file used in the hmmpir run that created the raw file.",
        "gzip_output": "Optional.  Compress the bsml output if a non-zero value.",
        "debug": "Debug level.  Use a large number to turn on verbose debugging.",
        "log": "Log file",
        "help": "This help message"
      },
      "contact": "Joshua Orvis jorvis@tigr.org =cut use strict; use Getopt::Long qw(:config no_ignore_case no_auto_abbrev); use Pod::Usage; BEGIN { use Ergatis::Logger; use BSML::BsmlRepository; use BSML::BsmlBuilder; use BSML::BsmlParserTwig; } my $gzip; my $fasta_input; my $defline; my %options = (); my $results = GetOptions (\\%options, 'input|i=s', 'output|o=s', 'fasta_input|f=s', 'gzip_output|g=s', 'log|l=s', 'debug=s', 'help|h') || pod2usage(); my $logfile = $options{'log'} || Ergatis::Logger::get_default_logfilename(); my $logger = new Ergatis::Logger('LOG_FILE'=>$logfile, 'LOG_LEVEL'=>$options{'debug'}); $logger = $logger->get_logger(); # display documentation if( $options{'help'} ){ pod2usage( {-exitval=>0, -verbose => 2, -output => \\*STDOUT} ); } ## make sure all passed options are peachy &check_parameters(\\%options); ## we want a new doc my $doc = new BSML::BsmlBuilder(); ## open the input file for parsing open (my $ifh, $options{'input'}) || $logger->logdie(\"can't open input file for reading\"); ## go through the top of the file and get a few things. my ($qry_id, $sbj_id, $description, $seq_pair_alignment); while (<$ifh>) { chomp; if (/Query sequence\\: (\\S+)\\s+matches (\\S+)\\:\\s+(.*)/) { ($qry_id, $sbj_id, $description) = ($1, $2, $3); ## the query sequence only counts up the first whitespace if ($qry_id =~ /(.+?)\\s+/) { $qry_id = $1; } ## make sure the name is legal my $qry_id_orig = $qry_id; $qry_id =~ s/[^a-zA-Z0-9\\.\\-\\_]/_/g; ## add the query sequence file to the doc ## the use of 'aa' is not guaranteed here, but we're not using it anyway in loading my $seq = $doc->createAndAddSequence($qry_id, $qry_id_orig, undef, 'aa', 'polypeptide'); $seq->addBsmlLink('analysis', \"\\#hmmpir_analysis\"); my $identifier = ''; $identifier = $1 if($defline =~ /^([^\\s]+)/ && $fasta_input); $doc->createAndAddSeqDataImport( $seq, 'fasta', $fasta_input, '', $identifier) if($fasta_input); $doc->createAndAddBsmlAttribute( $seq, 'defline', $defline); ## add the subject sequence file to the doc ## the use of 'aa' is not guaranteed here, but we're not using it anyway in loading $seq = $doc->createAndAddSequence($sbj_id, $description, undef, 'aa', 'profile'); $seq->addBsmlLink('analysis', \"\\#hmmpir_analysis\"); ## create the seq pair alignment $seq_pair_alignment = $doc->createAndAddSequencePairAlignment( refseq => $qry_id, refxref => \":$qry_id\", refstart => 0, method => 'hmmpir', compseq => $sbj_id, compxref => \":$sbj_id\", class => 'match' ); last; } } ## we should now be in the region where the domain hits are described. We'll add Seq-pair-runs ## to each of our Seq-pair-alignments here while (<$ifh>) { ## these rows should look like this: # PF02310 1/1 12 136 .. 1 142 [] -14.7 1.1 # PF01582 1/1 14 142 .. 1 150 [] 189.0 1.4e-53 my ($model, $domain_num, $domain_of, $qry_start, $qry_stop, $sbj_start, $sbj_stop, $score, $eval); if (/(\\S+)\\s+([0-9]+)\\/([0-9]+)\\s+(\\d+)\\s+(\\d+).+(\\d+)\\s+(\\d+).+([0-9\\.\\-e]+)\\s+([0-9\\.\\-e]+)/) { ($model, $domain_num, $domain_of, $qry_start, $qry_stop, $sbj_start, $sbj_stop, $score, $eval) = ($1, $2, $3, $4, $5, $6, $7, $8, $9); ## make sure this model matches the one we know about if ($model ne $sbj_id) { $logger->logdie(\"unhandled multiple-model hits find in file\"); } ## check and make sure we got a seq pair alignment if (! defined $seq_pair_alignment) { $logger->logdie(\"attempted to add a seq pair run without a seq pair alignment\"); } my $run = $doc->createAndAddSequencePairRun( alignment_pair => $seq_pair_alignment, runscore => $score, runlength => abs($qry_stop - $qry_start) + 1, comprunlength => abs($sbj_stop - $sbj_start) + 1, refpos => min($qry_start, $qry_stop) - 1, refcomplement => 0, comppos => min($sbj_start, $sbj_stop) - 1, compcomplement => 0, class => 'match_part' ); ## add other attributes of the run $doc->createAndAddBsmlAttribute( $run, 'class', 'match_part'); $doc->createAndAddBsmlAttributes($run, e_value => $eval, domain_num => $domain_num, domain_of => $domain_of, ); } } ## add the analysis element $doc->createAndAddAnalysis( id => \"hmmpir_analysis\", sourcename => $options{'output'}, ); ## now write the doc $doc->write($options{'output'}, '', $gzip); exit; sub check_parameters { ## make sure input file exists if (! -e $options{'input'}) { $logger->logdie(\"input file $options{'input'} does not exist\") } ## make user an output file was passed if (! $options{'output'}) { $logger->logdie(\"output option required!\") } ## check for fasta_input and if found, parse the defline if ($options{'fasta_input'}) { open(IN, \"< $options{fasta_input}\") or $logger->logdie(\"Could not open $options{'fasta_input'} ($!)\"); while(<IN>) { chomp; if(/^>(.*)/) { $defline = $_; last; } } close(IN); $fasta_input = $options{'fasta_input'}; } if($options{'gzip_output'}) { $gzip = 1; } else { $gzip = 0; } return 1; } sub min { my ($num1, $num2) = @_; if ($num1 < $num2) { return $num1; } else { return $num2; } }"
    },
    {
      "tool": "infernal",
      "converter_script": "infernal2bsml.pl",
      "name": "infernal.pl - Turns infernal raw output into bsml.",
      "synopsis": "USAGE: template.pl\n            --input_file=/path/to/some/transterm.raw\n            --output=/path/to/transterm.bsml\n            --project=aa1\n            --id_repository=/some/id_repository/dir\n            --query_file_path=/input/file.fsa\n            --gzip_output=1\n          [ --infernal_v1\n            --annot_bsml_list=/path/to/annot_bsml.list\n            --stockholm_path=/path/to/stockholm/files\n            --default_type=ncRNA\n            --log=/path/to/file.log\n            --debug=4\n            --help\n          ]",
      "description": "Reads in infernal output and produces a bsml representation of the matches.",
      "options": {
        "input_file": "The table output from Infernal's 'cmsearch' run.",
        "output": "Where the output bsml file should be",
        "project": "[DEPRECATED] The script will parse the project from the sequence id.\n    Used in id generation.  It's the first token in the id.  (Ex. project.class.number.version)",
        "id_repository": "Used to make the ids (See Ergatis::IdGenerator for details)",
        "query_file_path": "Path to the query file (input fasta file) for infernal.",
        "gzip_output": "A non-zero value will result in compressed bsml output.  If no .gz is on the end of the bsml output name, one will\n    be added.",
        "infernal_v1": "Whether or not to expect infernal 1.0 or later output. If left off then the assumption is that the input is \n    pre-infernal 1.0",
        "annot_bsml_list": "A list file containing the existing annotation bsml. This will activate the appending of the genome tag to the output bsml.",
        "stockholm_path": "The path to the stockholm files that contain the alignments for the Rfam CMs. This is required if you want a good type to \n    be assigned to your hits.  Can be a directory with the CM IDs in the file names, or a file with all CMs.",
        "default_type": "The default SO type to be assigned to either all hits or only those hits that don't have a valid SO mapping in their \n    stockholm file (if --stockholm_path is specified).",
        "log": "In case you wanted a log file.",
        "debug": "There are no debug statements in this program.  Sorry.",
        "help": "Displays this message."
      },
      "contact": "Kevin Galens kgalens@tigr.org =cut use lib (@INC,$ENV{\"PERL_MOD_DIR\"}); no lib \"$ENV{PERL_MOD_DIR}/i686-linux\"; no lib \".\"; use strict; use warnings; use BSML::GenePredictionBsml; use BSML::BsmlBuilder; use Ergatis::IdGenerator; use Ergatis::Logger; use Chado::Gene; use Getopt::Long qw(:config no_ignore_case no_auto_abbrev); use XML::Twig; #use Pod::Usage; ###############GLOBALS###################### my $DEBUG = 4; # Default DEBUG number my %options = (); #Options hash my $input; my $output; my $gene_pred; my $idMaker; #Id generator object my $project; my $gzip; my $defline; # The following is a mapping of all the supported RFAM types # and their associated SO type. These types were derived by # manually matching the TP line data from RFAM stockholm files # with appropriate SO terms. If the TP line of the associated # stockholm file does not have a value in SO then the behaviour # will default to whetever type is specified in --default_type. # If no value is specified then the hit will be ignored. my $RFAM_TP_TO_SO_TYPE = { 'snoRNA' => 'snoRNA', 'rRNA' => 'rRNA', 'tRNA' => 'tRNA', 'riboswitch' => 'riboswitch', 'miRNA' => 'miRNA', 'IRES' => 'internal_ribosome_entry_site', 'ribozyme' => 'ribozyme', 'snRNA' => 'snRNA' }; ############################################ #Get the options. my $results = GetOptions (\\%options, 'input|i=s', 'output|o=s', 'project|p=s', 'id_repository|r=s', 'query_file_path|q=s', 'gzip_output|g=s', 'infernal_v1|v1', 'stockholm_path|sp:s', 'annot_bsml_list|al:s', 'default_type|dt:s', 'log|l=s', 'command_id=s', ## passed by workflow 'logconf=s', ## passed by workflow (not used) 'debug=s', 'help|h') || pod2usage(); $options{'debug'} = $DEBUG if ! $options{'debug'}; #Make the logger my $logfile = $options{'log'} || Ergatis::Logger::get_default_logfilename(); my $logger = new Ergatis::Logger('LOG_FILE'=>$logfile, 'LOG_LEVEL'=>$options{'debug'}); $logger = $logger->get_logger(); #Create the gene prediction bsml document $gene_pred = new BSML::GenePredictionBsml( 'infernal', $options{'output'}); my $doc = $gene_pred->{'doc'}; #new BSML::BsmlBuilder(); #Bsml Builder object #If the help option is used, spit out documentation &_pod if( $options{'help'} ); #Check in input parameters and set up some variables. &check_parameters(\\%options); my $rawStructure; #Parse the input file print STDERR \"Parsing a V1 infernal output\\n\"; $rawStructure = &parseInfernalRawV1($input); print STDERR \"Building a hash of Rfam types and descriptions\\n\"; my $cm_hash = build_cm_type_desc_hash(); #Create a bsml document out of the data &createBsml($rawStructure, $cm_hash); print STDERR \"Finished creating BSML\\n\"; #Write the bsml file. $gene_pred->writeBsml($output, '', $gzip); print STDERR \"Finished writing BSML\\n\"; # If we have been passed a annotation file list then we'll need to add the genome tag to # the output bsml files. # Note that this is a total HACK if($options{'annot_bsml_list'}) { &appendGenomeLink(&getInputFiles($options{'annot_bsml_list'}),[$options{'output'}]); print STDERR \"Finished creating annotated BSML list\\n\"; } exit(0); ###################################### SUBROUTINES ################################ sub parseInfernalRawV1 { my $inputFile = shift; my @prevLines; my $infHit; my $retval; open(IN, \"< $inputFile\") or &_die(\"Unable to open input $inputFile\"); my $seqstart; my $seqstop; my $qstart; my $qstop; my $tstart; my $tstop; my $strand; while(<IN>) { #next if (/^#target/) || (/^#---/); next if (/^#/); my @fields = split(/\\s+/); $infHit->{'seqId'} = $fields[0]; $infHit->{'name'} = $fields[2]; $infHit->{'cmId'} = $fields[3]; $qstart = $fields[5]; $qstop = $fields[6]; $tstart = $fields[7]; $tstop = $fields[8]; $infHit->{'bit_score'} = $fields[13]; # Currently assuming the Rfam.cm general file is being used. Store the path #if(/\\# query CM file:\\s+(\\/.*\\.cm)/) { # $infHit->{'cmPath'} = $1; #} # Hit start should always be less than hit stop $infHit->{'strand'} = 0; if($tstart > $tstop) { my $tmp = $tstart; $tstart = $tstop; $tstop = $tmp; $infHit->{'strand'} = 1; } $infHit->{'start'} = $tstart; $infHit->{'stop'} = $tstop; $infHit->{'runlength'} = $tstop - $tstart; $infHit->{'comprunlength'} = abs($qstop - $qstart); $project = $1 if($infHit->{'seqId'} =~ /^([^\\.]+)/); my %tmpHash = %{$infHit}; push(@{$retval}, \\%tmpHash); %$infHit = (); # Reset hash } close(IN); return $retval; } #######GENERATE BSML (helper functions follow)############# sub createBsml { my $infernalRaw = shift; my $cm_hash = shift; my %querySeqs; my %cmSeqs; my %spas; my %fts; my %countHits; my ($type, $desc); foreach my $match (@{$infernalRaw}) { #See if we have a type for the given Rfam CM. If not we're moving on. $type = $cm_hash->{$match->{'cmId'}}->{type}; if(!$type) { next; } else { $desc = $cm_hash->{$match->{'cmId'}}->{desc}; } #Make sure the covariance model has been added as a sequence # S Adkins - Currently these are missing Seq-data-import tags, which causes pipeline summary to fail # so I am commenting out for now #&addCoModel(\\%cmSeqs, $match); # First, create the gene feature my $currGene = new Chado::Gene ( $idMaker->next_id( 'type' => 'gene', 'project' => $project ), $match->{'start'}, $match->{'stop'}, $match->{'strand'}, $match->{'seqId'} ); ## Next, with the same coords, create the RNA feature my $rna_feat_id = $currGene->addFeature( $idMaker->next_id ( 'type' => $type, 'project' => $project ), $match->{'start'}, $match->{'stop'}, $match->{'strand'}, $type ); ## add name attribute to feature $currGene->addFeatureAttribute( $rna_feat_id, 'gene_product_name', $desc, ); ## add name attribute to feature $currGene->addFeatureAttribute( $rna_feat_id, 'gene_product_name_source', $match->{'cmId'}, ); ## add score attribute to feature $currGene->addFeatureAttribute( $rna_feat_id, 'score', $match->{'bit_score'}, ); foreach my $t (qw(exon CDS)) { # Add the exon or CDS to the gene model object $currGene->addFeature( $idMaker->next_id( 'type' => $t, 'project' => $project ), $match->{'start'}, $match->{'stop'}, $match->{'strand'}, $t ); } # Handle Group now: my $count = $currGene->addToGroup( $currGene->getId, { 'all' => 1} ); $gene_pred->addGene($currGene); # Add query sequence $gene_pred->addSequence($match->{'seqId'}, $options{'query_file_path'}); } } # 12/10/15 - SAdkins - Not actually used in this script # sub addQuerySeq { # my ($querySeqs, $fts, $match) = @_; # # unless($querySeqs->{$match->{'seqId'}}) { # $querySeqs->{$match->{'seqId'}} = # $doc->createAndAddSequence($match->{'seqId'},undef, # undef, 'dna', 'assembly'); # $querySeqs->{$match->{'seqId'}}->addBsmlLink('analysis', '#infernal_analysis', 'input_of'); # $querySeqs->{$match->{'seqId'}}->addBsmlAttr('defline', $defline); # $fts->{$match->{'seqId'}} = # $doc->createAndAddFeatureTable($querySeqs->{$match->{'seqId'}}); # } # # } sub addCoModel { my ($cmSeqs, $match) = @_; unless($cmSeqs->{$match->{'cmId'}}) { $cmSeqs->{$match->{'cmId'}} = $doc->createAndAddSequence($match->{'cmId'}, undef, undef, 'rna', 'covariance_model'); $cmSeqs->{$match->{'cmId'}}->addBsmlLink('analysis', '#infernal_analysis', 'input_of'); } } # 12/10/15 - SAdkins - Not actually used in this script # sub addSeqPair { # my($spas, $match) = @_; # # unless($spas->{$match->{'seqId'}.$match->{'cmId'}}) { # $spas->{$match->{'seqId'}.$match->{'cmId'}} = # my $aln = $doc->createAndAddSequencePairAlignment( refseq => $match->{'seqId'}, # compseq => $match->{'cmId'}, # complength => \"\", # class => \"match\", # refstart => 0,); # $aln->addBsmlLink('analysis', '#infernal_aalysis', 'computed_by'); # } # # my $spr = $doc->createAndAddSequencePairRun(alignment_pair => # $spas->{$match->{'seqId'}.$match->{'cmId'}}, # runscore => $match->{'score'}, # runlength => $match->{'runlength'}, # comprunlength => $match->{'comprunlength'}, # refpos => $match->{'start'}, # refcomplement => $match->{'strand'}, # comppos => 0, # compcomplement => 0, # ); # # $doc->createAndAddBsmlAttribute($spr, 'class', 'match_part'); # $doc->createAndAddBsmlAttribute($spr, bit_score => $match->{'bit_score'}); # # # } # Build a hash consisting of the type and decription for each CM sub build_cm_type_desc_hash { my $cmId = ''; my $type = \"\"; my $desc = \"\"; my $cm_hash = {}; my $file; # Determine if stockholm input is a file or a directory if (-d $options{'stockholm_path'}){ opendir(DIR, $options{'stockholm_path'}) || warn \"can't opendir $options{'stockholm_path'}: $!\"; $cm_hash = parse_file($file, $cm_hash) while ($file = readdir(DIR)); closedir(DIR); } elsif (-f $options{'stockholm_path'}) { $file = $options{'stockholm_path'}; $cm_hash = parse_file($file, $cm_hash); } else { &_die(\"Stockholm path specified was neither a directory nor a file\"); } return $cm_hash; } # Parse the Stockholm Rfam file and push relevant parts into a hash-ref sub parse_file { my ($file, $cm_hash) = @_; open(IN, $file ) or &_warn(\"Unable to open file $file for reading\"); my $cm = ''; my $type = ''; my $desc = ''; while(<IN>) { if(/^\\#=GF\\sAC\\s+(.+)/) { $cm = $1; } if(/^\\#=GF\\sTP\\s+(.+)/) { my @types = split(/;/, $1); map { s/\\s//g; if($RFAM_TP_TO_SO_TYPE->{$_}) { $type = $RFAM_TP_TO_SO_TYPE->{$_}; } }@types; $type = $options{'default_type'} if(!$type && $options{'default_type'}); if(!$type) { print STDERR \"WARN: ignoring $cm hit because it's type could not be determined\\n\"; } } elsif(/^\\#=GF\\sDE\\s+(.*)/) { $desc = $1; } if (m{^//}) { $cm_hash->{$cm}->{type} = $type; $cm_hash->{$cm}->{desc} = $desc; } } close(IN); return ($cm_hash); } #############END OF BSML GENERATION##################### sub check_parameters { #input must be passed and must exist if($options{'input'}) { &_die(\"input option ($options{input}) does not exist\") unless(-e $options{'input'}); } else { &_die(\"input option was not passed and is required\"); } $input = $options{'input'}; #output must be passed &_die(\"output option was not passed and is required\") unless($options{'output'}); $output = $options{'output'}; #the id_repository should be passed (perhaps it should also exist, but whatever). unless($options{'id_repository'}) { &_die(\"option id_repository is required (for id generation).\". \" See Ergatis::IdGenerator for more information\"); } $idMaker = new Ergatis::IdGenerator( id_repository => \"$options{'id_repository'}\" ); #If the query file path was given, parse out the definition line. if($options{'query_file_path'}) { open(IN, \"<$options{query_file_path}\") or &_die(\"Unable to open $options{query_file_path}\"); while(<IN>) { chomp; if(/^>(.*)/) { $defline = $1; last; } } close(IN); } if(!$options{'stockholm_path'} && !$options{'default_type'}) { &_die(\"You must specify either --stockholm_path or --default_type or both\"); } } #------------------------------------------------------------------------------------------# # From here down is a super duper hack. This was at one point another script that has been # # copied into this script because we cannot do conditionals in ergatis. # sub appendGenomeLink { my $annotFiles = shift; my $analFiles = shift; my @annotationFiles = @$annotFiles; my @analysisFiles = @$analFiles; # First make a mapping of sequence_id to genome tag. my $sequence_id_to_genome = {}; foreach my $file (@annotationFiles) { my $genome_tag; my $genome_id; my $found_sequence = 0; my $twig = new XML::Twig( twig_handlers => { 'Genomes' => sub { my($t, $genome) = @_; $t->set_pretty_print('indented'); $genome_tag = $genome->sprint(0,0); $genome_id = $genome->child('Genome')->{'att'}->{'id'}; }, 'Sequence[@class=\"assembly\"]' => sub { my($t, $seq) = @_; if($seq->{'att'}->{'class'} eq 'assembly') { my $ident = $seq->first_child('Seq-data-import')->{'att'}->{'identifier'}; if($ident =~ /\\|/) { print STDERR \"Found some pipes \\| in identifier $ident. Replacing them with '_'. This is a no smoking script.\\n\"; $ident =~ s/\\|/\\_/g; } $sequence_id_to_genome->{$ident} = { 'tag' => $genome_tag, 'id' => $genome_id }; $found_sequence = 1; } } }, ignore_elts => { 'Feature-tables' => 1, 'Feature-group' => 1, 'Feature' => 1, 'Sequence[@class!=\"assembly\"]' => 1}); # Parse the file my $openFile; if( -e $file ) { open($openFile, \"< $file\"); } elsif( -e $file.\".gz\" ) { open($openFile, \"<:gzip\", $file.\".gz\"); } else { } $twig->parse($openFile); print STDERR \"Couldn't find genome tag or Sequence tag for $file\\n\" if !$found_sequence; } print STDERR \"Done making sequence_id->genome_tag mapping\\n\"; # Next make a mapping of filename to sequence_id my $analysis_file_name_to_sequence_id = {}; foreach my $file (@analysisFiles) { my $genome_tag; my $genome_id; my $twig = new XML::Twig( twig_handlers => { 'Sequence' => sub { my($t, $seq) = @_; if($seq->{'att'}->{'class'} eq 'assembly') { print STDERR $seq->{'att'}->{'id'}.\"\\n\"; $analysis_file_name_to_sequence_id->{$file} = $seq->{'att'}->{'id'}; } } }); # Parse the file my $openFile; if( -e $file ) { open($openFile, \"< $file\"); } elsif( -e $file.\".gz\" ) { open($openFile, \"<:gzip\", $file.\".gz\"); } else { } $twig->parse($openFile); } print STDERR \"Done making filename->sequence_id\\n\"; # Lastly we'll add the genome text and the link. foreach my $file (@analysisFiles) { # Parse the file my $openFile; if( -e $file ) { open($openFile, \" $file\"); } elsif( -e $file.\".gz\" ) { open($openFile, \":gzip\", $file.\".gz\"); } else { } my $in_sequence = 0; my $fname = $file; $fname =~ s/.*\\/([^\\/]+)/$1/; open(my $outputFile, \">\".$file.\".new\"); while(<$openFile>) { chomp; my $line = $_; if($line =~ /<Definitions>/) { if($analysis_file_name_to_sequence_id->{$file}) { print $outputFile $line.($sequence_id_to_genome->{$analysis_file_name_to_sequence_id->{$file}}->{'tag'}.\"\\n\"); } else { print STDERR \"Wasn't able to add a genome tag to $file\\n\"; } } elsif($line =~ /<Sequence.*assembly.*/) { $in_sequence = 1; } elsif($line =~ /(.*)<\\/Sequence>/ && $in_sequence) { $in_sequence = 0; if($analysis_file_name_to_sequence_id->{$file}) { print $outputFile \"$1<Link rel=\\\"genome\\\" href=\\\"\\#\". ($sequence_id_to_genome->{$analysis_file_name_to_sequence_id->{$file}}->{'id'}).\"\\\"></Link>\\n\"; print $outputFile $line.\"\\n\"; } } else { print $outputFile \"$line\\n\"; } } my $er = `cp $file\\.new $file`; if(!$er) { print STDERR `rm $file\\.new`; } else { print STDERR \"Issues copying $file\\.new to $file\\n\"; } } } sub getInputFiles { my $inputStr = shift; my @files; #comma unseparate my @tokens = split( /,/, $inputStr); foreach my $token ( @tokens ) { my $tfh; $token =~ s/\\.gz$//; if( -e $token ) { open($tfh, \"< $token\") or &_die(\"Can't open $token ($!)\"); } elsif( -e $token.\".gz\" ) { my $compFile = $token.\".gz\"; open($tfh, \"<:gzip\", \"$compFile\") or &_die(\"Can't open $compFile ($!)\"); } else { die(\"Can't find file $token\"); } my $isList = 0; while( my $line = <$tfh> ) { next if($line =~ /^\\s+$/); #It's a bsml file. if($line =~ /</ && !$isList) { push(@files, $token); last; #It's a list. } elsif($line =~ m|\\.bsml|) { chomp $line; &_die(\"$line doesn't exist (from list $token) ($!)\") unless(-e $line || -e $line.\".gz\"); push(@files, $line); $isList = 1; } } } return \\@files; } sub _pod { pod2usage( {-exitval=>0, -verbose => 2, -output => \\*STDOUT} ); } #DIE! sub _die { my $msg = shift; $logger->logdie($msg); } ######EOF###############################"
    },
    {
      "tool": "iprscan",
      "converter_script": "iprscan2bsml.pl",
      "name": "iprscan2bsml.pl - convert iprscan btab output to BSML",
      "synopsis": "USAGE: iprscan2bsml.pl \n    --input=/path/to/somefile.iprscan.raw \n    --output=/path/to/somefile.iprscan.bsml\n  [ --fasta_input=/path/to/iprscan/input.fsa\n    --gzip_output=1 ]",
      "description": "This script is used to convert the tab-delimited output from a nap search into BSML.",
      "options": {
        "input": "Input tab-delimited file from an iprscan search.",
        "query_file_path": "Full path to FASTA file containing query sequence.  This allows the creation\n    of a Sequence element in BSML even if there are no matches.",
        "debug": "Debug level.  Use a large number to turn on verbose debugging.",
        "gzip_output": "Optional.  Non-zero value will give you a compressed bsml file. If output\n    does not contain a .gz extension, it will be added automatically.",
        "log": "Log file",
        "output": "Output BSML file",
        "help": "This help message"
      },
      "contact": "Joshua Orvis jorvis@tigr.org =cut use strict; use Getopt::Long qw(:config no_ignore_case no_auto_abbrev); use Pod::Usage; use Ergatis::Logger; use BSML::BsmlRepository; use BSML::BsmlBuilder; use BSML::BsmlParserTwig; use File::Basename; use XML::Twig; my $gzip; my $fasta_input; my $defline; my $identifier; my %options = (); my $results = GetOptions (\\%options, 'input|i=s', 'output|o=s', 'fasta_input|f=s', 'gzip_output|g=s', 'query_file_path|q=s', 'log|l=s', 'debug=s', 'help|h') || pod2usage(); my $logfile = $options{'log'} || Ergatis::Logger::get_default_logfilename(); my $logger = new Ergatis::Logger('LOG_FILE'=>$logfile, 'LOG_LEVEL'=>$options{'debug'}); $logger = $logger->get_logger(); # display documentation if( $options{'help'} ){ pod2usage( {-exitval=>0, -verbose => 2, -output => \\*STDOUT} ); } ## make sure all passed options are peachy &check_parameters(\\%options); ## we want a new doc my $doc = new BSML::BsmlBuilder(); ## open the input file for parsing open (my $ifh, $options{'input'}) || $logger->logdie(\"can't open input file for reading\"); my $deflines = get_deflines($options{'query_file_path'}); my %seqs_found; print Dumper $deflines; foreach my $query_id(keys(%{$deflines})) { ## add the query sequence to the BSML doc my $seq = $doc->createAndAddSequence($query_id, $query_id, undef, 'na', 'assembly'); $doc->createAndAddSeqDataImport($seq, 'fasta', $options{query_file_path}, '', $query_id); $seq->addBsmlLink('analysis', '#iprscan_analysis', 'input_of'); $doc->createAndAddBsmlAttribute( $seq, 'defline', $deflines->{$query_id}) if ($deflines->{$query_id}); $seqs_found{$query_id} = 1; } while (<$ifh>) { ## ignore whitespace lines next if ( /^\\s*$/ ); chomp; ## there should be 14 elements in cols, unless we have an unrecognized format. my @cols = split(\"\\t\"); unless (scalar @cols >= 13) { $logger->error(\"the following iprscan line was not recognized and could not be parsed (should have 14 columns, actually has \" . scalar(@cols) . \"):\\n$_\\n\") if ($logger->is_error); next; } ## This isn't the right way to do the subject ID, but given a name like PIRSF001424 there ## isn't a reliable way to parse the database name from the entry name, unless we have a ## fixed list of database prefixes we can explicitly check. Just do this for now so we ## can have a working solution. my ($qry_id, $sbj_db, $sbj_id, $sbj_name) = ($cols[0], $cols[3], $cols[4], $cols[5]); ## the qry ID only counts up to the first whitespace if ($qry_id =~ /(.+?)\\s+/) { $qry_id = $1; } ## make sure both of these are valid IDs $qry_id =~ s/[^a-zA-Z0-9\\.\\-\\_]/_/g; $sbj_id =~ s/[^a-zA-Z0-9\\.\\-\\_]/_/g; ## has this subject sequence been added to the doc yet? if (! exists $seqs_found{$sbj_id}) { my $seq = $doc->createAndAddSequence($sbj_id, $cols[5], undef, 'aa', 'polypeptide'); $doc->createAndAddCrossReference( parent => $seq, database => $sbj_db, 'identifier-type' => 'accession', identifier => $sbj_id ); $doc->createAndAddCrossReference( parent => $seq, database => $sbj_db, 'identifier-type' => 'entry-name', identifier => $sbj_name ); if ($cols[11] =~ /IPR/ ) { $doc->createAndAddCrossReference( parent => $seq, database => 'interpro', 'identifier-type' => 'accession', identifier => $cols[11] ); } $seqs_found{$sbj_id} = 1; } ## each line represents a matched domain, so create a Seq-pair-alignment ## skipped attributes here are complength, compstart, compend and method my $seq_pair_aln = $doc->createAndAddSequencePairAlignment( refseq => $qry_id, refstart => $cols[6] - 1, refend => $cols[7], reflength => $cols[2], compseq => $sbj_id, class => 'match', ); $seq_pair_aln->addBsmlLink('analysis', '#iprscan_analysis'); if ( $cols[8] ne 'NA' ) { ## add the e_value (will be the same for each matching segment) $doc->createAndAddBsmlAttribute($seq_pair_aln, 'e_value', $cols[8]); } ## now add the Seq-pair-run ## skipped attributes are runprob my $run = $doc->createAndAddSequencePairRun( alignment_pair => $seq_pair_aln, runscore => 0, ## raw score is not given runlength => $cols[7] - $cols[6], comprunlength => $cols[7] - $cols[6], refpos => $cols[6] - 1, refcomplement => 0, comppos => 0, compcomplement => 0, ); $doc->createAndAddBsmlAttribute($run, 'class', 'match_part'); if ( $cols[8] ne 'NA' ) { $doc->createAndAddBsmlAttribute($run, 'e_value', $cols[8]); } } ## add the analysis element my $analysis = $doc->createAndAddAnalysis( id => 'iprscan_analysis', sourcename => $options{'output'}, program => 'iprscan', algorithm => 'iprscan', ); $doc->createAndAddBsmlAttribute( $analysis, 'version', 'current' ); $doc->createAndAddBsmlAttribute( $analysis, 'algorithm', 'iprscan' ); ## now write the doc $doc->write($options{'output'}, '', $gzip); exit; sub check_parameters { ## make sure input file exists if (! -e $options{'input'}) { $logger->logdie(\"input file $options{'input'} does not exist\") } ## make user an output file was passed if (! $options{'output'}) { $logger->logdie(\"output option required!\") } unless ($options{query_file_path}) { $logger->logdie(\"Must specify query file with flag --query_file_path\") } ## do we want compressed output? if($options{'gzip_output'}) { $gzip = 1; } else { $gzip = 0; } ## store some options if the fasta_input file was included if($options{'query_file_path'}) { $fasta_input = $options{'query_file_path'}; open(IN, \"< $fasta_input\") or $logger->logdie(\"Could not open $fasta_input ($!)\"); while(<IN>) { chomp; if(/^>(.*)/) { $defline = $1; $identifier = $1 if($defline =~ /^([^\\s]+)/); } } close(IN); } return 1; } ## retrieve deflines from a fasta file sub get_deflines { my ($fasta_file) = @_; my $deflines = {}; my $ifh; if (! -e $fasta_file) { if (-e $fasta_file.\".gz\") { $fasta_file .= \".gz\"; } elsif (-e $fasta_file.\".gzip\") { $fasta_file .= \".gzip\"; } } if ($fasta_file =~ /\\.(gz|gzip)$/) { open ($ifh, \"<:gzip\", $fasta_file) || $logger->logdie(\"can't open input file '$fasta_file': $!\"); } else { open ($ifh, $fasta_file) || $logger->logdie(\"Failed opening '$fasta_file' for reading: $!\"); } while (<$ifh>) { unless (/^>/) { next; } chomp; if (/^>((\\S+).*)$/) { $deflines->{$2} = $1; } } close $ifh; if (scalar(keys(%{$deflines})) < 1) { $logger->warn(\"defline lookup failed for '$fasta_file'\"); } return $deflines; }"
    },
    {
      "tool": "islandpath",
      "converter_script": "islandpath2bsml.pl",
      "name": "islandpath2bsml.pl - convert islandpath output to BSML",
      "synopsis": "USAGE: islandpath2bsml.pl \n        --input=/path/to/somefile.out \n        --output=/path/to/output.bsml\n      [ --project=aa1 ]",
      "description": "This script is used to convert the output from an Islandpath run into BSML.",
      "options": {
        "input": "Input .out file from a Islandpath search.",
        "debug": "Debug level.  Use a large number to turn on verbose debugging.",
        "log": "Log file",
        "output": "Output BSML file (will be created, or overwritten)",
        "project": "Project ID.  Used in creating feature ids.  Defaults to whatever the prefix of the\n    input file is (i.e. spntigr4.assembly.1.1 would be spntigr4).",
        "id_repository": "Required for creating feature identifiers.  Each project should have\n    its own id_repository directory - use the full path to it here.",
        "help": "This help message"
      },
      "contact": "David Riley driley@som.umaryland.edu =cut use strict; use Getopt::Long qw(:config no_ignore_case no_auto_abbrev); use Pod::Usage; use Ergatis::IdGenerator; use File::Basename; use Ergatis::Logger; use BSML::BsmlRepository; use BSML::BsmlBuilder; use BSML::BsmlParserTwig; my %options = (); my $results = GetOptions (\\%options, 'input|i=s', 'output|o=s', 'project|p=s', 'log|l=s', 'id_repository|r=s', 'command_id=s', ## passed by workflow 'logconf=s', ## passed by workflow (not used) 'debug=s', 'help|h') || pod2usage(); my $logfile = $options{'log'} || Ergatis::Logger::get_default_logfilename(); my $logger = new Ergatis::Logger('LOG_FILE'=>$logfile, 'LOG_LEVEL'=>$options{'debug'}); $logger = $logger->get_logger(); # display documentation if( $options{'help'} ){ pod2usage( {-exitval=>0, -verbose => 2, -output => \\*STDOUT} ); } ## make sure all passed options are peachy &check_parameters(\\%options); ## we want a new doc my $doc = new BSML::BsmlBuilder(); ## we're going to generate ids my $idcreator = new Ergatis::IdGenerator( id_repository => $options{id_repository} ); ## Let's pull the sequence ID out of the filename my $seq_id = basename($options{'input'}, '.out'); my $prefix = $seq_id; if($seq_id =~ /([^\\.]+)\\..*/) { $prefix = $1; } my $project = $options{project} ? $options{project} : $prefix; ## first we'll add the sequence element my $seq = $doc->createAndAddSequence($seq_id, undef, '', 'dna', 'assembly'); $seq->addBsmlLink('analysis', '#islandpath_analysis', 'input_of'); my $ft = $doc->createAndAddFeatureTable($seq); ## open the input file for parsing open (my $ifh, $options{'input'}) || $logger->logdie(\"can't open input file for reading\"); my %data; while (<$ifh>) { my ($start, $stop) = split(/\\s+/, $_); if(defined($start) && defined($stop)) { ## add the island my $id = $idcreator->next_id( project => $project, type => 'pathogenic_island' ); my $island = $doc->createAndAddFeature($ft, $id, '', 'pathogenic_island'); $island->addBsmlLink('analysis', '#islandpath_analysis', 'computed_by'); ## add the location of the repeat ## 1 is subtracted from each position to give interbase numbering if($start < $stop) { $island->addBsmlIntervalLoc( $start, $stop, 0); } else { $island->addBsmlIntervalLoc( $stop, $start, 1); } } } ## add the analysis element $doc->createAndAddAnalysis( id => 'islandpath_analysis', sourcename => dirname($options{'output'}), program => 'islandpath', algorithm => 'islandpath', programversion => 'current' ); ## now write the doc $doc->write($options{'output'}); exit; sub check_parameters { ## make sure input file exists if (! -e $options{'input'}) { $logger->logdie(\"input file $options{'input'} does not exist\") } return 1; }"
    },
    {
      "tool": "lipop",
      "converter_script": "lipop2bsml.pl",
      "name": "lipop2bsml.pl - Takes raw lipop output (short) and prints to bsml",
      "synopsis": "USAGE: lipop2bsml.pl\n       --input_file=/path/to/some/lipop.raw\n       --input_fasta=/path/to/polypeptide.fsa\n       --id_repository=/path/to/valid_id_repo/\n       --project=db1\n       --output=/path/to/lipop.bsml\n     [ --analysis_id=lipoP_analysis\n       --sourcename=/path/to/all_output_dir\n       --log=/path/to/file.log\n       --debug=4\n       --help\n     ]",
      "description": "Example input:\n\n    # gnmM04c.polypeptide.451723460.1 SpII score=34.6562 margin=19.0125 cleavage=19-20 Pos+2=S\n\n    Example output:\n    \n    <Sequence id=\"gnmM04c.polypeptide.451723460.1\" title=\"gnmM04c.polypeptide.451723460.1\" ...>\n      <Feature id=\"gnmM04c.lipoprotein_signal_peptide.3458954893.1\" ...>\n         <Interval-loc startpos=\"0\" endpos=\"19\" complement=\"0\">\n      </Feature>\n      <Feature id=\"gnmM04c.cleavage_site.54890549.1\" ...>\n         <Site-loc sitepos=\"19\" complement=\"0\"></Site-loc>\n      </Feature>\n    </Sequence>",
      "options": {
        "input_file": "Raw output from a LipoP run (using the -short option)",
        "input_fasta": "The input fasta file used to generate the lipop output",
        "id_repository": "A valid id repository (used for Ergatis::IdGenerator)",
        "project": "The project (database name).  Used in id generation",
        "output": "Path to the output bsml file",
        "analysis_id": "Optional. Default = lipoP_analysis",
        "sourcename": "Optional. Path to where the output for the analysis was located (raw output). \n    Default is parse the directory from the input_file (and traverse 2 dirs up)",
        "log": "Logfile.",
        "help": "Print this message"
      },
      "contact": "Kevin Galens kgalens@som.umaryland.edu =cut use strict; use warnings; use Getopt::Long qw(:config no_ignore_case no_auto_abbrev pass_through); use BSML::BsmlBuilder; use Ergatis::IdGenerator; use File::OpenFile qw(open_file); use Pod::Usage; my $options = &check_options(); my $idgen; my $analysis_id = \"lipop_analysis\"; my $sourcename; #grab the input my $in = open_file( $options->{'input_file'}, 'in' ); chomp( my @lines = <$in> ); close($in); #there should only be one line #if( @lines != 1 ) { # die(\"There should only be one line in the LipoP raw output when the -short option is used\"); #} my $doc = new BSML::BsmlBuilder; while (scalar(@lines) >0) { my (undef, $id, $type, $score, $margin, $cleavage, $pos) = split( /\\s+/, shift @lines ); my $seq = $doc->createAndAddSequence( $id, $id, '', 'aa', 'polypeptide' ); #validate the input fasta file to make sure it contains the sequence we are looking for &validate_input_fasta( $options->{'input_fasta'}, $id ); #create the seq data import and analysis link my $sdi = $doc->createAndAddSeqDataImport( $seq, 'fasta', $options->{'input_fasta'}, '', $id ); my $s_link = $doc->createAndAddLink( $seq, 'analysis', '#'.$analysis_id, 'input_of' ); #we are only encoding the cleavage site predictions (type either SpI or SpII) if( $type eq 'SpI' || $type eq 'SpII' ) { #add a feature table my $ft = $doc->createAndAddFeatureTable( $seq ); ## SpI is a signal peptide my $signal_peptide_type; if( $type eq 'SpI' ) { $signal_peptide_type = 'signal_peptide'; ## SpII is a lipoprotein signal peptide } elsif( $type eq 'SpII' ) { $signal_peptide_type = 'lipoprotein_signal_peptide'; } #create the signal peptide feature, interval loc and analysis link my $sp_id = $idgen->next_id( 'type' => $signal_peptide_type, 'project' => $options->{'project'} ); my $sp_feat = $doc->createAndAddFeature( $ft, $sp_id, $sp_id, $signal_peptide_type ); my $endpos = $1 if( $cleavage =~ /(\\d+)-(\\d+)/ ); my $sp_il = $doc->createAndAddIntervalLoc( $sp_feat, 0, $endpos, 0 ); my $sp_link = $doc->createAndAddLink( $sp_feat, 'analysis', \"#\".$analysis_id, 'computed_by' ); #create the cleavage site feature, site loc, and analysis link my $cs_id = $idgen->next_id( 'type' => 'cleavage_site', 'project' => $options->{'project'} ); my $cs_feat = $doc->createAndAddFeature( $ft, $cs_id, $cs_id, 'cleavage_site' ); my $cs_sl = $doc->createAndAddSiteLoc( $cs_feat, $endpos, 0 ); my $cs_link = $doc->createAndAddLink( $cs_feat, 'analysis', '#'.$analysis_id, 'computed_by' ); } } #add the analysis my $an = $doc->createAndAddAnalysis( 'id' => $analysis_id, 'algorithm' => 'lipoP', 'sourcename' => $sourcename, 'program' => 'lipoP', 'programversion' => 'current'); #write the bsml file $doc->write( $options->{'output'} ); print \"Finished writing $options->{'output'}\\n\"; sub validate_input_fasta { my ($file, $id) = @_; my $in = open_file( $file, 'in' ); my $found = 0; while( <$in> ) { if( /^>(\\S+)/ ) { if( $1 eq $id ) { $found = 1; last; } } } close($in); die(\"Could not find sequence for $id in $file\") unless( $found ); } sub check_options { my %options; my $results = GetOptions (\\%options, 'input_file|i=s', 'input_fasta|f=s', 'id_repository|d=s', 'project|p=s', 'output|o=s', 'analysis_id|a=s', 'sourcename|s=s', 'log|l=s', 'help|h', ); if( $options{'help'} ) { &_pod; } my @reqs = qw( input_file input_fasta id_repository project output ); foreach my $req ( @reqs ) { die(\"Option $req is required\") unless( $options{$req} ); } # create IdGenerator. Not setting pooling because there will only be a max of one id # of each type generated $idgen = new Ergatis::IdGenerator( 'id_repository' => $options{'id_repository'} ); #if analysis_id was specified, replace the default $analysis_id = $options{'analysis_id'} if( $options{'analysis_id'} ); #parse the sourcename if it was not specified if( $options{'sourcename'} ) { $sourcename = $options{'sourcename'}; } else { $sourcename = $1 if( $options{'input_file'} =~ m|(.*)/[^/]+/[^/]+/.*| ); die(\"Could not parse sourcename out of input_file [$options{'input_file'}]\") unless( $sourcename ); } return \\%options; } sub _pod { pod2usage( {-exitval => 0, -verbose => 2, -output => \\*STDERR} ); }"
    },
    {
      "tool": "metagene",
      "converter_script": "metagene2bsml.pl",
      "name": "metagene2bsml.pl  - converts raw metagene output into BSML",
      "synopsis": "USAGE:  metagene2bsml.pl -i raw_metagene_output.txt -f /path/to/fasta_input.fsa -o /path/to/outfile.bsml [-l /path/to/logfile.log] --project project_name --id_repository /path/to/id_repository",
      "description": "Create BSML document from metagene output. Will extract nucleotide sequences for the\npredicted ORFs.",
      "options": {
        "input_file": "The input raw output from metagene.",
        "fasta_input": "The full path to the fasta sequence file that was input to metagene.",
        "output": "The full path to the BSML output file to be created.",
        "debug": "Debug level.  Use a large number to turn on verbose debugging.",
        "log": "Log file",
        "help": "This help message"
      },
      "contact": "Brett Whitty bwhitty@tigr.org =cut use strict; use warnings; use Getopt::Long qw(:config no_ignore_case no_auto_abbrev); use Pod::Usage; use File::Basename; use Chado::Gene; use BSML::GenePredictionBsml; use Ergatis::IdGenerator; use Ergatis::Logger; my %options = (); my $results = GetOptions (\\%options, 'input_file|i=s', 'fasta_input|f=s', 'output_directory=s', 'output|o=s', 'num_seqs|n=s', 'cutoff:s', 'id_repository=s', 'analysis_id=s', 'project=s', 'log|l=s', 'debug=s', 'help|h') || pod2usage(); my $logfile = $options{'log'} || Ergatis::Logger::get_default_logfilename(); my $logger = new Ergatis::Logger('LOG_FILE'=>$logfile, 'LOG_LEVEL'=>$options{'debug'}); $logger = $logger->get_logger(); if ($options{'help'}) { pod2usage(verbose => 2); } if (! $options{'analysis_id'}) { $options{'analysis_id'} = 'metagene_analysis'; } if (!$options{'id_repository'}) { pod2usage(\"must provided --id_repository\"); } if (!$options{'project'}) { pod2usage(\"project name must be provided with --project\"); } my $id_gen = Ergatis::IdGenerator->new('id_repository' => $options{'id_repository'}); unless ($options{'cutoff'} =~ /\\d+/) { $logger->warn(\"Cutoff parameter not correctly formatted, skipping use.\"); undef $options{'cutoff'}; } unless ($options{'input_file'}) { pod2usage(\"raw metagene output must be provided with --input_file\"); } unless ($options{'output'}) { pod2usage(\"must specify an output prefix with --output\"); } my $output_dir = $options{'output_directory'} || ''; if ($output_dir eq '') { $output_dir = '.'; } my $output_fsa_file = $output_dir.\"/\".basename($options{'output'}, \".bsml\").\".fsa\"; my $orfs = {}; $options{'num_seqs'} = 1 if(!defined $options{'num_seqs'}); my $in_fh; open $in_fh,\"$options{'input_file'}\"; my $orf_count = 0; my $seq_id; while (<$in_fh>) { chomp; if($_ =~ /^\\#\\s+(\\S+)/){ if($1 ne 'gc' && $1 ne 'self:'){ print $1,\" \",scalar(keys %$orfs),\" $orf_count\\n\"; $seq_id = $1; } } else{ my @elts = split(\"\\t\", $_); if(scalar (@elts) == 11){ my ($geneid, $startpos, $endpos, $strand, $frame, $complete, $genescore, $usedmodel, $rbsstart, $rbsend, $rbsscore ) = @elts; ## if the user has supplied a cutoff size we want to toss out any ## ORFS that are shorter than it my $orf_len = $endpos - $startpos; next if ( ( defined($options{'cutoff'}) ) && ($orf_len < $options{'cutoff'}) ); ## set flags for partial ORFs my ($five_prime_partial, $three_prime_partial) = split(//,$complete); ## we need to add the frame to either the startpos or endpos depending on the ## strand we are one if ($strand eq '+') { $startpos += $frame; } elsif ($strand eq '-') { $endpos -= $frame; } push (@{$orfs->{$seq_id}}, { 'model' => $usedmodel, 'startpos' => $startpos, 'endpos' => $endpos, 'complement' => ($strand eq '+') ? 0 : 1, 'frame' => $frame, 'score' => $genescore, '5_partial' => $five_prime_partial, '3_partial' => $three_prime_partial, 'orf_id' => $geneid }); $orf_count++; } else{ print $_,\"\\n\"; } } } if ($orf_count == 0) { $logger->warn(\"No ORF's found in BSML file.\"); exit 0; } $id_gen->set_pool_size('ORF' => $orf_count, 'CDS' => $orf_count); my $orfcount=0; my $doc = new BSML::GenePredictionBsml( 'metagene', $options{'fasta_input'} ); my @bsmldocs; my $numseqs=0; my $outputnum=0; foreach my $seq_id (keys(%{$orfs})) { if($numseqs >= $options{'num_seqs'}){ $outputnum++; my $ofile = $output_dir.\"/\".$options{'output'}.\".$outputnum.bsml\"; print \"Writing BSML file $outputnum\\n\"; $doc->writeBsml($ofile); $doc = new BSML::GenePredictionBsml( 'metagene', $options{'fasta_input'} ); $numseqs = 1; } my $addedTo = $doc->setFasta($seq_id, $options{'fasta_input'}); die \"$seq_id was not a sequence associated with the gene\" unless($addedTo); my @orfs; foreach my $orf (@{$orfs->{$seq_id}}) { my $orf_id = $id_gen->next_id( 'type' => 'gene', 'project' => $options{'project'} ); $orf->{'id'} = $orf_id; #Create some genes and push them ontot he $genes array my $tmp = new Chado::Gene( $orf_id, $orf->{'startpos'}-1, $orf->{'endpos'}, ($orf->{'complement'} > 0) ? 1 : 0, $seq_id); foreach my $type(qw(exon CDS transcript polypeptide)) { my $type_id = $id_gen->next_id( 'type' => $type, 'project' => $options{'project'} ); $tmp->addFeature($type_id, $orf->{'startpos'}-1, $orf->{'endpos'}, ($orf->{'complement'} > 0) ? 1 : 0, $type); } my $count = $tmp->addToGroup($tmp->getId, { 'all' => 1 }); $doc->addGene($tmp); my $addedTo = $doc->addSequence($tmp->{'seq'}, $options{'fasta_input'} ); } $numseqs++; } $outputnum++; my $ofile = $output_dir.\"/\".$options{'output'}.\".$outputnum.bsml\"; print \"Writing final BSML for $outputnum\\n\"; $doc->writeBsml($ofile);"
    },
    {
      "tool": "mreps",
      "converter_script": "mreps2bsml.pl",
      "name": "mreps2bsml.pl - convert mreps output to BSML",
      "synopsis": "USAGE: mreps2bsml.pl \n            --input=/path/to/somefile.dat \n            --output=/path/to/output.bsml\n          [ --project=aa1 ]",
      "description": "This script is used to convert the output from an mreps search into BSML.",
      "options": {
        "input": "Input .raw file from an mreps search.",
        "debug": "Debug level.  Use a large number to turn on verbose debugging.",
        "log": "Log file",
        "output": "Output BSML file (will be created, must not exist)",
        "project": "Project ID.  Used in creating feature ids.  Defaults to 'unknown' if\n    not passed.",
        "help": "This help message"
      },
      "contact": "Jason Inman jinman@tigr.org =cut use strict; use Getopt::Long qw(:config no_ignore_case no_auto_abbrev); use Pod::Usage; BEGIN { use Ergatis::Logger; use BSML::BsmlRepository; use Papyrus::TempIdCreator; use BSML::BsmlBuilder; use BSML::BsmlParserTwig; } my %options = (); my $results = GetOptions (\\%options, 'input|i=s', 'output|o=s', 'debug|d=s', 'command_id=s', ## passed by workflow 'logconf=s', ## passed by workflow (not used) 'project|p=s', 'log|l=s', 'help|h') || pod2usage(); my $logfile = $options{'log'} || Ergatis::Logger::get_default_logfilename(); my $logger = new Ergatis::Logger('LOG_FILE'=>$logfile, 'LOG_LEVEL'=>$options{'debug'}); $logger = $logger->get_logger(); # display documentation if( $options{'help'} ){ pod2usage( {-exitval=>0, -verbose => 2, -output => \\*STDOUT} ); } ## make sure all passed options are peachy &check_parameters(\\%options); ## we want to create ids unique to this document, which will be replaced later. they must ## contain the prefix that will be used to look up a real id, such as ath1.gen.15 my $next_id = 1; ## we want a new doc my $doc = new BSML::BsmlBuilder(); ## we're going to generate ids my $idcreator = new Papyrus::TempIdCreator(); ## open the input file for parsing open (my $ifh, $options{'input'}) || $logger->logdie(\"can't open input file for reading\"); my @data; my $qry_id; my $parameters; while (<$ifh>) { ## Remove any preceding whitespace chomp; $_ =~ s/^\\s*//; # Capture the header if this is that line: if (/Processing sequence '(.*)'/) { $qry_id = $1; } ## only the data lines in the output file start with numbers if ( /^\\d/ ) { # Due to the tricky formating of the output, let's force the split # to create 9 elements in the array. We'll just ignore certain columns. my @cols = split(/\\s+/,$_,9); ## add this data row to this sequence push( @data, \\@cols ); } } ## set up the bsml for the sequence my $seq = $doc->createAndAddSequence($qry_id, undef, '', 'dna', 'assembly'); $seq->addBsmlLink('analysis', '#mreps_analysis', 'input_of'); my $ft = $doc->createAndAddFeatureTable($seq); my $fg; ## loop through each array reference now my $repeat; my @elements; foreach my $arr ( @data ) { ## grab an ID my $new_id = $idcreator->new_id( db => $options{project}, so_type => 'tandem_repeat', prefix => $options{command_id} ); ## add the repeat $repeat = $doc->createAndAddFeature($ft, $new_id, '', $idcreator->so_used('tandem_repeat') ); $repeat->addBsmlLink('analysis', '#mreps_analysis', 'computed_by'); ## add the location of the repeat (all given by mreps as coords are on the forward strand) ## 1 is subtracted from each position to give interbase numbering $repeat->addBsmlIntervalLoc( --$$arr[0], --$$arr[2], 0); ## Adjust the vlaues in period and exponent cells to take them out of the silly ## brackets. Also strip out the spaces since we know the periodicity and exponent. $$arr[5] =~ s/<(.*)>/$1/; $$arr[6] =~ s/\\[(.*)\\]/$1/; $$arr[8] =~ tr/ //d; ## SO terms for these repeats need to be added as Attributes $doc->createAndAddBsmlAttributes( $repeat, 'period_size', $$arr[5], 'exponent', $$arr[6], 'consensus_size', $$arr[4], 'err-rate', $$arr[7], 'repeat_sequence', $$arr[8], ); } ## add the analysis element my $analysis = $doc->createAndAddAnalysis( id => 'mreps_analysis', sourcename => $options{'output'}, ); ## now write the doc $doc->write($options{'output'}); exit; sub check_parameters { ## make sure input file exists if (! -e $options{'input'}) { $logger->logdie(\"input file $options{'input'} does not exist\") } ## make sure output file doesn't exist yet if (-e $options{'output'}) { $logger->logdie(\"can't create $options{'output'} because it already exists\") } $options{'project'} = 'unknown' unless ($options{'project'}); $options{'command_id'} = '0' unless ($options{'command_id'}); return 1; }"
    },
    {
      "tool": "mummer",
      "converter_script": "mummer2bsml.pl",
      "name": "mummer2bsml.pl  - convert info stored in mummer coord files into BSML documents",
      "synopsis": "USAGE:  mummer2bsml.pl -m mummer_coord.txt -o nucmer.bsml -t 1",
      "description": "mummer2bsml.pl is designed to convert information in mummer coordinate\nfiles into BSML documents.  The user can specify which type of mummer\nfiles to convert by --mummer_type(t) flag. \n\nSamples:\n\n1. convert nucmer coordinate files \"nucmer_coord.txt\" into BSML doc \n\n   mummer2bsml.pl -m nucmer_coord.txt -o nucmer.bsml -t 3 \n\nNOTE:  \n\nCalling the script name with NO flags/options or --help will display the syntax requirement.\n\n\n=cut\n\n\nuse strict;\nuse Getopt::Long qw(:config no_ignore_case no_auto_abbrev);\nuse English;\nuse File::Basename;\nuse Pod::Usage;\nBEGIN {\nuse Ergatis::Logger;\nuse BSML::BsmlBuilder;\nuse BSML::BsmlParserTwig;\n}\n\nmy %options = ();\nmy $results = GetOptions (\\%options, \n\t\t\t  'mummer_coords|m=s', \n\t\t\t  'mummer_type|t=s', \n\t\t\t  'output|o=s', \n\t\t\t  'database|d=s', \n\t\t\t  'log|l=s',\n\t\t\t  'debug=s',\n\t\t\t  'class|c=s',\n\t\t\t  'help|h') || pod2usage();\n\n\nmy $logfile = $options{'log'} || Ergatis::Logger::get_default_logfilename();\nmy $logger = new Ergatis::Logger('LOG_FILE'=>$logfile,\n\t\t\t\t  'LOG_LEVEL'=>$options{'debug'});\n\n$logger = Ergatis::Logger::get_logger();\n\n&check_parameters(\\%options);\n\nmy $class;\nif (!defined($options{'class'})){\n    $logger->logdie(\"class was not defined\");\n}\nelse{\n    $class = $options{'class'};\n}\n\n\nmy $doc = BSML::BsmlBuilder->new();\nif($options{'mummer_type'} == 1) {\n    parse_promer_full_coords($options{'mummer_coords'});\n}elsif($options{'mummer_type'} == 2) {\n    parse_mummer_collapsed_coords($options{'mummer_coords'});\n}\nelsif($options{'mummer_type'} == 3) {\n    parse_nucmer_full_coords($options{'mummer_coords'});\n}else {\n    $logger->logdie(\"Bad options{'mummer_type'} $options{'mummer_type'}\");\n}\n\n$doc->write($options{'output'});\n\nsub parse_mummer_collapsed_coords {\n\n    my $coords_file = shift;\n\n    my @mummer;\n    open (MUMMER, $coords_file) or die \"Unable to open \\\"$coords_file\\\" due to $!\";\n    while (my $line = <MUMMER>) {\n\tchomp($line);\n\t@mummer = split(\"\\t\", $line);\t\n\t#In Mummer ref seq refers to query\n\n\tmy $ref_start   = $mummer[0];\n\tmy $ref_end     = $mummer[1];\n\tmy $qry_start   = $mummer[2];\n        my $qry_end     = $mummer[3];\n\tmy $ref_length  = $mummer[4];\n\tmy $qry_length  = $mummer[5];\n\tmy $ref_asmbl_length = $mummer[6];\n\tmy $qry_asmbl_length = $mummer[7];\n\tmy $ref_name    = $mummer[10];\n        my $qry_name    = $mummer[11];\n\n\t$qry_name =~ s/^$options{'database'}\\_//i; #strip leading database name for now\n\t$ref_name =~ s/^$options{'database'}\\_//i; #strip leading database name for now\n\n\tnext if($ref_name eq $qry_name);\n\n\tmy $complement= ($qry_start > $qry_end) ? 1 : 0;\n\tif($complement){\n\t    ($qry_start,$qry_end) = ($qry_end,$qry_start);\n\t}\n\tif($ref_start > $ref_end){\n\t    $logger->logdie(\"Unexpected reference coordinates $ref_start $ref_end\\n\");\n\t}\n\t$qry_start--;\n\t$ref_start--;\t\n\n\tmy $aln = $doc->createAndAddSequencePairAlignment( 'refseq'        => $ref_name,\n                                                       'compseq'       => $qry_name,\n                                                       'complength'    => $qry_asmbl_length,\n                                                       'reflength'     => $ref_asmbl_length,\n                                                       'class'         => 'match'\n                                                       ); \n\tmy $s = $doc->createAndAddSequencePairRun( 'alignment_pair'   => $aln,\n                                               'refpos'           => $ref_start,\n                                               'refcomplement'    => 0,\n                                               'runlength'        => $ref_length,\n                                               'comppos'          => $qry_start,\n                                               'comprunlength'    => $qry_length,\n                                               'compcomplement'   => $complement,\n                                               'class'            => 'match_part'\n                                                  );\n    }\n}\n\nsub parse_promer_full_coords {\n    my $coords_file = shift;\n\n    my @promer;\n    open (PROMER, $coords_file) or die \"Unable to open \\\"$coords_file\\\" due to $!\";\n    while (my $line = <PROMER>) {\n\tchomp($line);\n\t@promer = split(\"\\t\", $line);\t\n\t#In Promer ref seq refers to query\n        my $ref_name    = $promer[15];\n        my $qry_name    = $promer[16];\n\tmy $ref_start   = $promer[0];\n\tmy $ref_end     = $promer[1];\n\tmy $ref_length  = $promer[4];\n\tmy $qry_start   = $promer[2];\n        my $qry_end     = $promer[3];\n\tmy $qry_length  = $promer[5];\n\tmy $percent_id  = $promer[6];\n        my $percent_sim = $promer[7];\n\tmy $percent_stop = $promer[8];\n\tmy $qry_asmbl_length = $promer[10];\n        my $ref_asmbl_length = $promer[9];\n\tmy $frame_ref = $promer[13];\n        my $frame_qry = $promer[14];\n\t\n\t$qry_name =~ s/^$options{'database'}\\_//i; #strip leading database name for now\n\t$ref_name =~ s/^$options{'database'}\\_//i; #strip leading database name for now\n\n\tnext if($ref_name eq $qry_name);\n\n\tmy $complement= ($qry_start > $qry_end) ? 1 : 0;\n\tif($complement){\n\t    ($qry_start,$qry_end) = ($qry_end,$qry_start);\n\t}\n\tif($ref_start > $ref_end){\n\t    $logger->logdie(\"Unexpected reference coordinates $ref_start $ref_end\\n\");\n\t}\n\t$qry_start--;\n\t$ref_start--;\t\n\n\tmy $aln = $doc->createAndAddSequencePairAlignment( 'refseq'        => $ref_name,\n\t\t\t\t\t\t\t   'compseq'       => $qry_name,\n                                                           'complength'    => $qry_asmbl_length,\n                                                           'reflength'     => $ref_asmbl_length,\n\t\t\t\t\t\t\t   'class'         => $class\n\t\t\t\t\t\t\t ); \n\tmy $s = $doc->createAndAddSequencePairRun( 'alignment_pair'   => $aln,\n\t\t\t\t\t\t   'refpos'           => $ref_start,\n\t\t\t\t\t\t   'refcomplement'    => 0,\n\t\t\t\t\t\t   'runlength'        => $ref_length,\n\t\t\t\t\t\t   'comppos'          => $qry_start,\n\t\t\t\t\t\t   'comprunlength'    => $qry_length,\n\t\t\t\t\t\t   'compcomplement'   => $complement\n                                                  );\n\t#additional attributes\n\t$s->addBsmlAttr( 'percent_identity',  $percent_id);\n\t$s->addBsmlAttr( 'percent_similarity', $percent_sim);\n\t$s->addBsmlAttr( 'percent_stop',  $percent_stop);\n\t$s->addBsmlAttr( 'ref_frame', $frame_ref );\n\t$s->addBsmlAttr( 'query_frame', $frame_qry );\n\n    }\n}\n\nsub parse_nucmer_full_coords {\n\n    my $coords_file = shift;\n\n    my @mummer;\n    open (NUCMER, $coords_file) or die \"Unable to open \\\"$coords_file\\\" due to $!\";\n    while (my $line = <NUCMER>) {\n\tchomp($line);\n\t@mummer = split(\"\\t\", $line);\n\t#In Mummer ref seq refers to query\n\tmy $ref_name = $mummer[11];\n        my $qry_name = $mummer[12];\n\tmy $ref_start = $mummer[0];\n\tmy $ref_end   = $mummer[1];\n\tmy $qry_start = $mummer[2];\n        my $qry_end   = $mummer[3];\n\tmy $ref_length = $mummer[4];\n\tmy $qry_length = $mummer[5];\n\tmy $percent_id = $mummer[6];\n        my $ref_asmbl_length = $mummer[7];\n\tmy $qry_asmbl_length = $mummer[8];\n\n\t$qry_name =~ s/^$options{'database'}\\_//i; #strip leading database name for now\n\t$ref_name =~ s/^$options{'database'}\\_//i; #strip leading database name for now\n\n\tnext if($ref_name eq $qry_name);\t\n\n\tmy $aln = $doc->createAndAddSequencePairAlignment( 'refseq'        => $ref_name,\n\t\t\t\t\t\t\t   'compseq'       => $qry_name,\n                                                           'complength'    => $qry_asmbl_length,\n                                                           'reflength'     => $ref_asmbl_length,\n\t\t\t\t\t\t\t   'class'         => $class\n\t\t\t\t\t\t\t ); \n\n\tmy $complement= ($qry_start > $qry_end) ? 1 : 0;\n\tif($complement){\n\t    ($qry_start,$qry_end) = ($qry_end,$qry_start);\n\t}\n\tif($ref_start > $ref_end){\n\t    $logger->logdie(\"Unexpected reference coordinates $ref_start $ref_end\\n\");\n\t}\n\t$qry_start--;\n\t$ref_start--;\n\n\tmy $s = $doc->createAndAddSequencePairRun( 'alignment_pair'   => $aln,\n\t\t\t\t\t\t   'refpos'           => $ref_start,\n\t\t\t\t\t\t   'refcomplement'    => 0,\n \t\t\t\t\t\t   'runlength'        => $ref_length,\n\t\t\t\t\t\t   'comppos'          => $qry_start,\n\t\t\t\t\t\t   'comprunlength'    => $qry_length,\n\t\t\t\t\t\t   'compcomplement'   => $complement\n\t\t\t\t\t\t   );\n\t$s->addBsmlAttr( 'percent_identity',  $percent_id);\n    }\n}\n\n\nsub check_parameters{\n    my ($options) = @_;\n    \n    if(!$options{'mummer_coords'} or !$options{'mummer_type'} or !$options{'output'}) {\n\tpod2usage({-exitval => 2,  -message => \"$0: All the required options are not specified\", -verbose => 1, -output => \\*STDERR});    \n    }\n\n\n    if($options{'mummer_type'} != '1' and $options{'mummer_type'} != '2' and $options{'mummer_type'} != '3') {\n\tpod2usage({-exitval => 2,  -message => \"$0: mummer_type can only be 1 or 2\", -verbose => 1, -output => \\*STDERR}); \n    }\n}",
      "options": {},
      "contact": null
    },
    {
      "tool": "nap",
      "converter_script": "nap2bsml.pl",
      "name": "nap2bsml.pl - convert nap btab output to BSML",
      "synopsis": "USAGE: nap2bsml.pl \n    --input=/path/to/somefile.nap.btab \n    --output=/path/to/somefile.nap.bsml",
      "description": "This script is used to convert the btab output from a nap search into BSML.",
      "options": {
        "input": "Input btab file from a nap search.",
        "query_file_path": "Full path to FASTA file containing query sequence.",
        "query_id": "ID of query sequence",
        "cutoff_identity": "Filter results on % identity (exclude < cutoff).",
        "cutoff_similarity": "Filter results on % similarity (exclude < cutoff).",
        "debug": "Debug level.  Use a large number to turn on verbose debugging.",
        "log": "Log file",
        "output": "Output BSML file",
        "qzip_output": "Optional.  A non-zero value will make compressed output.",
        "help": "This help message"
      },
      "contact": "Joshua Orvis jorvis@users.sf.net =cut use strict; use Getopt::Long qw(:config no_ignore_case no_auto_abbrev); use Pod::Usage; use Ergatis::Logger; use BSML::BsmlRepository; use BSML::BsmlBuilder; use BSML::BsmlParserTwig; my $qfDefline; my %options = (); my $results = GetOptions (\\%options, 'input|i=s', 'query_file_path|q=s', 'query_id=s', 'output|o=s', 'gzip_output|g=s', 'cutoff_identity:s', 'cutoff_similarity:s', 'log|l=s', 'debug=s', 'help|h') || pod2usage(); my $logfile = $options{'log'} || Ergatis::Logger::get_default_logfilename(); my $logger = new Ergatis::Logger('LOG_FILE'=>$logfile, 'LOG_LEVEL'=>$options{'debug'}); $logger = $logger->get_logger(); # display documentation if( $options{'help'} ){ pod2usage( {-exitval=>0, -verbose => 2, -output => \\*STDOUT} ); } ## make sure all passed options are peachy &check_parameters(\\%options); ## we want a new doc my $doc = new BSML::BsmlBuilder(); ## open the input file for parsing my $ifh; if($options{'input'} =~ /\\.gz$/) { open ($ifh, \"<:gzip\", $options{'input'}) || $logger->logdie(\"can't open input file for reading\"); } else { open ($ifh, $options{'input'}) || $logger->logdie(\"can't open input file for reading\"); } ## each chainID = one Seq-pair-alignment ## each chain segment = one Seq-pair-run my %seqs_found; ## this hash will hold the chainIDs as their key and a reference to its Seq-pair-alignment my %chains; while (<$ifh>) { ## ignore whitespace lines next if ( /^\\s*$/ ); chomp; ## there should be 19 elements in cols, unless we have an unrecognized format. my @cols = split(\"\\t\"); unless (scalar @cols == 19) { $logger->error(\"the following nap btab line was not recognized and could not be parsed (should have 19 columns, actually has \" . scalar(@cols) . \"):\\n$_\\n\") if ($logger->is_error); next; } if ($options{'cutoff_identity'} && $cols[10] < $options{'cutoff_identity'}) { next; } if ($options{'cutoff_similarity'} && $cols[11] < $options{'cutoff_similarity'}) { next; } my ($qry_id, $sbj_id) = ($cols[0], $cols[5]); ## the qry ID only counts up to the first whitespace if ($qry_id =~ /(.+?)\\s+/) { $qry_id = $1; } ## has this query sequence been added to the doc yet? if (! exists $seqs_found{$qry_id}) { my $seq = $doc->createAndAddSequence($qry_id, $cols[0], undef, 'na', 'assembly'); $doc->createAndAddSeqDataImport($seq, 'fasta', $options{'query_file_path'}, '', $cols[0]); $seq->addBsmlLink('analysis', '#aat_aa_analysis', 'input_of'); $seq->addBsmlAttr('defline', $qfDefline) if($qfDefline); $seqs_found{$qry_id} = 1; } ## BioPerl is introducing CTRL-A characters as separators now, which kills the XML. # replace with three spaces $cols[15] =~ s/\\cA/ /g; ## has this subject sequence been added to the doc yet? if (! exists $seqs_found{$sbj_id}) { my $seq = $doc->createAndAddSequence($sbj_id, $cols[5], undef, 'aa', 'polypeptide'); $seq->addBsmlAttr( 'defline', \"$cols[5] $cols[15]\" ); $doc->createAndAddSeqDataImport($seq, 'fasta', $cols[4], '', $cols[5]); $doc->createAndAddCrossReferencesByParse( sequence => $seq, string => $cols[5]); $seqs_found{$sbj_id} = 1; } my ($chainID, $segmentID) = ($cols[13], $cols[14]); ## if this combination doesn't exist yet, create its Seq-pair-alignment if (! exists $chains{$chainID}) { ## skipped attributes here are complength, compstart, compend, compxref, refxref and method $chains{$chainID} = $doc->createAndAddSequencePairAlignment( refseq => $qry_id, refxref => \":$qry_id\", refstart => 0, refend => $cols[2] - 1, reflength => $cols[2], compseq => $sbj_id, compxref => \"$cols[4]:$sbj_id\", class => 'match', ); $chains{$chainID}->addBsmlLink('analysis', '#aat_aa_analysis', 'computed_by'); ## add the total_score (will be the same for each matching segment) $doc->createAndAddBsmlAttribute($chains{$chainID}, 'total_score', $cols[18]); } ## now add the Seq-pair-run ## skipped attributes are runprob my $run = $doc->createAndAddSequencePairRun( alignment_pair => $chains{$chainID}, runscore => $cols[12], runlength => abs($cols[7] - $cols[6]) + 1, comprunlength => abs($cols[9] - $cols[8]) + 1, refpos => min($cols[6], $cols[7]) - 1, refcomplement => $cols[17] eq 'Minus' ? 1 : 0, comppos => min($cols[8], $cols[9]) - 1, compcomplement => 0, ); $doc->createAndAddBsmlAttribute($run, 'class', 'match_part'); $doc->createAndAddBsmlAttribute($run, 'percent_identity', $cols[10]); $doc->createAndAddBsmlAttribute($run, 'percent_similarity', $cols[11]); $doc->createAndAddBsmlAttribute($run, 'chain_number', $chainID); $doc->createAndAddBsmlAttribute($run, 'segment_number', $segmentID); } ## if there were no results this will create a sequence stub my $align = &createAndAddNullResult( doc => $doc, query_name => $options{'query_id'}, query_length => '', class => 'assembly', ); ## add the analysis element my $analysis = $doc->createAndAddAnalysis( id => 'aat_aa_analysis', sourcename => $options{'output'}, program => 'AAT-nap', algorithm => 'AAT-nap' ); ## now write the doc $doc->write($options{'output'}, '', $options{'gzip_output'}); exit; sub check_parameters { ## make sure input file exists if (! -e $options{'input'}) { $logger->logdie(\"input file $options{'input'} does not exist\") unless(-e \"$options{input}.gz\"); $options{'input'}.='.gz'; } ## make user an output file was passed if (! $options{'output'}) { $logger->logdie(\"output option required!\") } if($options{'query_file_path'}) { open(IN, \"< $options{'query_file_path'}\") or $logger->logdie(\"cannot open $options{query_file_path}\"); while(<IN>) { chomp; if(/^>(.*)/) { $qfDefline = $1; last; } } close(IN); } return 1; } sub min { my ($num1, $num2) = @_; if ($num1 < $num2) { return $num1; } else { return $num2; } } ##Adds BSML tags for the case where ##the query sequence returned no hits sub createAndAddNullResult { my %args = @_; my $doc = $args{'doc'}; if ( !( $doc->returnBsmlSequenceByIDR( \"$args{'query_name'}\")) ){ my $seq = $doc->createAndAddSequence( \"$args{'query_name'}\", \"$args{'query_name'}\", '', 'na', $args{'class'} ); $doc->createAndAddSeqDataImport($seq, 'fasta', $options{'query_file_path'}, '', $args{'query_name'}); $seq->addBsmlLink('analysis', '#aat_aa_analysis', 'input_of'); } }"
    },
    {
      "tool": "panther",
      "converter_script": "panther2bsml.pl",
      "name": "panther2bsml.pl - convert panther raw output to BSML",
      "synopsis": "USAGE: panther2bsml.pl \n        --input=/path/to/somefile.panther.raw \n        --output=/path/to/somefile.panther.bsml\n        --query_file_path=/path/to/query.fasta.fsa\n        --gzip_output=1\n      [ --log=/path/to/some.log\n        --debug=4 \n        --help\n      ]",
      "description": "This script is used to convert the raw output from a panther search into BSML.",
      "options": {
        "input": "Input raw alignment file from an panther search.",
        "output": "Output BSML file",
        "query_file_path": "Full path to query sequence file used for Panther run.",
        "gzip_output": "A non-zero will result in compressed bsml output.  If there is not a .gz extension \n    on the output file name, one will be added.",
        "debug": "Debug level.  Use a large number to turn on verbose debugging.",
        "log": "Log file",
        "help": "This help message"
      },
      "contact": "Brett Whitty bwhitty@tigr.org =cut use strict; use Getopt::Long qw(:config no_ignore_case no_auto_abbrev); use Pod::Usage; use Ergatis::Logger; use File::Basename; use BSML::BsmlRepository; use BSML::BsmlBuilder; use BSML::BsmlParserTwig; my $defline; my %options = (); my $results = GetOptions (\\%options, 'input|i=s', 'output|o=s', 'query_file_path|q=s', 'gzip_output|g=s', 'log|l=s', 'debug=s', 'help|h') || pod2usage(); my $logfile = $options{'log'} || Ergatis::Logger::get_default_logfilename(); my $logger = new Ergatis::Logger('LOG_FILE'=>$logfile, 'LOG_LEVEL'=>$options{'debug'}); $logger = $logger->get_logger(); # display documentation if( $options{'help'} ){ pod2usage( {-exitval=>0, -verbose => 2, -output => \\*STDOUT} ); } ## make sure all passed options are peachy &check_parameters(\\%options); my $infile = basename($options{'input'}); my $query_id = ''; if ($infile =~ /^(.*)\\.panther\\.raw/) { $query_id = $1; } else { $logger->logdie(\"bad input file '$options{input}'\"); } ## open the input file for parsing open (my $ifh, $options{'input'}) || $logger->logdie(\"can't open input file for reading\"); ## we want a new doc my $doc = new BSML::BsmlBuilder(); ## make sure the name is legal my $query_id_orig = $query_id; $query_id =~ s/[^a-zA-Z0-9\\.\\-\\_]/_/g; ## add the query sequence file to the doc ## the use of 'aa' is not guaranteed here, but we're not using it anyway in loading my $seq = $doc->createAndAddSequence($query_id, $query_id_orig, undef, 'aa', 'polypeptide'); $doc->createAndAddSeqDataImport($seq, 'fasta', $options{'query_file_path'}, '', $query_id); $seq->addBsmlLink('analysis', \"#panther_analysis\", 'input_of'); $seq->addBsmlAttr('defline', $defline); my @panther_results = (); while (<$ifh>) { chomp; ## Panther raw format # sma1.model.48073_00236 PTHR23256:SF53 TYROSINE-PROTEIN KINASE-LIKE 7 5.9e-65 226.6 229-343,422-510,539-564,615-727,761-802,827-868, my @results = split(\"\\t\", $_); ## add this model sequence my $seq = $doc->createAndAddSequence($results[1], $results[2], undef, 'aa', 'polypeptide'); my $seqPairAlignment = $doc->createAndAddSequencePairAlignment( refseq => $query_id, refstart => 0, compseq => $results[1], class => 'match', ); ## add a link element inside this seq-pair-alignment $seqPairAlignment->addBsmlLink('analysis', \"panther_analysis\", 'computed_by'); ## add the total_score and total_eval for this pair $doc->createAndAddBsmlAttribute($seqPairAlignment, 'total_score', $results[4]); $doc->createAndAddBsmlAttribute($seqPairAlignment, 'total_e_value', $results[3]); my $segments = pop(@results); $results[5] =~ s/\\,$//; my $seg_counter = 0; my $seg_total = scalar(split(\",\", $segments)); foreach my $segment(split(\",\", $segments)) { $seg_counter++; my ($startpos, $endpos) = split(\"-\", $segment); $startpos--; ## correct startpos for interbase my $run = $doc->createAndAddSequencePairRun( alignment_pair => $seqPairAlignment, runlength => ($endpos - $startpos), comprunlength => ($endpos - $startpos), refpos => $startpos, refcomplement => 0, comppos => 0, compcomplement => 0, ); ## add other attributes of the run $doc->createAndAddBsmlAttribute( $run, 'class', 'match_part'); $doc->createAndAddBsmlAttributes( $run, domain_num => $seg_counter, domain_of => $seg_total, ); } } close $ifh; ## add the analysis element $doc->createAndAddAnalysis( id => \"panther_analysis\", sourcename => $options{'output'}, ); ## now write the doc $doc->write($options{'output'}, '', $options{'gzip_output'}); exit; sub check_parameters { ## make sure input file exists if (! -e $options{'input'}) { $logger->logdie(\"input file $options{'input'} does not exist\") } ## make user an output file was passed if (! $options{'output'}) { $logger->logdie(\"output option required!\") } ## if the query fasta file was given, parse out the header line (defline). if($options{'query_file_path'}) { open(IN, \"< $options{query_file_path}\") or $logger->logdie(\"Unable to open $options{query_file} ($!)\"); while(<IN>) { chomp; if(/^>(.*)/) { $defline = $1; last; } } close(IN); } return 1; }"
    },
    {
      "tool": "pasagff3",
      "converter_script": "pasagff32bsml.pl",
      "name": "pasagff32bsml.pl",
      "synopsis": "USAGE: pasagff32bsml.pl\n           --input|-i\n           --output|-o\n           --project|-p\n           --help|-h",
      "description": "This script parses GFF output from PASA and writes it out \nas BSML suitable for import into CHADO DBs.",
      "options": {
        "input": "Input gff3 format file created by PASA.",
        "output": "Output BSML file name.",
        "project": "Project/database name used to create feature identifiers.",
        "help": "This help documentation"
      },
      "contact": "Brett Whitty bwhitty@tigr.org =cut use strict; use warnings; use Getopt::Long qw(:config no_ignore_case no_auto_abbrev); use Pod::Usage; use BSML::BsmlBuilder; my ($input, $help, $man, $output, $project, $id_repository, $analysis, $mapping); GetOptions ( 'help|h' => \\$help, 'man|m' => \\$man, 'output|o=s' => \\$output, 'input|i=s' => \\$input, 'analysis:s' => \\$analysis, 'mapping:s' => \\$mapping, ) || pod2usage(); &pod2usage({-exitval => 1, -verbose => 2, -output => \\*STDOUT}) if ($man); &pod2usage({-exitval => 1, -verbose => 1, -output => \\*STDOUT}) if ($help); if (!$input){ pod2usage(\"input gff_file was not defined with --input\"); } if (!$output){ pod2usage(\"output BSML filename was not defined with --output\"); } if ($mapping) { unless (-e $mapping) { pod2usage(\"Specified mapping file does not exist\"); } } $project =~ tr/A-Z/a-z/; if ($analysis) { $analysis = 'pasa_'.$analysis.'_analysis'; } else { $analysis = 'pasa_analysis'; } my $global_id_counter=0; my $nodes = {}; my @root_nodes = (); my %id_map; if ($mapping) { open (IN, $mapping) || die \"couldn't open mapping file for reading\"; while (<IN>) { chomp; my @t = split (\"\\t\", $_); $id_map{$t[0]} = $t[1]; } close IN; } open (IN, $input) || die \"couldn't open input file '$input'\"; while (<IN>) { chomp; if (/^#/) { #process header line } elsif (/^>/ || /^#.*fasta.*/i) { last; } else { my $record = parse_record($_); ## correct numbering for interbase (see parse_record) $record->{'_end'}++; ## if it has no parents it's a root node if (!$record->{'Parent'}) { push(@root_nodes, $record); } ## store records in a set of arrays indexed by ID if ($record->{'ID'}) { push(@{$nodes->{$record->{'ID'}}->{'records'}},$record); } } } close IN; my @chains; foreach my $node_id(keys(%{$nodes})) { my $chain; my $refstart; my $refend; foreach my $node_hash(@{$nodes->{$node_id}->{'records'}}) { if (!defined($refstart)) { $refstart = $node_hash->{'_start'}; $refend = $node_hash->{'_end'}; } if ($refstart > $node_hash->{'_start'}) { $refstart = $node_hash->{'_start'}; } if ($refend < $node_hash->{'_end'}) { $refend = $node_hash->{'_end'}; } my @comp = split(\" \", $node_hash->{'Target'}->[0]); $comp[1]--; # fix numbering for interbase if ($mapping) { if (!defined($id_map{$node_hash->{'_seqid'}})) { die \"mapping for refseq id '$node_hash->{_seqid}' was not defined\"; } $chain->{'refseq'} = $id_map{$node_hash->{'_seqid'}}; } else { $chain->{'refseq'} = $node_hash->{'_seqid'}; } $chain->{'compseq'} = $comp[0]; $chain->{'compdatabase'} = $node_hash->{'_source'}; $chain->{'compidentifier'} = $comp[0]; my $score = $node_hash->{'_score'} eq '.' ? '' : $node_hash->{'_score'}; push ( @{$chain->{'percent_identity'}}, $score ); push ( @{$chain->{'refpos'}}, $node_hash->{'_start'} ); push ( @{$chain->{'runlength'}}, $node_hash->{'_end'} - $node_hash->{'_start'} ); push ( @{$chain->{'refcomplement'}}, $node_hash->{'_strand'} ); push ( @{$chain->{'comppos'}}, $comp[1] ); push ( @{$chain->{'comprunlength'}}, $comp[2] - $comp[1] ); my $compcomplement = $comp[3] eq '+' ? 0 : 1; push ( @{$chain->{'compcomplement'}}, $compcomplement ); } $chain->{'refstart'} = $refstart; $chain->{'refend'} = $refend; $chain->{'reflength'} = $refend - $refstart; push (@chains, $chain); } my $doc = new BSML::BsmlBuilder(); foreach my $chain(@chains) { if( !( $doc->returnBsmlSequenceByIDR($chain->{'refseq'}) )){ my $seq = $doc->createAndAddSequence( $chain->{'refseq'}, # query sequence $chain->{'refseq'}, # query sequence '', # length 'dna', # mol-type 'assembly', # class ); $seq->addBsmlLink('analysis', '#'.$analysis, 'input_of'); } if( !( $doc->returnBsmlSequenceByIDR($chain->{'compseq'}) )){ my $seq = $doc->createAndAddSequence( $chain->{'compseq'}, #subject id $chain->{'compseq'}, #subject id '', #length 'dna', #mol-type 'processed_transcript', #class ); $seq->addBsmlLink('analysis', '#'.$analysis, 'input_of'); $doc->createAndAddCrossReference( 'parent' => $seq, 'database' => $chain->{'compdatabase'}, 'identifier' => $chain->{'compidentifier'}, # 'identifier-type' => '', ); } my $aln = $doc->createAndAddSequencePairAlignment( 'refseq' => $chain->{'refseq'}, 'refstart' => $chain->{'refstart'}, 'refend' => $chain->{'refend'}, 'reflength' => $chain->{'reflength'}, 'compseq' => $chain->{'compseq'}, 'class' => 'match', 'method' => 'PASA', ); $aln->addBsmlLink('analysis', '#'.$analysis, 'computed_by'); my $spr_count = scalar(@{$chain->{'refpos'}}); foreach (my $i=0; $i < $spr_count; $i++) { my $s = $doc->createAndAddSequencePairRun( 'alignment_pair' => $aln, 'refpos' => $chain->{'refpos'}->[$i], 'runlength' => $chain->{'runlength'}->[$i], 'comprunlength' => $chain->{'comprunlength'}->[$i], 'comppos' => $chain->{'comppos'}->[$i], 'refcomplement' => $chain->{'refcomplement'}->[$i], 'compcomplement' => $chain->{'compcomplement'}->[$i], ); $doc->createAndAddBsmlAttribute( $s, 'class', 'match_part' ); $doc->createAndAddBsmlAttribute( $s, 'percent_identity', $chain->{'percent_identity'}->[$i] ); } } # add the analysis element $doc->createAndAddAnalysis( id => $analysis, sourcename => $output, ); $doc->write($output); exit(); sub parse_record { my ($line) = @_; my $record = {}; my $attrib_hash = {}; my $record_id = ''; my $parent_id = ''; my @cols = split(\"\\t\"); ## adjust both positions so that we are numbering from zero $cols[3]--; $cols[4]--; ## change the + and - symbols in strand column to 0 and 1, respectively if ($cols[6] eq '+') { $cols[6] = 0; } elsif ($cols[6] eq '-') { $cols[6] = 1; } else { die(\"unknown value ($cols[6]) in strand column. expected + or -.\"); } $record->{'_seqid'} = $cols[0]; $record->{'_source'} = $cols[1]; $record->{'_type'} = $cols[2]; $record->{'_start'} = $cols[3]; $record->{'_end'} = $cols[4]; $record->{'_score'} = $cols[5]; $record->{'_strand'} = $cols[6]; $record->{'_phase'} = $cols[7]; my @attribs = split(\";\", $cols[8]); foreach my $attrib(@attribs) { my ($type, $val) = split(\"=\", $attrib); my @vals = split(\",\", $val); $record->{$type}=\\@vals; } if (!defined($record->{'ID'})) { #print STDERR \"no ID defined for record\\n\"; } else { $record->{'ID'} = $record->{'ID'}->[0]; } if (!defined($record->{'Parent'})) { #print STDERR \"no Parent attribute defined for record\\n\"; } else { foreach my $parent(@{$record->{'Parent'}}) { ## store record's hash reference as a child of Parent if (!defined($nodes->{$parent}->{'children'})) { $nodes->{$parent}->{'children'}->{$record->{'_type'}} = []; } push (@{$nodes->{$parent}->{'children'}->{$record->{'_type'}}},$record); } } return $record; }"
    },
    {
      "tool": "pe",
      "converter_script": "pe2bsml.pl",
      "name": "dummy.pl - do nothing",
      "synopsis": "USAGE:  dummy.pl --debug debug_level --log log_file",
      "description": "=cut\n\n\nuse strict;\nuse Getopt::Long qw(:config no_ignore_case no_auto_abbrev);\nuse Pod::Usage;\nBEGIN {\nuse BSML::BsmlRepository;\nuse Ergatis::Logger;\nuse BSML::BsmlBuilder;\nuse BSML::BsmlParserSerialSearch;\n}\n\nmy $qfPath;\nmy $defline;\nmy $identifier;\n\nmy %options = ();\nmy $results = GetOptions (\\%options, \n\t\t\t  'file|f=s',\n\t\t\t  'bsml_repository|b=s',\n              'query_file_path|q=s',\n\t\t\t  'output|o=s',\n\t\t\t  'num_hits|n=s',\n              'gzip_output|g=s',\n\t\t\t  'log|l=s',\n\t\t\t  'debug=s',\n\t\t\t  'class|c=s',\n\t\t\t  'help|h') || pod2usage();\n\nmy $logfile = $options{'log'} || Ergatis::Logger::get_default_logfilename();\nmy $logger = new Ergatis::Logger('LOG_FILE'=>$logfile,\n\t\t\t\t  'LOG_LEVEL'=>$options{'debug'});\n$logger = Ergatis::Logger::get_logger();\n\n# display documentation\nif( $options{'help'} ){\n    pod2usage( {-exitval=>0, -verbose => 2, -output => \\*STDERR} );\n}\n\n$options{'num_hits'} = 1 if(!$options{'num_hits'});\n\nmy $class;\nif (!defined($options{'class'})){\n    $logger->logdie(\"class was not defined\");\n}\nelse{\n    $class = $options{'class'};\n}\n\n\n&check_parameters(\\%options);\n\nmy $aalookup = &get_aa_lookup($options{'bsml_repository'});\n\nmy $doc = BSML::BsmlBuilder->new();\n\nmy $seq_pair = {};\n\nmy ($ClusterGeneCount, $ClusterGapCount, $ClusterScore, $ClusterId);\n\nopen (PE, \"$options{'file'}\") or die \"Unable to open \\\"$options{'file'}\\\" due to $!\";\nwhile (my $line = <PE> ) {\n    chomp($line);\n    my @pe = split(/\\s+/, $line);\n    if(@pe == 5) {\n\t#Encountered a cluster definition\n\t$ClusterGeneCount = $pe[0];\n\t$ClusterGapCount = $pe[1];\n\t$ClusterScore = $pe[2];\n\t$ClusterId = $pe[4];\n    } elsif(@pe == 4) {\n\tif(! (exists $seq_pair->{$pe[2]}->{$pe[3]})){\n\t    $seq_pair->{$pe[2]}->{$pe[3]} = [];\n\t}\n\tmy $length = $aalookup->{$pe[2]}->{'length'} || 0;\n\tmy $comprunlength = $aalookup->{$pe[3]}->{'length'} || 0;\n\tpush @{$seq_pair->{$pe[2]}->{$pe[3]}}, {\n\t    'start_query'    => 0,\n\t    'runlength'      => $length,\n\t    'comprunlength'  => $comprunlength,\n\t    'start_hit'      => 0,\n\t    'runscore'       => $ClusterScore,\n\t    'PEffect_Cluster_Id' => $ClusterId,\n\t    'PEffect_Cluster_Gap_Count' => $ClusterGapCount,\n\t    'PEffect_Cluster_Gene_Count' => $ClusterGeneCount \n\t    };\n    }\n}\n\nclose PE;\n\n$logger->debug(\"Created lookup with \",scalar(keys %$seq_pair),\" matches\") if($logger->is_debug());\n\nforeach my $query_name (keys %$seq_pair){\n    if($query_name ne \"GAP\"){\n\tforeach my $dbmatch_accession (keys %{$seq_pair->{$query_name}}){\n\t    if($dbmatch_accession ne \"GAP\"){\n\t\tif( !( $doc->returnBsmlSequenceByIDR($query_name) )){\n\t\t    $doc->createAndAddSequence($query_name,$query_name,$aalookup->{$query_name}->{'length'}, 'aa', $class );\n\t\t    my $seq = $doc->returnBsmlSequenceByIDR($query_name);\n            $seq->addBsmlAttr('defline', $defline) if($defline);\n            $doc->createAndAddSeqDataImport( $seq, 'fasta', $qfPath, '', $identifier) if($qfPath && $identifier);\n\t\t}\n\t\tif( !( $doc->returnBsmlSequenceByIDR($dbmatch_accession) )){\n\t\t    $doc->createAndAddSequence($dbmatch_accession,$dbmatch_accession,$aalookup->{$dbmatch_accession}->{'length'}, 'aa', $class );\n\t\t    my $seq = $doc->returnBsmlSequenceByIDR($dbmatch_accession);\n\t\t}\n\t\tmy $aln = $doc->createAndAddSequencePairAlignment( 'refseq'  => $query_name,\n                                                           'compseq' => $dbmatch_accession ,\n                                                           'class'   => 'match'\n\t\t\t\t\t\t\t\t   );\n\n\t    $aln->addBsmlLink('analysis', '#pe_analysis', 'computed_by');\t\n\t\tmy $runs = $seq_pair->{$query_name}->{$dbmatch_accession};\n\t\tmy $hitnum = 0;\n\t\tforeach my $run (sort {$b->{'runscore'} <=> $a->{'runscore'}} (@$runs)){\n\t\t    if($hitnum <$options{'num_hits'}){\n\t\t\tmy $s = $doc->createAndAddSequencePairRun( 'alignment_pair' => $aln,\n\t\t\t\t\t\t\t\t   'refpos'    => $run->{'start_query'},\n\t\t\t\t\t\t\t\t   'runlength'      => $run->{'runlength'},\n\t\t\t\t\t\t\t\t   'comprunlength'      => $run->{'comprunlength'},\n\t\t\t\t\t\t\t\t   'comppos'      => $run->{'start_hit'},\n\t\t\t\t\t\t\t\t   'runscore'       => $run->{'runscore'},\n\t\t\t\t\t\t\t\t   'refcomplement' => 0,\n\t\t\t\t\t\t\t\t   'compcomplement' => 0,\n\t\t\t\t\t\t\t\t   );\n\t\t\t#additional attributes\n            $s->addBsmlAttr( 'class', 'match_part');\n\t\t\t$s->addBsmlAttr( 'PEffect_Cluster_Id',  $run->{'PEffect_Cluster_Id'} );\n\t\t\t$s->addBsmlAttr( 'PEffect_Cluster_Gap_Count', $run->{'PEffect_Cluster_Gap_Count'} );\n\t\t\t$s->addBsmlAttr( 'PEffect_Cluster_Gene_Count', $run->{'PEffect_Cluster_Gene_Count'} );\n\t\t\t\n\t\t    }\n\t\t    $hitnum++;\n\t\t}\n\t    }\n\t}\n    }\n }\n\n$doc->createAndAddAnalysis(\n\t\t\t   id => \"pe_analysis\",\n\t\t\t   sourcename => $options{'output'},\n\t\t\t   );\n\n$doc->write($options{'output'}, '', $options{'gzip_output'});\n\nsub get_aa_lookup{\n    my($repository) = @_;\n    \n    my $bsmlrepo = new BSML::BsmlRepository('BSML_repository'=>$repository);\n    my ($files) = $bsmlrepo->list_bsml_files();\n\n    my $lookup = {};\n    foreach my $bsml_doc (@$files) {\n\tmy $seqParser = new BSML::BsmlParserSerialSearch( ReadFeatureTables => 0,\n\t\t\t\t\t\t\t  SequenceCallBack =>sub \n\t\t\t\t\t\t\t  {\n\t\t\t\t\t\t\t      my $seqRef = shift;\n\t\t\t\t\t\t\t      my $id = $seqRef->returnattr( 'id' );\n\t\t\t\t\t\t\t      my $type = $seqRef->returnattr( 'molecule' );\n\t\t\t\t\t\t\t      my $length = $seqRef->returnattr( 'length' );\n\t\t\t\t\t\t\t      if($type eq \"aa\"){\n\t\t\t\t\t\t\t\t  $logger->debug(\"Storing sequence $id in lookup with length $length\")  if($logger->is_debug());\n\t\t\t\t\t\t\t\t  $lookup->{$id}->{'length'} = $length;\n\t\t\t\t\t\t\t      }\n\t\t\t\t\t\t\t  }); \n\t\n\t\n\t$seqParser->parse($bsml_doc);\n    }\n    return $lookup;\n}\n\n\nsub check_parameters{\n    my ($options) = @_;\n\n    if($options{'query_file_path'}) {\n        $qfPath = $options{'query_file_path'};\n        open(IN, \"< $qfPath\") or \n            $logger->logdie(\"Unable to open query_file_path $options{'query_file_path'} ($!)\");\n        while(<IN>) {\n            if(/^>(.*)/) {\n                $defline = $1;\n                $identifier = $1 if($defline =~ /^([^\\s]+)/);\n                last;\n            }\n        }\n        close(IN);\n\n    }\n    \n    if(0){\n\tpod2usage({-exitval => 2,  -message => \"error message\", -verbose => 1, -output => \\*STDERR});    \n    }\n}",
      "options": {},
      "contact": null
    },
    {
      "tool": "pepstats",
      "converter_script": "pepstats2bsml.pl",
      "name": "pepstats2bsml.pl - convert EMBOSS pepstats output to BSML",
      "synopsis": "USAGE: pepstats2bsml.pl --input=/path/to/pepstats_out.raw --output=/path/to/output.bsml",
      "description": "This script is used to convert the output from pepstats into BSML.",
      "options": {
        "input": "Input file file from a pepstats run.",
        "debug": "Debug level.  Use a large number to turn on verbose debugging.",
        "log": "Log file",
        "output": "Output BSML file (will be created, must not exist)",
        "help": "This help message"
      },
      "contact": "Brett Whitty bwhitty@tigr.org =cut use Log::Log4perl qw(get_logger); use Getopt::Long qw(:config no_ignore_case no_auto_abbrev); use Pod::Usage; use Ergatis::Logger; use BSML::BsmlBuilder; use warnings; use strict; my %options = (); my $results = GetOptions (\\%options, 'input|i=s', 'output|o=s', 'debug|d=s', 'command_id=s', ## passed by workflow 'logconf=s', ## passed by workflow (not used) 'project|p=s', 'log|l=s', 'help|h') || pod2usage(); my $logfile = $options{'log'} || Ergatis::Logger::get_default_logfilename(); my $logger = new Ergatis::Logger('LOG_FILE'=>$logfile, 'LOG_LEVEL'=>$options{'debug'}); $logger = $logger->get_logger(); # display documentation if( $options{'help'} ){ pod2usage( {-exitval=>0, -verbose => 2, -output => \\*STDOUT} ); } if (!$options{'input'}) { pod2usage(\"you must specify an input file with --input\"); } if (!$options{'output'}) { pod2usage(\"you must specify an output file with --output\"); } if (-e $options{'output'}) { $logger->logdie(\"output file '$options{output}' already exists\"); } if (!-e $options{'input'}) { $logger->logdie(\"input file '$options{input}' does not exist\"); } ## map output to ontology terms in output.obo my $onto_terms = { 'Molecular weight' => 'mol_wt', 'Residues' => '', 'Average Residue Weight' => 'avg_residue_wt', 'Charge' => 'charge', 'Isoelectric Point' => 'isoelectric_pt', 'A280 Molar Extinction Coefficient' => 'extinction_coefficient_mol', 'A280 Extinction Coefficient 1mg/ml' => 'extinction_coefficient_mg_ml', 'Improbability of expression in inclusion bodies' => 'improb_expr_in_inclusion_bodies', 'Probability of expression in inclusion bodies' => 'prob_expr_in_inclusion_bodies', }; my $doc = new BSML::BsmlBuilder(); $doc->makeCurrentDocument(); my $seq_id; my $atts; my $length; open (IN, $options{'input'}) || $logger->logdie(\"couldn't open input file for reading\"); while (<IN>) { chomp; s/\\t+/\\t/g; s/\\s+=\\s+/=/g; s/\\s+$//; if (/^\\s*$/) { next; } if (/PEPSTATS of ([^\\s]+)/) { $seq_id = $1; next; } if (/^Residue/) { last; } my @data = split(\"\\t\"); foreach my $datum(@data) { my ($att, $val) = split(\"=\",$datum); $val =~ s/\\s+//g; if ($att eq 'Residues') { $length = $val; } if (!defined($onto_terms->{$att})) { $logger->logdie(\"encountered an unexpected data type '$att'\"); } elsif ($onto_terms->{$att} ne '') { $atts->{$onto_terms->{$att}} = $val; } } } my $seq = $doc->createAndAddSequence( $seq_id, $seq_id, $length, 'aa', 'polypeptide' ); foreach my $att(keys(%{$atts})) { $seq->addBsmlAttr($att, $atts->{$att}); } $doc->createAndAddLink( $seq, 'analysis', '#pepstats_analysis', 'computed_by', ); $doc->write($options{'output'});"
    },
    {
      "tool": "phat",
      "converter_script": "phat2bsml.pl",
      "name": "phat2bsml.pl - convert phat GFF output to BSML",
      "synopsis": "USAGE: phat2bsml.pl \n        --input=/path/to/phat.output.file.gff \n        --output=/path/to/output.bsml\n      [ --project=aa1 ]",
      "description": "This script is used to convert the output from a phat search into BSML.",
      "options": {
        "input": "Input file from a phat scan.",
        "debug": "Debug level.  Use a large number to turn on verbose debugging.",
        "project": "Project ID.  Used in creating feature ids.  Defaults to 'unknown' if\n    not passed.",
        "command_id": "This is passed automatically by workflow and is used in creating unique\n    feature IDs.  It represents the command ID of the phat2bsml step withing the\n    phat workflow component.",
        "log": "Log file",
        "output": "Output BSML file (will be created, must not exist)",
        "help": "This help message"
      },
      "contact": "Joshua Orvis jorvis@tigr.org =cut use strict; use Getopt::Long qw(:config no_ignore_case no_auto_abbrev); use Pod::Usage; BEGIN { use Ergatis::Logger; use BSML::BsmlRepository; use Papyrus::TempIdCreator; use BSML::BsmlBuilder; use BSML::BsmlParserTwig; } my %options = (); my $results = GetOptions (\\%options, 'input|i=s', 'output|o=s', 'project|p=s', 'log|l=s', 'command_id=s', ## passed by workflow 'logconf=s', ## passed by workflow (not used) 'debug=s', 'help|h') || pod2usage(); my $logfile = $options{'log'} || Ergatis::Logger::get_default_logfilename(); my $logger = new Ergatis::Logger('LOG_FILE'=>$logfile, 'LOG_LEVEL'=>$options{'debug'}); $logger = $logger->get_logger(); # display documentation if( $options{'help'} ){ pod2usage( {-exitval=>0, -verbose => 2, -output => \\*STDOUT} ); } ## make sure all passed options are peachy &check_parameters(\\%options); ## we want a new doc my $doc = new BSML::BsmlBuilder(); ## we're going to generate ids my $idcreator = new Papyrus::TempIdCreator(); ## open the input file for parsing open (my $ifh, $options{'input'}) || $logger->logdie(\"can't open input file for reading\"); my $seq_id; my ($seq, $ft, $fg); my ($last_group_name, $current_group_name, $current_transcript_id); my ($thing, $id); ## we have to hold each cds in an array so that we can add 3 bases to the last ## one (phat doesn't include the stop codon within the cds) my @cds; ## go through the file while (<$ifh>) { chomp; ## skip whitespace next if (/^\\s*$/); my @cols = split(/\\t/); ## die if we didn't get enough columns unless ( scalar @cols == 9 ) { $logger->logdie(\"failed to split line $. into 9 fields. quitting.\"); } ## has the sequence been defined yet? it's in the first column ## this should happen on the first row only unless ($seq_id) { $seq_id = $cols[0]; $seq_id =~ s/\\s//g; $logger->debug(\"processing seq_id: $seq_id\\n\") if $logger->is_debug(); ## create this sequence, an analysis link, and a feature table $seq = $doc->createAndAddSequence($seq_id, undef, '', 'dna', 'assembly'); $seq->addBsmlLink('analysis', '#phat_analysis', 'input_of'); $ft = $doc->createAndAddFeatureTable($seq); } if ( $cols[8] =~ /gene \\\"(.+?)\\\" frame/ ) { $current_group_name = $1; } else { $logger->logdie(\"unrecognized column 9 ($cols[8]), line $. . expected something like: gene \\\"Phat2\\\" frame\\\"2\\\"\\n\"); } ## if a group is defined and is different than the last one we need to ## create a new feature group if ($current_group_name && $current_group_name ne $last_group_name) { ## remember this group name $last_group_name = $current_group_name; # ## add 3 bases to the last CDS, if any were found # if (scalar @cds) { # # ## if on the reverse strand, we need to take three from column 2 # ## if on the forward add three to column 3 # ## assumes (obviously) that all CDS in this group are on the same strand # if ($cds[-1][3]) { # ## here we need to sort the CDS array because the terminal one isn't # ## explicitly defined and the software can write them in any order. # ## reverse strand, sort descending # @cds = sort { $b->[1] <=> $a->[1] } @cds; # # $logger->debug(\"manually shifting 3 from reverse CDS coordinate $cds[-1][1] on $seq_id\\n\") if $logger->is_debug(); # $cds[-1][1] -= 3; # } else { # ## here we need to sort the CDS array because the terminal one isn't # ## explicitly defined and the software can write them in any order. # ## reverse strand, sort descending # @cds = sort { $a->[2] <=> $b->[2] } @cds; # # $logger->debug(\"manually pushing 3 onto forward CDS coordinate $cds[-1][2] on $seq_id\\n\") if $logger->is_debug(); # $cds[-1][2] += 3; # } for my $cd ( @cds ) { &add_feature( @{$cd} ); } undef @cds; # } ## pull a new gene id (in phat this = primary transcript) $current_transcript_id = $idcreator->new_id( db => $options{project}, so_type => 'gene', prefix => $options{command_id} ); $fg = $doc->createAndAddFeatureGroup( $seq, '', $current_transcript_id ); } ## adjust both positions so that we are numbering from zero $cols[3]--; $cols[4]--; ## change the + and - symbols in strand column to 0 and 1, respectively if ($cols[6] eq '+') { $cols[6] = 0; } elsif ($cols[6] eq '-') { $cols[6] = 1; } else { $logger->logdie(\"unknown value ($cols[6]) in strand column. expected + or -.\"); } ## phat only predicts CDS features if ($cols[2] eq 'CDS') { push @cds, [ 'CDS', $cols[3], $cols[4], $cols[6], ($cols[8] || 0) ]; } else { $logger->logdie(\"unrecognized feature type in raw phat output. expected only CDS: $cols[2]\"); } } ## add the analysis element $doc->createAndAddAnalysis( id => 'phat_analysis', sourcename => $options{'output'}, ); ## now write the doc $doc->write($options{'output'}); exit; sub add_feature { my ($type, $start, $stop, $strand, $group) = @_; $logger->debug(\"add_feature($type, $start, $stop, $strand, $group)\\n\") if $logger->is_debug(); $id = $idcreator->new_id( db => $options{project}, so_type => $type, prefix => $options{command_id} ); $thing = $doc->createAndAddFeature( $ft, $id, '', $idcreator->so_used($type) ); $thing->addBsmlLink('analysis', '#phat_analysis', 'computed_by'); $thing->addBsmlIntervalLoc($start, $stop, $strand); ## some features aren't added to a group if ($group) { $fg->addBsmlFeatureGroupMember( $id, $idcreator->so_used($type) ); } } sub check_parameters { ## make sure input file exists if (! -e $options{'input'}) { $logger->logdie(\"input file $options{'input'} does not exist\") } $options{'project'} = 'unknown' unless ($options{'project'}); $options{'command_id'} = '0' unless ($options{'command_id'}); return 1; }"
    },
    {
      "tool": "phobos",
      "converter_script": "phobos2bsml.pl",
      "name": "phobos2bsml.pl - convert phobos output to BSML",
      "synopsis": "USAGE: phobos2bsml.pl \n        --input=/path/to/somefile.out \n        --output=/path/to/output.bsml\n      [ --project=aa1 ]",
      "description": "This script is used to convert the output from an phobos run into BSML.",
      "options": {
        "input": "Input .out file from a Phobos search.",
        "debug": "Debug level.  Use a large number to turn on verbose debugging.",
        "log": "Log file",
        "output": "Output BSML file (will be created, or overwritten)",
        "project": "Project ID.  Used in creating feature ids.  Defaults to whatever the prefix of the\n    input file is (i.e. spntigr4.assembly.1.1 would be spntigr4).",
        "id_repository": "Required for creating feature identifiers.  Each project should have\n    its own id_repository directory - use the full path to it here.",
        "help": "This help message"
      },
      "contact": "David Riley driley@som.umaryland.edu =cut use strict; use Getopt::Long qw(:config no_ignore_case no_auto_abbrev); use Pod::Usage; use Ergatis::IdGenerator; use File::Basename; use Ergatis::Logger; use BSML::BsmlRepository; use BSML::BsmlBuilder; use BSML::BsmlParserTwig; my %options = (); my $results = GetOptions (\\%options, 'input|i=s', 'output|o=s', 'project|p=s', 'log|l=s', 'id_repository|r=s', 'command_id=s', ## passed by workflow 'logconf=s', ## passed by workflow (not used) 'debug=s', 'help|h') || pod2usage(); my $logfile = $options{'log'} || Ergatis::Logger::get_default_logfilename(); my $logger = new Ergatis::Logger('LOG_FILE'=>$logfile, 'LOG_LEVEL'=>$options{'debug'}); $logger = $logger->get_logger(); # display documentation if( $options{'help'} ){ pod2usage( {-exitval=>0, -verbose => 2, -output => \\*STDOUT} ); } ## make sure all passed options are peachy &check_parameters(\\%options); ## we want a new doc my $doc = new BSML::BsmlBuilder(); ## we're going to generate ids my $idcreator = new Ergatis::IdGenerator( id_repository => $options{id_repository} ); my $seq_id; my $project; ## open the input file for parsing open (my $ifh, $options{'input'}) || $logger->logdie(\"can't open input file for reading\"); my %data; my $seq; my $ft; my $added_seqs = {}; while (<$ifh>) { if($_ !~ /^\\#/) { my @fields= split(/\\s+/, $_); if(!$added_seqs->{$fields[0]}) { ($seq,$ft) = &add_sequence($fields[0]); $added_seqs->{$fields[0]} = 1; } next if($fields[0] eq 'seq-name'); my $start = $fields[3]; my $stop = $fields[4]; my $bases = $fields[12]; if(defined($start) && defined($stop)) { ## add the island my $id = $idcreator->next_id( project => $project, type => 'repeat_region' ); my $island = $doc->createAndAddFeature($ft, $id, '', 'repeat_region'); $island->addBsmlLink('analysis', '#phobos_analysis', 'computed_by'); ## add the location of the repeat $island->addBsmlIntervalLoc( $start, $stop, 0); } } } ## add the analysis element $doc->createAndAddAnalysis( id => 'phobos_analysis', sourcename => dirname($options{'output'}), program => 'phobos', algorithm => 'phobos', programversion => 'current' ); ## now write the doc $doc->write($options{'output'}); exit; sub add_sequence { my $seq_id = shift; my $seq = $doc->createAndAddSequence($seq_id, undef, '', 'dna', 'assembly'); $seq->addBsmlLink('analysis', '#phobos_analysis', 'input_of'); my $ft = $doc->createAndAddFeatureTable($seq); $seq_id =~ /([^\\.]+)\\./; my $prefix = $1; $project = $prefix ? $prefix : $options{project}; return ($seq,$ft); } sub check_parameters { ## make sure input file exists if (! -e $options{'input'}) { $logger->logdie(\"input file $options{'input'} does not exist\") } return 1; }"
    },
    {
      "tool": "pmarks",
      "converter_script": "pmarks2bsml.pl",
      "name": "pmarks2bsml.pl - Creates a bsml document for pmarks location on a pseudomolecule",
      "synopsis": "USAGE: pmarks2bsml.pl\n            --input_file=/path/to/some/pseudomol.pmarks\n            --output=/path/to/pmarks.bsml\n            --id_repository=/path/to/id_repository\n          [ --fasta_input=/path/to/pseudomolecule.fsa\n            --log=/path/to/file.log\n            --debug=4\n            --help\n          ]",
      "description": "This script is used to convert the output from a create_pseudomolecule script specifying the pmarks location into BSML.",
      "options": {
        "input_file": "Input pmarks positions file",
        "output": "The output bsml file.",
        "id_repository": "Id repository for use by Workflow::IdGenerator.pm",
        "fasta_input": "The input file that was used to locate pmarks location in a pseudomolecule",
        "log": "Logfile.",
        "help": "Print this message"
      },
      "contact": "Sonia Agrawal sagrawal@som.umaryland.edu =cut use strict; use warnings; use Getopt::Long qw(:config no_ignore_case no_auto_abbrev pass_through); use Pod::Usage; use File::Basename; use BSML::BsmlBuilder; use Ergatis::IdGenerator; use Ergatis::Logger; ####### GLOBALS AND CONSTANTS ########### my $inputFile; #Holds input files my $project; #The project (ex aa1) my $output; #Output file my $idMaker; #The Workflow::IdGenerator my $doc; #BSML::BsmlBuilder object object. my $inputFsa; #The fasta file input (pseudomolecule) my $debug; #The debug variable my $length; my $ft; my $seq; my $thing; ######################################## my %options = (); my $results = GetOptions (\\%options, 'input_file|f=s', 'output|o=s', 'project|p=s', 'id_repository|r=s', 'fasta_input|a=s', 'log|l=s', 'debug=s', 'help|h') || &_pod; #Setup the logger my $logfile = $options{'log'} || Ergatis::Logger::get_default_logfilename(); my $logger = new Ergatis::Logger('LOG_FILE'=>$logfile, 'LOG_LEVEL'=>$options{'debug'}); $logger = $logger->get_logger(); # Check the options. &check_parameters(\\%options); $doc = new BSML::BsmlBuilder(); &parsePmarksData($inputFile); $doc->createAndAddAnalysis( id => 'pseudomolecule_analysis', sourcename => $output, version => 'current', algorithm => 'pseudomolecule_generation', program => 'pmark_spacer' ); $doc->write($output); exit(0); ######################## SUB ROUTINES ####################################### sub parsePmarksData { my ($file) = @_; my $genes; my $foundId = 0; open(IN, \"<$file\") or $logger->logdie(\"Unable to open $file file\"); while(<IN>) { if(/^>(.*?)\\s/) { $foundId = $1; print \"$foundId is foundId\\n\"; if( $project eq 'parse' ) { $project = $1 if($foundId =~ /^(\\w+?)\\./); $logger->logdie(\"Could not parse project name out of id $foundId.\") unless($project); } $seq = $doc->createAndAddSequence($foundId, undef, $length->{$foundId}, 'dna', 'assembly'); $doc->createAndAddBsmlAttribute($seq,'defline',$foundId); $doc->createAndAddSeqDataImport($seq,'fasta',$inputFsa,'',$foundId); $seq->addBsmlLink('analysis', '#pseudomolecule_analysis', 'input_of'); $ft = $doc->createAndAddFeatureTable($seq); } elsif($foundId) { print \"$_\\n\"; my @cols = split(/\\s+/,$_); my $id = $idMaker->next_id( type => 'pmark_spacer', project => $project); $thing = $doc->createAndAddFeature( $ft, $id, '', 'pmark_spacer' ); $thing->addBsmlLink('analysis', '#pseudomolecule_analysis', 'computed_by'); $thing->addBsmlIntervalLoc($cols[0], $cols[1], 0); } else { $logger->logdie(\"Did not find the id in the file\"); } } close(IN); } sub check_parameters { my $options = shift; if($options{'help'}) { pod2usage( {-exitval => 0, -verbose => 2, -output => \\*STDERR} ); } if($options{'output'}) { $output = $options{'output'}; } else { $output = $inputFile.\".bsml\"; } unless($options{'id_repository'}) { $logger->logdie(\"Option id_repository is required. Please see Ergatis::IdGenerator for details.\\n\"); } else { $idMaker = new Ergatis::IdGenerator( 'id_repository' => $options{'id_repository'} ); $idMaker->set_pool_size( 'pmark_spacer' => 20); } if(defined($options{'fasta_input'}) && (-e $options{'fasta_input'})) { $inputFsa = $options{'fasta_input'}; #Find the length of the sequence open(IN, \"<$inputFsa\") or $logger->logdie(\"Cannot open $inputFsa file for reading\\n$!\\n\"); my $seq = \"\"; my $curId; while(<IN>) { chomp; if(/^>(\\S+)/) { if(defined($curId)) { $length->{$curId} = length($seq); $seq = \"\"; } $curId = $1; } else { $seq.= $_; } } $length->{$curId} = length($seq); close(IN); } else { # my ($file_base,$file_dir,$file_ext) = fileparse($inputFile,qr/\\.[^.]*/); # $inputFsa = $file_base; $logger->logdie(\"--fasta_input is mandatory and $options{'fasta_input'} file should exist.\"); } if($options{'input_file'}) { $inputFile = $options{'input_file'}; } else { $inputFile = $inputFsa.\".pmarks\"; $logger->logdie(\"$inputFile file does not exist. Either pass it as a parameter or execute pseudomolecule creation script\\n\") unless(-e $inputFile); } if( $options{'project'} ) { $project = $options->{'project'}; } else { $project = \"parse\"; } if($options{'debug'}) { $debug = $options{'debug'}; } }"
    },
    {
      "tool": "predotar",
      "converter_script": "predotar2bsml.pl",
      "name": "predotar2bsml.pl - convert predotar output to BSML",
      "synopsis": "USAGE: predotar2bsml.pl --input=/path/to/predotar_file --output=/path/to/output.bsml",
      "description": "This script is used to convert the output from predotar into BSML.",
      "options": {
        "input": "Input file file from a predotar run.",
        "debug": "Debug level.  Use a large number to turn on verbose debugging.",
        "log": "Log file",
        "output": "Output BSML file (will be created, must not exist)",
        "help": "This help message"
      },
      "contact": "Brett Whitty bwhitty@tigr.org =cut use strict; use Getopt::Long qw(:config no_ignore_case no_auto_abbrev); use Pod::Usage; BEGIN { use Ergatis::Logger; use BSML::BsmlRepository; use Papyrus::TempIdCreator; use BSML::BsmlBuilder; use BSML::BsmlParserTwig; } my %options = (); my $results = GetOptions (\\%options, 'input|i=s', 'output|o=s', 'debug|d=s', 'command_id=s', ## passed by workflow 'logconf=s', ## passed by workflow (not used) 'project|p=s', 'log|l=s', 'help|h', 'strict', ) || pod2usage(); my $logfile = $options{'log'} || Ergatis::Logger::get_default_logfilename(); my $logger = new Ergatis::Logger('LOG_FILE'=>$logfile, 'LOG_LEVEL'=>$options{'debug'}); $logger = $logger->get_logger(); # display documentation if( $options{'help'} ){ pod2usage( {-exitval=>0, -verbose => 2, -output => \\*STDOUT} ); } ## make sure all passed options are peachy &check_parameters(\\%options); ## we want to create ids unique to this document, which will be replaced later. they must ## contain the prefix that will be used to look up a real id, such as ath1.gen.15 my $next_id = 1; ## we want a new doc my $doc = new BSML::BsmlBuilder(); ## we're going to generate ids my $idcreator = new Papyrus::TempIdCreator(); ## open the input file for parsing open (my $ifh, $options{'input'}) || $logger->logdie(\"can't open input file for reading\"); my @results; my @result_fields; my @field_ids; my $finished_flag = 0; while (<$ifh>) { chomp; #check whitespace, no warn next if ( /^\\s*$/ ); ##recognize header fields if (/^Seq\\t/) { ##save the field ids for verifying data later @field_ids = split(\"\\t\"); while (my $result_line = <$ifh>) { chomp $result_line; if ($result_line =~ /^finished reading/) { $finished_flag = 1; last; } else { my @result_fields = split(\"\\t\", $result_line); if ($result_line =~ /Discarding/) { $logger->error( \"input sequence \".$result_fields[0].\" was discarded by predotar.\" ) if ($logger->is_error); next; } push (@results, \\@result_fields); } } } } ## if we reached EOF without hitting finished reading line ## we need to die because something's probably gone very wrong if (! $finished_flag) { $logger->logdie(\"Reached end of input file without seeing 'finished reading' line.\\nRaw file is corrupted or in an unrecognized format.\\n\"); } my @clean_results = @results; ## removed skipping of discarded sequences #my @clean_results; #foreach my $result_fields_ref(@results) { ## Check if any sequences were discarded # if ((scalar @$result_fields_ref) == 2 && $result_fields_ref->[1] =~ /^Discarding ([^:]+): (.*)$/) { # $logger->error(\"The sequence with id \\\"$1\\\" was discarded by predotar.\\nThe reason given was: $2\\n\") if ($logger->is_error); # } elsif (scalar @$result_fields_ref != scalar @field_ids) { # $logger->error(\"The number of fields in the following line did not match the results header:\\n\".join(\"\\t\", @$result_fields_ref).\"\\n\") if ($logger->is_error); # } else { # push (@clean_results, $result_fields_ref); # } #} @results = (); my $result_count = scalar @clean_results; ## GO mappings tables for output my %go_term; my %go_id; if (defined($options{strict})) { %go_term = ( 'mitochondrial' => 'mitochondrion', 'possibly mitochondrial' => 'cellular component unknown', 'plastid' => 'plastid', 'possibly plastid' => 'cellular component unknown', 'ER' => 'endoplasmic reticulum', 'possibly ER' => 'cellular component unknown', 'none' => 'cellular component unknown', ); %go_id = ( 'mitochondrial' => 'GO:0005739', 'possibly mitochondrial' => 'GO:0008372', 'plastid' => 'GO:0009536', 'possibly plastid' => 'GO:0008372', 'ER' => 'GO:0005783', 'possibly ER' => 'GO:0008372', 'none' => 'GO:0008372', ); } else { %go_term = ( 'mitochondrial' => 'mitochondrion', 'possibly mitochondrial' => 'mitochondrion', 'plastid' => 'plastid', 'possibly plastid' => 'plastid', 'ER' => 'endoplasmic reticulum', 'possibly ER' => 'endoplasmic reticulum', 'none' => 'cellular component unknown', ); %go_id = ( 'mitochondrial' => 'GO:0005739', 'possibly mitochondrial' => 'GO:0005739', 'plastid' => 'GO:0009536', 'possibly plastid' => 'GO:0009536', 'ER' => 'GO:0005783', 'possibly ER' => 'GO:0005783', 'none' => 'GO:0008372', ); } ## loop through each of the matches that we found for (my $i = 0; $i < $result_count; $i++) { my @result_fields = @{$clean_results[$i]}; my @result_field_ids = @field_ids; ## pull the sequence id off the front of the array my $sequence_id = shift @result_fields; ## and discard the label shift @result_field_ids; ## pull the prediction off the end of the array my $prediction = pop @result_fields; ## and again discard the label pop @result_field_ids; my $seq = $doc->createAndAddSequence($sequence_id, undef, '', 'aa', 'polypeptide'); $seq->addBsmlLink('analysis', '#predotar_analysis', 'input_of'); unless ($prediction =~ /^Discarding ([^:]+): (.*)$/) { my $ft = $doc->createAndAddFeatureTable($seq); my $new_id = $idcreator->new_id( db => $options{project}, so_type => 'transit_peptide', prefix => $options{command_id}, ); my $feature = $doc->createAndAddFeature($ft, $new_id, '', 'transit_peptide'); $feature->addBsmlLink('analysis', '#predotar_analysis', 'computed_by'); unless (defined($go_id{$prediction})) { $logger->logdie(\"predotar prediction '$prediction' was not an expected result\"); } my $attribute_array_ref; push( @{$attribute_array_ref}, { name => 'GO', content => $go_id{$prediction}} ); push( @{$attribute_array_ref}, { name => 'IEA', content => 'predotar prediction'} ); $feature->addBsmlAttributeList($attribute_array_ref); my $attribute_count = scalar @result_field_ids; for (my $j = 0; $j < $attribute_count; $j++) { $doc->createAndAddBsmlAttribute($feature, $result_field_ids[$j], $result_fields[$j]); } } } ## add the analysis element my $analysis = $doc->createAndAddAnalysis( id => 'predotar_analysis', sourcename => $options{'output'}, ); $doc->createAndAddBsmlAttribute( $analysis, 'version', 'current' ); $doc->createAndAddBsmlAttribute( $analysis, 'algorithm', 'predotar' ); ## now write the doc $doc->write($options{'output'}); exit; sub check_parameters { ## make sure input file exists if (! -e $options{'input'}) { $logger->logdie(\"input file $options{'input'} does not exist\") } ## make sure output file doesn't exist yet if (-e $options{'output'}) { $logger->logdie(\"can't create $options{'output'} because it already exists\") } $options{'project'} = 'unknown' unless ($options{'project'}); $options{'command_id'} = '0' unless ($options{'command_id'}); return 1; }"
    },
    {
      "tool": "prodigal",
      "converter_script": "prodigal2bsml.pl",
      "name": "prodigal2bsml.pl - Creates a bsml document from prodigal raw output",
      "synopsis": "USAGE: prodigal2bsml.pl\n            --input_list=/path/to/some/prodigal.raw.list\n            --input_file=/path/to/some/prodigal.raw\n            --output=/path/to/transterm.bsml\n            --id_repository=/path/to/id_repository\n            --fasta_input=/path/to/prodigal/input.fsa\n          [ --log=/path/to/file.log\n            --debug=4\n            --help\n          ]",
      "description": "This script is used to convert the output from a prodigal search into BSML.",
      "options": {
        "input_list": "Input list of prodigal raw output files (.predict)",
        "input_file": "Input prodigal raw file (.predict)",
        "output": "The output bsml file.",
        "id_repository": "Id repository for use by Workflow::IdGenerator.pm",
        "fasta_input": "The input file that was used as input for the prodigal run",
        "log": "Logfile.",
        "help": "Print this message"
      },
      "contact": "Sonia Agrawal sagrawal@som.umaryland.edu =cut use strict; use warnings; use Getopt::Long qw(:config no_ignore_case no_auto_abbrev pass_through); use Pod::Usage; use Chado::Gene; use BSML::GenePredictionBsml; use Ergatis::IdGenerator; use Ergatis::Logger; ####### GLOBALS AND CONSTANTS ########### my @inputFiles; #Holds input files my $project; #The project (ex aa1) my $output; #Output file my $idMaker; #The Workflow::IdGenerator my $bsml; #BSML::BsmlBuilder object object. my $data; #Holds parsed prodigal information my $inputFsa; #The fasta file input to prodigal my $debug; #The debug variable my $length; ######################################## my %options = (); my $results = GetOptions (\\%options, 'input_list|i=s', 'input_file|f=s', 'output|o=s', 'project|p=s', 'id_repository|r=s', 'fasta_input|a=s', 'log|l=s', 'debug=s', 'help|h') || &_pod; #Setup the logger my $logfile = $options{'log'} || Ergatis::Logger::get_default_logfilename(); my $logger = new Ergatis::Logger('LOG_FILE'=>$logfile, 'LOG_LEVEL'=>$options{'debug'}); $logger = $logger->get_logger(); # Check the options. &check_parameters(\\%options); foreach my $file (@inputFiles) { $data = &parseProdigalData($file); $bsml = &generateBsml($data); } $bsml->writeBsml($output); exit(0); ######################## SUB ROUTINES ####################################### sub parseProdigalData { my ($file) = @_; my $genes; my $foundId = 0; open(IN, \"<$file\") or &_die(\"Unable to open $file\"); while(<IN>) { chomp($_); # return header to first space to be consistent with glimmer3 if(/seqhdr\\=\\\"(\\S+)[^\\\"]*\\\"/g) { $foundId = $1; if( $project eq 'parse' ) { $project = $1 if($foundId =~ /^(\\w+?)\\./); $logger->logdie(\"Could not parse project name out of id $foundId.\") unless($project); } } elsif($foundId) { next if(/^#/); my @cols = split(/_/,$_); my $strand = ($cols[3] eq '+') ? 0 : 1; # Correcting for interbase numbering $cols[1]--; #Create some genes and push them onto the $genes array my $tmp = new Chado::Gene( $idMaker->next_id( 'type' => 'gene', 'project' => $project), $cols[1], $cols[2], $strand, $foundId); foreach my $type(qw(exon CDS transcript polypeptide)) { my $typeid =$idMaker->next_id( 'type' => $type, 'project' => $project); $tmp->addFeature($typeid, $cols[1], $cols[2], $strand, $type); } my $count = $tmp->addToGroup($tmp->getId, { 'all' => 1 }); &_die(\"Nothing was added to group\") unless($count); push(@{$genes}, $tmp); } else { &_die(\"Didn't find the id\"); } } close(IN); return $genes; } sub generateBsml { my $data = shift; #Create the document my $doc = new BSML::GenePredictionBsml( 'prodigal', $inputFsa ); foreach my $gene(@{$data}) { $doc->addGene($gene); } my $seqId; open(IN, \"< $inputFsa\") or &_die(\"Unable to open $inputFsa\"); while(<IN>) { #assume it's a single fasta file if(/^>([^\\s+]+)/) { $seqId = $1; last; } } close(IN); my $addedTo = $doc->setFasta($seqId, $inputFsa); &_die(\"$seqId was not a sequence associated with the gene\") unless($addedTo); return $doc; } sub check_parameters { my $options = shift; my $error = \"\"; &_pod if($options{'help'}); if($options{'input_list'}) { $error .= \"Option input_list ($options{'input_list'}) does not exist\\n\" unless(-e $options{'input_list'}); open(IN, \"< $options{'input_list'}\") || &_die(\"Unable to open $options{'input_list'} ($!)\"); @inputFiles = <IN>; close(IN); } if($options{'input_file'}) { $error .= \"Option input_file ($options{'input_file'}) does not exist\\n\" unless(-e $options{'input_file'}); push(@inputFiles, $options{'input_file'}); } unless($options{'input_list'} || $options{'input_file'}) { $error .= \"Either option input_list or input_file is required\\n\"; } unless($options{'output'}) { $error .= \"Option output is required\\n\"; } else { $output = $options{'output'}; } unless($options{'id_repository'}) { $error .= \"Option id_repository is required. Please see Ergatis::IdGenerator \". \"for details.\\n\"; } else { $idMaker = new Ergatis::IdGenerator( 'id_repository' => $options{'id_repository'} ); $idMaker->set_pool_size( 'exon' => 20, 'transcript' => 20, 'gene' => 20, 'polypeptide' => 20, 'CDS' => 20 ); } unless($options{'fasta_input'}) { $error .= \"Option fasta_input is required\\n\"; } else { $error .= \"$options{'fasta_input'} (fasta_input) does not exist\\n\" unless(-e $options{'fasta_input'}); $inputFsa = $options{'fasta_input'}; #Find the length of the sequence open(IN, \"<$options{'fasta_input'}\") or $logger->logdie(\"Can't open $options->{'fasta_input'}\"); my $seq = \"\"; my $curId; while(<IN>) { chomp; if(/^>(\\S+)/) { if(defined($curId)) { $length->{$curId} = length($seq); $seq = \"\"; } $curId = $1; $curId =~ s/\\s+$//; } else { $seq.= $_; } } $length->{$curId} = length($seq); close(IN); } if( $options{'project'} ) { $project = $options->{'project'}; } else { $project = \"parse\"; } if($options{'debug'}) { $debug = $options{'debug'}; } unless($error eq \"\") { &_die($error); } } sub _pod { pod2usage( {-exitval => 0, -verbose => 2, -output => \\*STDERR} ); } sub _die { my $msg = shift; $logger->logdie($msg); }"
    },
    {
      "tool": "ps_scan",
      "converter_script": "ps_scan2bsml.pl",
      "name": "ps_scan2bsml.pl - Formats prosite scan output into bsml format.",
      "synopsis": "USAGE: template.pl\n            --input_file=/path/to/some/transterm.raw\n            --output=/path/to/transterm.bsml\n            --analysis_id=ps_scan\n          [ --log=/path/to/file.log\n            --debug=4\n            --help\n          ]",
      "description": "Reads ps_scan output file and turns it into BSML.  Generates BSML with Sequence Pair Alignment and \n    Sequence Pair Run elements with polypeptide and prosite_entry class elements.",
      "options": {
        "input_file": "The input file (should be prosite scan output)",
        "output": "Where the output bsml file should be",
        "analysis_id": "Analysis id.  Should most likely by ps_scan_analysis.",
        "query_file_path": "Path to the query file (input fasta file) for ps_scan.",
        "gzip_output": "A non-zero value will result in compressed bsml output.  If no .gz is on the end of the bsml output name, one will\n    be added.",
        "log": "In case you wanted a log file.",
        "debug": "There are no debug statements in this program.  Sorry.",
        "help": "Displays this message."
      },
      "contact": "Kevin Galens kgalens@som.umaryland.edu =cut use strict; use warnings; use Getopt::Long qw(:config no_ignore_case no_auto_abbrev pass_through); use Pod::Usage; use BSML::BsmlBuilder; use Ergatis::Logger; use Ergatis::IdGenerator; use Data::Dumper; ####### GLOBALS AND CONSTANTS ########### my $inputFile; my $output; my $debug; my $analysis_id; my $fasta_file; my $gzip; my $identifier_lookup = {}; ######################################## my %options = (); my $results = GetOptions (\\%options, 'input_file|i=s', 'output|o=s', 'analysis_id|a=s', 'query_file_path|q=s', 'gzip_output|g=s', 'fasta_file|f=s', 'log|l=s', 'debug=s', 'help|h') || &_pod; #Setup the logger my $logfile = $options{'log'} || Ergatis::Logger::get_default_logfilename(); my $logger = new Ergatis::Logger('LOG_FILE'=>$logfile, 'LOG_LEVEL'=>$options{'debug'}); $logger = $logger->get_logger(); # Check the options. &check_parameters(\\%options); my $data = &parsePs_scanData($inputFile); my $bsml = &generateBsml($data); print \"Writing to $output\\n\"; $bsml->write($output,'', $gzip); ######################## SUB ROUTINES ####################################### sub parsePs_scanData { my $file = shift; my $retHash; my ($seq, $prosite); #Open the file (should be default output from ps_scan run). open(IN, \"<$file\") or &_die(\"Unable to open ps_scan raw file input ($file) : $!\"); while(<IN>) { if(/^>(.*)\\s:(.*)$/) { $seq = $1; $seq =~ s/\\s+//g; $prosite = $2; &_die(\"prosite ($prosite) or seq ($seq) was not set\\n\") unless($prosite && $seq); } else { my @tmp = split(/[\\s\\t]+/); if($tmp[1] > $tmp[3]) { $tmp[0] = 1; ($tmp[1], $tmp[3]) = ($tmp[3], $tmp[1]); } else { $tmp[0] = 0; } my $match = { 'start' => $tmp[1]-1, 'stop' => $tmp[3]-1, 'strand' => $tmp[0], 'match' => $tmp[4] }; push(@{$retHash->{$seq}->{$prosite}}, $match); } } return $retHash; } sub generateBsml { my $data = shift; my $seqObj; ## keeps track of which sequence elements we've added (since they can't be duplicated) ## key is id, value is a reference to the object my %seqs; my $doc = new BSML::BsmlBuilder(); if( scalar(keys %{$data}) == 0 ) { foreach my $seq ( keys %{$identifier_lookup} ) { print \"Adding $seq to doc\\n\"; my $seq_elem = $doc->createAndAddSequence($seq, $seq, '', 'aa', 'polypeptide'); $doc->createAndAddLink($seq_elem, 'analysis', '#'.$analysis_id, 'input_of'); $doc->createAndAddSeqDataImport($seq_elem, 'fasta', $fasta_file, '', $seq); $doc->createAndAddBsmlAttribute( $seq_elem, 'defline', $identifier_lookup->{$seq}); } } foreach my $seq(keys %{$data}) { #Create the seq object if we need to if ( ! defined $seqs{$seq} ) { $seqs{$seq} = $doc->createAndAddSequence($seq, $seq, '', 'aa', 'polypeptide'); } $doc->createAndAddLink($seqs{$seq}, 'analysis', '#'.$analysis_id, 'input_of'); if( ! exists( $identifier_lookup->{$seq} ) ) { die(\"$seq was not found in query sequence file\"); } $doc->createAndAddSeqDataImport($seqs{$seq}, 'fasta', $fasta_file, '', $seq); $doc->createAndAddBsmlAttribute( $seqs{$seq}, 'defline', $identifier_lookup->{$seq}); foreach my $proDomain(keys %{$data->{$seq}}) { #Create another seq object. my ($proId, $title) = ($1, $2) if($proDomain =~ /(\\w+)\\s(.*)/); &_die(\"Could not parse id and title from prosite domain id line in raw output\") unless($proId && $title); if ( ! defined $seqs{$proId} ) { $seqs{$proId} = $doc->createAndAddSequence($proId, $title, '', 'aa', 'prosite_entry'); } my %spaArgs = ( 'refseq' => $seqs{$seq}->{'attr'}->{'id'}, 'compseq' => $seqs{$proId}->{'attr'}->{'id'}, 'restart' => 0, 'class' => 'match' ); my $spaObj = $doc->createAndAddSequencePairAlignment(%spaArgs); foreach my $match (@{$data->{$seq}->{$proDomain}}) { my %sprArgs = ( 'alignment_pair' => $spaObj, 'refpos' => $match->{'start'}, 'runlength' => $match->{'stop'} - $match->{'start'}, 'refcomplement' => $match->{'strand'}, 'comppos' => 0, 'comprunlength' => length($match->{'match'}), 'compcomplement' => 0, ); # SADKINS - 6/29/17 - for some reason some match parts had refpos at -1 with all other values at 0. Skip these. next if $sprArgs{'refpos'} == -1; my $sprObj = $doc->createAndAddSequencePairRun(%sprArgs); $doc->createAndAddBsmlAttribute($sprObj, 'class', 'match_part'); } ## add a link to the analysis my $analysis_link = $doc->createAndAddLink( $spaObj, 'analysis', \"#$analysis_id\", 'computed_by' ); } } $doc->createAndAddAnalysis( 'id' => $analysis_id, 'sourcename' => $output, 'algorithm' => 'ps_scan', 'program' => 'ps_scan'); return $doc; } sub check_parameters { my $options = shift; my $error = \"\"; &_pod if($options{'help'}); if($options{'input_file'}) { $error .= \"Option input_file ($options{'input_file'}) does not exist\\n\" unless(-e $options{'input_file'}); $inputFile = $options{'input_file'}; } else { $error .= \"Option input_file is required\\n\"; } unless($options{'output'}) { $error .= \"Option output is required\\n\"; } else { $output = $options{'output'}; } unless($options{'analysis_id'}) { $error .= \"Option analysis_id is required\\n\"; } else { $analysis_id = $options{'analysis_id'}; } unless($options{'query_file_path'}) { $error .= \"Option fasta_file is required\\n\"; } else { $fasta_file = $options{'query_file_path'}; open(IN, \"< $fasta_file\") or &_die(\"Unable to open $fasta_file ($!)\"); while(<IN>) { if(/^>(.*)/) { my $defline = $1; my $identifier = $1 if($defline =~ /^([^\\s]+)/); $identifier_lookup->{$identifier} = $defline; } } close(IN); } if($options{'debug'}) { $debug = $options{'debug'}; } if($options{'gzip_output'}) { $gzip = 1; } else { $gzip = 0; } unless($error eq \"\") { &_die($error); } } sub _pod { pod2usage( {-exitval => 0, -verbose => 2, -output => \\*STDERR} ); } sub _die { my $msg = shift; $logger->logdie($msg); }"
    },
    {
      "tool": "psortb",
      "converter_script": "psortb2bsml.pl",
      "name": "psortb2bsml.pl - convert psortb output to BSML",
      "synopsis": "USAGE: psortb2bsml.pl --input=/path/to/psortb_out.raw --output=/path/to/output.bsml",
      "description": "This script is used to convert the output from psortb into BSML.",
      "options": {
        "input": "Input file file from a psortb run.",
        "debug": "Debug level.  Use a large number to turn on verbose debugging.",
        "log": "Log file",
        "output": "Output BSML file (will be created, must not exist)",
        "help": "This help message"
      },
      "contact": "Brett Whitty bwhitty@tigr.org =cut use Log::Log4perl qw(get_logger); use Getopt::Long qw(:config no_ignore_case no_auto_abbrev); use Pod::Usage; use Ergatis::Logger; use BSML::BsmlBuilder; use warnings; use strict; my %options = (); my $results = GetOptions (\\%options, 'input|i=s', 'output|o=s', 'debug|d=s', 'command_id=s', ## passed by workflow 'logconf=s', ## passed by workflow (not used) 'project|p=s', 'log|l=s', 'help|h') || pod2usage(); my $logfile = $options{'log'} || Ergatis::Logger::get_default_logfilename(); my $logger = new Ergatis::Logger('LOG_FILE'=>$logfile, 'LOG_LEVEL'=>$options{'debug'}); $logger = $logger->get_logger(); # display documentation if( $options{'help'} ){ pod2usage( {-exitval=>0, -verbose => 2, -output => \\*STDOUT} ); } if (!$options{'input'}) { pod2usage(\"you must specify an input file with --input\"); } if (!$options{'output'}) { pod2usage(\"you must specify an output file with --output\"); } if (-e $options{'output'}) { $logger->logdie(\"output file '$options{output}' already exists\"); } if (!-e $options{'input'}) { $logger->logdie(\"input file '$options{input}' does not exist\"); } ## ontology terms in output.obo for the output columns my @columns = ( 'cmsvm_loc', 'cmsvm_desc', 'cytosvm_loc', 'cytosvm_desc', 'ecsvm_loc', 'ecsvm_desc', 'hmmtop_loc', 'hmmtop_desc', 'motif_loc', 'motif_desc', 'ompmotif_loc', 'ompmotif_desc', 'omsvm_loc', 'omsvm_desc', 'ppsvm_loc', 'ppsvm_desc', 'profile_loc', 'profile_desc', 'scl-blast_loc', 'scl-blast_desc', 'scl-blaste_loc', 'scl-blaste_desc', 'signal_loc', 'signal_desc', 'cytoplasmic_score', 'cytoplasmic_membrane_score', 'periplasmic_score', 'outer_membrane_score', 'extracellular_score', 'final_loc', 'final_score', ); my $doc = new BSML::BsmlBuilder(); $doc->makeCurrentDocument(); my $seq_id; my $atts; my $length; open (IN, $options{'input'}) || $logger->logdie(\"couldn't open input file for reading\"); my $header = <IN>; ## skip the header line if (!($header =~ /^SeqID/)) { $logger->logdie(\"invalid pSortB file or file format has changed\"); } my $psortb; while (<IN>) { chomp; if (/^\\s*$/) { next; } my @cols = split(\"\\t\"); if (scalar(@cols) != 32) { $logger->logdie(\"expected 32 cols in output but found \".scalar(@cols)); } my $seq_id = shift @cols; $seq_id =~ s/^([^\\s]+).*/$1/; $psortb->{$seq_id} = \\@cols; } foreach my $seq_id(keys(%{$psortb})) { my $seq = $doc->createAndAddSequence( $seq_id, $seq_id, '', 'aa', 'polypeptide' ); for (my $i=0; $i<31; $i++) { $seq->addBsmlAttr($columns[$i], $psortb->{$seq_id}->[$i]); } $doc->createAndAddLink( $seq, 'analysis', '#psortb_analysis', 'computed_by', ); } $doc->write($options{'output'});"
    },
    {
      "tool": "quicktree",
      "converter_script": "quicktree2bsml.pl",
      "name": "qiucktree2bsml.pl - Convert output from quicktree to BSML.",
      "synopsis": "USAGE: quicktree2bsml.pl\n            --quicktree_output=/path/to/output/of/quicktree\n            --quicktree_input=/path/to/input/of/quicktree\n            --output=/path/to/output.bsml\n          [ --log=/path/to/some.log\n            --debug=4\n          ]",
      "description": "Converts a Stockholm formatted Multiple Sequence alignment (or distance matrix)\nand the Newick formatted output of quicktree from that alignment into BSML.",
      "options": {
        "quicktree_input": "Input multiple sequence alignment file, used as quicktree input.  Alternatively,\n    this may be the distance matrix used as input.  If the input is a MSA file, the\n    alignment is stored in the bsml.  If only given a distance matrix, we can at the\n    moment only store the sequence ids, with no seq-data-import and no alignment info.",
        "quicktree_output": "Quicktree output in Newick (New Hampshire) format.",
        "output": "The full path to the BSML file that will be created.",
        "debug": "Debug level.  Use a large number to turn on verbose debugging.",
        "log": "Log file",
        "help": "This help message"
      },
      "contact": "Jason Inman jinman@tigr.org =cut use strict; use Getopt::Long qw(:config no_ignore_case no_auto_abbrev); use Pod::Usage; use Config::IniFiles; use Ergatis::Logger; use BSML::BsmlBuilder; my $q_input; my $q_output; my $output; my $class = ''; my $input_type; my %options= (); my $results = GetOptions (\\%options, 'quicktree_input|i=s', 'quicktree_output|j=s', 'output|o=s', 'class|c=s', 'log|l=s', 'debug=s', 'help|h') || pod2usage(); my $logfile = $options{'log'} || Ergatis::Logger::get_default_logfilename(); my $logger = new Ergatis::Logger('LOG_FILE'=>$logfile, 'LOG_LEVEL'=>$options{'debug'}); $logger = Ergatis::Logger::get_logger(); # display documentation if( $options{'help'} ){ pod2usage( {-exitval=>0, -verbose => 2, -output => \\*STDERR} ); } &check_parameters(\\%options); $logger->info(\"Instantiating the BSML builder object\"); my $builder = new BSML::BsmlBuilder; $logger->logdie(\"builder was not defined\") if (!defined($builder)); # Prepare the input data my $analysis_id = 'quicktree_analysis'; my $seq_data = process_quicktree_input_file($q_input); if ( $seq_data->{'mol_type'} eq 'polypeptide') { $seq_data->{'mol_type'} = 'protein'; } else { $seq_data->{'mol_type'} = 'nucleotide'; } my $seq_class = { 'protein' => 'polypeptide', 'nucleotide' => 'nucleotide', }; my $seq_molecule = { 'protein' => 'aa', 'nucleotide' => 'na', }; if (keys %$seq_data > 1) { #skip empty msf files my $table = $builder->createAndAddMultipleAlignmentTable('molecule-type' => $seq_data->{'mol_type'}, 'class' => 'match' ); # take care of the tree open(my $tree_fh, \"< $q_output\") || die \"can't read quicktree output: $!\\n\"; undef $/; my $newick_tree = <$tree_fh>; $newick_tree =~ s/\\n//g; $/ = \"\\n\"; $table->addBsmlAttr( 'newick_tree', $newick_tree ); $table->addattr('class', 'match'); $logger->logdie(\"table was not defined\") if (!defined($table)); my $summary = $builder->createAndAddAlignmentSummary( 'multipleAlignmentTable' => $table, 'seq-type' => $seq_data->{'mol_type'}, 'seq-format' => 'msf' ); $logger->logdie(\"summary was not defined\") if (!defined($summary)); my $aln = $builder->createAndAddSequenceAlignment( 'multipleAlignmentTable' => $table ); $logger->logdie(\"aln was not defined\") if (!defined($aln)); $table->addBsmlLink('analysis', '#'.\"$analysis_id\", 'computed_by'); my $seqnum=0; my $sequences_tag; foreach my $seq (keys %{ $seq_data->{'polypeptide'} }) { $logger->logdie(\"seq was not defined\") if (!defined($seq)); $seqnum++; my $alignment; my $aln_length = 0; if ($input_type eq 'stockholm') { $alignment = join ('', @{ $seq_data->{'polypeptide'}->{$seq}->{'alignment'} }); $logger->logdie(\"alignment was not defined\") if (!defined($alignment)); $_ = $alignment; $aln_length = length($alignment) - tr/\\n//; } ## Add sequence stub if (!($builder->returnBsmlSequenceByIDR($seq))) { my $seq_stub = $builder->createAndAddSequence( $seq, #id $seq, #title '', #length $seq_molecule->{$seq_data->{'mol_type'}}, #molecule $seq_class->{$seq_data->{'mol_type'}}, #class ); $seq_stub->addBsmlLink('analysis', '#' . $analysis_id , 'input_of'); } $builder->createAndAddAlignedSequence( 'alignmentSummary' => $summary, 'seqnum' => $seqnum, 'name' => \"$seq:$seqnum\", 'length' => $aln_length, ); my @cAASD_list = ('sequenceAlignment',$aln,'seq-name',\"$seq:$seqnum\"); push (@cAASD_list,('seq-data',$alignment)) if ($input_type eq 'stockholm'); $builder->createAndAddSequenceData( @cAASD_list ); $sequences_tag .= \"$seqnum:\"; } $aln->addattr( 'sequences', $sequences_tag ); } my $algorithm = 'quicktree'; my $program = 'quicktree'; ## add the analysis element $builder->createAndAddAnalysis( id => $analysis_id, sourcename => $output, algorithm => $algorithm, program => $program ); $builder->write( $output ); $logger->debug(\"FINISHED\"); exit(0); sub check_parameters{ my $error = ''; if (exists $options{'quicktree_input'}) { $q_input = $options{'quicktree_input'}; } else { $error .= \"quicktree_input must be given.\\n\"; } if (exists $options{'quicktree_output'}) { $q_output = $options{'quicktree_output'}; } else { $error .= \"quicktree_output must be given.\\n\"; } if (exists $options{'output'}) { $output = $options{'output'}; } else { $error .= \"output must be given.\\n\"; } if (exists $options{'class'}) { $class = $options{'class'}; unless ($class eq 'polypeptide' || $class eq 'assembly') { $error .= \"unexpected vallue for option --class.\\n\"; } } else { $error .= \"class must be given.\\n\"; } $logger->logdie($error) if $error; } #------------------------------------------------------------- # process_quicktree_input_file() # #------------------------------------------------------------- sub process_quicktree_input_file { $logger->debug(\"Entered process_quicktree_input_file\") if $logger->is_debug; my $file = shift; $logger->logdie(\"file was not defined\") if (!defined($file)); my $seq_data; open(MSF, \"$file\") or die \"Unable to open $file due to $!\"; my $first_line = <MSF>; if ($first_line =~ /^\\t\\d+/) { $input_type = 'dsm'; } elsif ($first_line =~ /# STOCKHOLM/) { $input_type = 'stockholm'; } else { $logger->logdie(\"Unrecognized quicktree input! Expecting distance matrix or stockholm MSA\"); } $seq_data->{'mol_type'} = $class; if ($input_type eq 'dsm') { &process_dsm(*MSF,$seq_data); } else { &process_stockholm(*MSF,$seq_data); } close MSF; return $seq_data; }#end sub process_quicktree_input_file() sub process_dsm { # collect information from the dsm. my $handle = shift; my $seq_data = shift; while (<$handle>) { if ($_ =~ /^(\\S+)\\s/) { undef $seq_data->{$class}->{$1}; } else { $logger->logdie(\"unexpected line format in $q_input\"); } } return $seq_data; } sub process_stockholm { # collect information from the msa in stockholm format my $handle = shift; my $seq_data = shift; while (<$handle>) { # skip auxilliary information, if it's here last if (/\\/\\//); next if (/#(.*)/); next if (/^$/); if($_ =~ /(\\S+)\\s+(\\S+\\n)/) { my $name = $1; my $alignment = $2; push @{$seq_data->{$class}->{$name}->{'alignment'}}, $2; } } return $seq_data; }"
    },
    {
      "tool": "region",
      "converter_script": "region2bsml.pl",
      "name": "region2bsml - Convert gene_boundaries(region) output to BSML",
      "synopsis": "USAGE: region2bsml -r region_file -o output_file [--gzip_output 1] [--debug debug_level] [--log log_file] [--help]",
      "description": "Convert gene_boundaries(region) output to BSML\n\n=cut\n\n\nuse strict;\nuse Getopt::Long qw(:config no_ignore_case no_auto_abbrev);\nuse File::Basename;\nBEGIN {\nuse BSML::BsmlBuilder;\n}\nuse Log::Log4perl qw(get_logger :levels :easy);\nuse Pod::Usage;\n\nmy ($region,$output_file,$debug,$log,$help,$class,$gzip_output);\nmy $results = GetOptions (\n\t\t\t  'region|r=s' => \\$region,\n\t\t\t  'output|o=s' => \\$output_file,\n              'gzip_output|g=s' => \\$gzip_output,\n\t\t\t  'debug|D=s'  => \\$debug,\n\t\t\t  'log|l=s'    => \\$log,\n\t\t\t  'help|?|h'   => \\$help,\n\t\t\t  'class|c=s'  => \\$class\n\t\t\t  );\n\npod2usage({-exitval => 1, -verbose => 2, -output => \\*STDOUT}) if($help || !$region || !$output_file);\n\n###-------------------------------------------------------###\n#Init logger\n#Use central install log file as default if available\nLog::Log4perl-> Log::Log4perl::init_and_watch($ENV{LOG4PERL_CONF}) if($ENV{LOG4PERL_CONF});\n\nmy $logger = get_logger('ergatis::regions');\n$logger->level($INFO);\n$logger->more_logging($debug) if($debug);\n# Define a file appender or a screen appender\nif($log){\n    my $file_appender = Log::Log4perl::Appender->new(\n\t\t\t\t\t\t     \"Log::Dispatch::File\",\n\t\t\t\t\t\t     filename  => $log);\n    \n    my $layout = \n\tLog::Log4perl::Layout::PatternLayout->new(\n\t\t\t\t\t\t  \"%d %p> %F{1}:%L %M - %m%n\");\n    $file_appender->layout($layout);\n    $logger->add_appender($file_appender);\n}else{\n    my $screen_appender = Log::Log4perl::Appender->new(\n\t\t\t\t\t\t       \"Log::Dispatch::Screen\");\t\n    \n    $logger->add_appender($screen_appender);\n}\n\n\n###-------------------------------------------------------###\n\n\nif (!defined($class)){\n    $logger->logdie(\"class was not defined\");\n}\n\n\n\nmy $doc = BSML::BsmlBuilder->new();\n\nopen (IN, $region) or die \"unable to read $region due to $!\";\nwhile (my $line = <IN>) {\n    if($line !~ /^\\#/) {\n\tchomp($line);\n\tmy @elements = split(/\\s+/, $line);\n\tmy ($refseq,$compseq,$refstart,$compstart,$refend,$compend, $derived_class) = @elements;\n\n\tif (!defined($derived_class)){\n\t    $derived_class = $class;\n\t}\n\n\t$logger->debug(\"Parsing match line $refseq,$compseq,$refstart,$compstart,$refend,$compend\");\n\tif (scalar(@elements) == 6) {\n\t    my $align = $doc->createAndAddSequencePairAlignment('refseq' => $refseq, 'compseq' => $compseq, 'class' => $derived_class);\n\t    my $complement= ($compstart > $compend) ? 1 : 0;\n\t    if($complement){\n\t\t($compstart,$compend) = ($compend,$compstart);\n\t    }\n\t    if($refstart >= $refend){\n\t\t$logger->logdie(\"Bad reference coordinates $refstart- $refend in output between $refseq $compseq\\n\");\n\t    }\n\t    my $query_align_length = abs($refend-$refstart);\n\t    my $match_align_length = abs($compend-$compstart);\n\t    $doc->createAndAddSequencePairRun('alignment_pair' => $align, \n                                          'refpos' => $refstart, \n                                          'runlength' =>$query_align_length,\n                                          'complement' => 0,\n                                          'comppos'=> $compstart, \n                                          'comprunlength'=>$match_align_length,\n                                          'compcomplement'=>$complement);\n        } else {\n\t    $logger->info(\"Bad match line: $line\");\n        }\n    }\n}\n\n# write the altered file to disk\n$doc->write( $output_file, '', $gzip_output );\nchmod 0666, $output_file;\n$logger->info(\"Wrote output file $output_file\");",
      "options": {},
      "contact": null
    },
    {
      "tool": "repeatmasker",
      "converter_script": "repeatmasker2bsml.pl",
      "name": "repeatmasker2bsml.pl - convert RepeatMasker output to BSML",
      "synopsis": "USAGE: repeatmasker2bsml.pl \n        --input=/path/to/somefile.out \n        --output=/path/to/output.bsml\n      [ --project=aa1 ]",
      "description": "This script is used to convert the output from a RepeatMasker search into BSML.",
      "options": {
        "input": "Input .out file from a RepeatMasker search.",
        "debug": "Debug level.  Use a large number to turn on verbose debugging.",
        "log": "Log file",
        "output": "Output BSML file (will be created, or overwritten)",
        "project": "Project ID.  Used in creating feature ids.  Defaults to 'unknown' if\n    not passed.",
        "id_repository": "Required for creating feature identifiers.  Each project should have\n    its own id_repository directory - use the full path to it here.",
        "help": "This help message"
      },
      "contact": "Joshua Orvis jorvis@tigr.org =cut use strict; use Getopt::Long qw(:config no_ignore_case no_auto_abbrev); use Pod::Usage; use Ergatis::IdGenerator; use Ergatis::Logger; use BSML::BsmlRepository; use BSML::BsmlBuilder; use BSML::BsmlParserTwig; my %options = (); my $results = GetOptions (\\%options, 'input|i=s', 'output|o=s', 'project|p=s', 'log|l=s', 'id_repository|r=s', 'command_id=s', ## passed by workflow 'logconf=s', ## passed by workflow (not used) 'debug=s', 'help|h') || pod2usage(); my $logfile = $options{'log'} || Ergatis::Logger::get_default_logfilename(); my $logger = new Ergatis::Logger('LOG_FILE'=>$logfile, 'LOG_LEVEL'=>$options{'debug'}); $logger = $logger->get_logger(); # display documentation if( $options{'help'} ){ pod2usage( {-exitval=>0, -verbose => 2, -output => \\*STDOUT} ); } ## make sure all passed options are peachy &check_parameters(\\%options); ## we want a new doc my $doc = new BSML::BsmlBuilder(); ## we're going to generate ids my $idcreator = new Ergatis::IdGenerator( id_repository => $options{id_repository} ); ## open the input file for parsing open (my $ifh, $options{'input'}) || $logger->logdie(\"can't open input file for reading\"); my %data; my $linectr=0; my $datalinectr=0; my $old_version=0; while (<$ifh>) { $linectr++; chomp; #check whitespace, no warn next if ( /^\\s*$/ ); ## make sure we don't parse the repeatmasker output header lines ## (I think these don't exist anymore in current versions) if (( /^\\s*sw.*position.*repeat/i) || (/^\\s*score.*class.*id/i)) { ## set flag which indicates script is parsing older version of repeatmasker output $old_version = 1; next; } ## let's count the data lines $datalinectr++; ## skip lines that warn about lack of matches: next if ( /were no repetitive sequences detected/i ); ## if the line ends with an asterisk, remove it. it only causes ## column ambiguity. s/(.+)\\s+\\*\\s*$/$1/; my @cols = split; ## get the number of columns parsed my $colctr = scalar(@cols); if (($old_version) && ($colctr == 15)){ ## if we are parsing the old version of input file and the number of columns is fifteen with last column being an integer (ID value)- remove that last column. it only causes ## column ambiguity. s/(.+)\\s+\\*\\s*$/$1/; $colctr--; } ## if there are 13 columns, the repeat family must have been missing and we need to adjust. if ( $colctr == 13 ) { ( $cols[10], $cols[11], $cols[12], $cols[13] ) = ( '', $cols[10], $cols[11], $cols[12] ); push( @{$data{$cols[4]}}, \\@cols ); ## if there are 14 columns, just add. } elsif ( $colctr ==14 ) { push( @{$data{$cols[4]}}, \\@cols ); ## else we have an unrecognized row. } else { $logger->logdie(\"Could not parse file '$options{'input'}' at file line '$linectr' data line '$datalinectr'. Number of columns '$colctr'. The following RepeatMasker line was not recognized and could not be parsed:\\n$_\\n\"); } } ## loop through each of the matches that we found for my $seqid (keys %data) { my $seq = $doc->createAndAddSequence($seqid, undef, '', 'dna', 'assembly'); $seq->addBsmlLink('analysis', '#repeatmasker_analysis', 'input_of'); my $ft = $doc->createAndAddFeatureTable($seq); my $fg; ## loop through each array reference of this key my $gene; my $repeat; my @elements; foreach my $arr ( @{$data{$seqid}} ) { ## add the repeat my $id = $idcreator->next_id( project => $options{project}, type => 'repeat_region' ); $repeat = $doc->createAndAddFeature($ft, $id, '', 'repeat_region'); $repeat->addBsmlLink('analysis', '#repeatmasker_analysis', 'computed_by'); ## add the location of the repeat ## 1 is subtracted from each position to give interbase numbering if ($$arr[8] eq '+') { $repeat->addBsmlIntervalLoc( --$$arr[5], $$arr[6], 0); } elsif ($$arr[8] eq 'C') { $repeat->addBsmlIntervalLoc( --$$arr[5], $$arr[6], 1); } else { $logger->logdie(\"expected '+' or 'C' in column 9, but found: $$arr[8]\"); } ## add the properties of the repeat: $doc->createAndAddBsmlAttributes( $repeat, 'matching_repeat', $$arr[9], 'sw_score', $$arr[0], ); ## add the repeat class, if we have one if ($$arr[10]) { $doc->createAndAddBsmlAttributes( $repeat, 'repeat_class', $$arr[10] ); } } } ## add the analysis element $doc->createAndAddAnalysis( id => 'repeatmasker_analysis', sourcename => $options{'output'}, program => 'repeatmasker', algorithm => 'repeatmasker', ); ## now write the doc $doc->write($options{'output'}); exit; sub check_parameters { ## make sure input file exists if (! -e $options{'input'}) { $logger->logdie(\"input file $options{'input'} does not exist\") } return 1; }"
    },
    {
      "tool": "rna",
      "converter_script": "rna2bsml.pl",
      "name": "rna2bsml - Produces RNA/repeat BSML documents",
      "synopsis": "USAGE:  rna2bsml -D database -G genus -S species -f infile [-d debug_level] [-h] [-l log4perl] [-o outdir] [-s schema] [-t dtd] -y orgtype -z ftype",
      "description": "rna2bsml creates RNA/repeat BSML documents\n    \n=cut\n\nuse strict;\nuse Log::Log4perl qw(get_logger :levels :easy);\nuse Getopt::Long qw(:config no_ignore_case no_auto_abbrev);\nuse Pod::Usage;\nuse Data::Dumper;\nBEGIN {\nuse Ergatis::Logger;\nuse BSML::BsmlBuilder;\n}\n\n#\n# Process command line options\n#\nmy ($database, $species, $genus, $infile, $debug_level, $log4perl ,$help, $outdir, $schema, $dtd, $man, $orgtype, $ftype);\n\nmy $results = GetOptions (\n\t\t\t  'database|D=s'     => \\$database, \n\t\t\t  'outdir|o=s'       => \\$outdir, \n\t\t\t  'species|S=s'      => \\$species,\n\t\t\t  'genus|G=s'        => \\$genus,\n\t\t\t  'schema|s=s'       => \\$schema,\n\t\t\t  'dtd|t=s'          => \\$dtd,\n\t\t\t  'debug_level|d=s'  => \\$debug_level,\n\t\t\t  'log4perl|l=s'     => \\$log4perl,\n\t\t\t  'help|h'           => \\$help,\n\t\t\t  'infile|f=s'       => \\$infile,\n\t\t\t  'man|m'            => \\$man,\n\t\t\t  'orgtype|y=s'      => \\$orgtype,\n\t\t\t  'ftype|z=s'        => \\$ftype\n\t\t\t  );\n\nprint STDERR \"database was not defined\\n\" if (!defined($database));\nprint STDERR \"species was not defined\\n\"  if (!defined($species));\nprint STDERR \"genus was not defined\\n\"    if (!defined($genus));\nprint STDERR \"infile was not defined\\n\"   if (!defined($infile));\nprint STDERR \"orgtype was not defined\\n\"  if (!defined($orgtype));\nprint STDERR \"ftype was not defined\\n\"    if (!defined($ftype));\n\n\n&print_usage() if (!defined($database) || !defined($species) || !defined($genus) || !defined($infile) || !defined($orgtype));\n\n&print_usage() if ($help);\n&pod2usage({-exitval => 1, -verbose => 2, -output => \\*STDOUT}) if($man);\n\n\n#\n# initialize the logger\n#\n$log4perl = \"/tmp/rna2bsml.pl.log\" if (!defined($log4perl));\nmy $mylogger = new Coati::Logger('LOG_FILE'=>$log4perl,\n\t\t\t\t 'LOG_LEVEL'=>$debug_level);\n\nmy $logger = Coati::Logger::get_logger(__PACKAGE__);\n\n\nif (($ftype eq 'rna') or ($ftype eq 'te') or ($ftype eq 'repeat')){\n    $logger->info(\"Processing features of type '$ftype'\");\n}\nelse{\n    $logger->logdie(\"Unrecognized feature type '$ftype'\");\n}\n\n\n$outdir = &verify_and_set_outdir($outdir);\n\n$logger->info(\"database set to '$database'\");\n\n&construct_documents(\n\t\t     file     => $infile,\n\t\t     database => $database,\n\t\t     species  => $species,\n\t\t     genus    => $genus,\n\t\t     ftype    => $ftype     \n\t\t     );\n\n\n$logger->info(\"Please verify log4perl log file: $log4perl\");\n\n\n\n\n\n\n#------------------------------------------------------------------------------------------------------------------------\n#\n#   END OF MAIN -- SUBROUTINES FOLLOW\n#\n#------------------------------------------------------------------------------------------------------------------------\n\n\n#------------------------------------------------------------------\n# construct_documents()\n#\n# This section uses BSML API writer functions to create a \n# BSML gene model document\n#\n#------------------------------------------------------------------\nsub construct_documents {\n\n\n    $logger->debug(\"Entered construct_documents\") if $logger->is_debug;\n\n    \n    my (%args) = @_;\n    my $file     = $args{'file'};\n    my $database = $args{'database'};\n    my $genus    = $args{'genus'};\n    my $species  = $args{'species'};\n    my $ftype    = $args{'ftype'};\n\n    \n    if (!-e $file){\n\t$logger->logdie(\"file '$file' does not exist\");\n    }\n    if (!-r $file){\n\t$logger->logdie(\"file '$file' does not have read permissions\");\n    }\n\n    open (INFILE, \"<$file\") or $logger->logdie(\"Could not open file '$file'\");\n    my @contents = <INFILE>;\n    chomp @contents;\n\n\n    my $linectr=0;\n    my $asmblhash = {};\n\n\n    my $regexp;\n    if ($ftype eq 'rna'){\n\t$regexp = '^(\\S+)\\s+(\\S+)\\s+(\\S+)\\s+(\\S+)\\s+(\\S+)\\s+(\\S{1,3}RNA)\\s+([\\S\\s]+)';\n    }\n    elsif ($ftype eq 'te'){\n\t$regexp = '^(\\S+)\\s+(\\S+)\\s+(\\S+)\\s+(\\S+)\\s+(\\S+)\\s+(TE)\\s+([\\S\\s]+)'\n    }\n    elsif ($ftype eq 'repeat'){\n\t$regexp = '^(\\S+)\\s+(\\S+)\\s+(\\S+)\\s+(\\S+)\\s+(\\S+)\\s+(repeat)\\s+([\\S\\s]+)'\n    }\n    else{\n\t$logger->logdie(\"unrecognized feature type '$ftype'\");\n    }\n\n\n\n    foreach my $line (@contents){\n\t\n\t$linectr++;\n\t\n\tmy ($locus, $feat_name, $asmbl_id, $end5, $end3, $feat_type, $product_name);\n\n\t#\n\t# For RNAs\n\t#\n#\tif ($line =~ /^(\\S+)\\s+(\\S+)\\s+(\\S+)\\s+(\\S+)\\s+(\\S+)\\s+(\\S{1,3}RNA)\\s+([\\S\\s]+)/){\n\n\t#\n\t# For tca1 transposable elements\n#\tif ($line =~ /^(\\S+)\\s+(\\S+)\\s+(\\S+)\\s+(\\S+)\\s+(\\S+)\\s+(TE)\\s+([\\S\\s]+)/){\n\n\n\n\tif ($line =~ /$regexp/){\n\n\n\t    $locus     = $1;\n\t    $feat_name = $2;\n\t    $asmbl_id  = $3;\n\t    $end5      = $4;\n\t    $end3      = $5;\n\t    $feat_type = $6;\n\t    $product_name = $7;\n\t\n\n\n\t    #----------------------------------------------------------------\n\t    # Transform invalid terms:\n\t    #\n\t    # TIGR terms        ==>  Sequence Ontology qualified term\n\t    # slRNA             ==>  splice_leader_RNA\n\t    # repeated sequence ==> repeat_region\n\t    #\n\t    #\n\t    #----------------------------------------------------------------\n\t    if ($feat_type eq 'slRNA'){\n\t\t$feat_type = 'spliced_leader_RNA';\n\t    }\n\t    if ($feat_type eq 'repeated sequence'){\n\t\t$feat_type = 'repeat_region';\n\t    }\n\n\n\n\n\n\t    my $hash;\n\t    $hash->{'feat_name'} = $feat_name;\n\t    $hash->{'locus'}     = $locus;\n\t    $hash->{'end5'}      = $end5;\n\t    $hash->{'end3'}      = $end3;\n\t    $hash->{'feat_type'} = $feat_type;\n\t    $hash->{'product_name'} = $product_name;\n\n\n\t    my $asmbl_id = $database . '_'.  $asmbl_id . '_assembly';\n\n\t    push (@{$asmblhash->{$asmbl_id}}, $hash);\n\n\t}\n\telse{\n\t    $logger->logdie(\"Regular expression '$regexp' could not parse line '$linectr': $line\");\n\t}\n    }\n\n\n    my $crossrefctr=0;\n    my $xref_database = 'TIGR_' . $orgtype . ':'. $database;\n\n    my $asmblctr ={};\n\n    #\n    # Create a new BSML document for each assembly\n    #\n    foreach my $asmbl_id (sort keys %{$asmblhash}){\n\n\n\t$asmblctr->{'asmblcount'}++;\n\n\n\tmy $doc = new BSML::BsmlBuilder(); \n\t$logger->logdie(\"doc was not defined\") if (!defined($doc));\n\t\n\n\n\t#\n\t# Add <Genomes> element\n\t#\n\t\n\tmy $genome = $doc->createAndAddGenome();\n\t\n\t\n\tmy $identifier = lc(substr($genus,0,1)) . '_' . lc($species);\n\t\n\t\n\tmy $xref = $doc->createAndAddCrossReference(\n\t\t\t\t\t\t    'parent'          => $genome,\n\t\t\t\t\t\t    'id'              => '_' . ++$crossrefctr,\n\t\t\t\t\t\t    'database'        => $xref_database,\n\t\t\t\t\t\t    'identifier'      => $identifier,\n\t\t\t\t\t\t    'identifier-type' => 'current'\n\t\t\t\t\t\t    );\n\t\n\t\n\tmy $organism = $doc->createAndAddOrganism( \n\t\t\t\t\t\t   'genome'  => $genome,\n\t\t\t\t\t\t   'genus'   => $genus,  \n\t\t\t\t\t\t   'species' => $species,\n\t\t\t\t\t\t   );\n\t\n\t\n\t#\n\t# Add the <Sequence> elements for the assemblies\n\t#\n\t\n\t\n\tmy $asmseq = $doc->createAndAddExtendedSequenceN( \n\t\t\t\t\t\t\t  'id'       => $asmbl_id, \n\t\t\t\t\t\t\t  'title'    => $asmbl_id, \n\t\t\t\t\t\t\t  'molecule' => 'dna', \n\t\t\t\t\t\t\t  );\n\t$asmseq->addattr(\"class\", \"assembly\");\n\t\n\t\n\t#\n\t# Creating a feature-table object which will eventually result in the\n\t# creation of a <Feature-tables> BSML element for the assembly\n\t#\n\tmy $asmFTable = $doc->createAndAddFeatureTable($asmseq);\n\t$logger->logdie(\"asmFTable was not defined\") if (!defined($asmFTable));\n\n\t#\n\t# For this assembly, add all rna features as <Feature> elements\n\t#\n\n\tmy $FGroup;\n\n\tforeach my $feathash (sort @{$asmblhash->{$asmbl_id}}){\n\t    \n\n\t    $asmblctr->{$asmbl_id}->{'featctr'}++;\n\n\t    my $end5         = $feathash->{'end5'};\n\t    my $end3         = $feathash->{'end3'};\n\t    my $locus        = $feathash->{'locus'};\n\t    my $feat_type    = $feathash->{'feat_type'};\n\t    my $feat_name    = $feathash->{'feat_name'};\n\t    my $product_name = $feathash->{'product_name'};\n\n\n\t    if ($feat_type eq 'TE'){\n\t\t$feat_type = 'transposable_element';\n\t    }\n\n\n\t    #\n\t    # Chado stores stand as 1 = forward strand\n\t    #                      -1 = reverse strand\n\t    #\n\t    # BSML stores as \"is complement\" 0 = false\n\t    #                                1 = true\n\t    #\n\t    my $complement;\n\t    if ($end3 > $end5){\n\t\t$complement = 0;\n\t    }\n\t    elsif ($end5 > $end3){\n\t\t$complement = 1;\n\t\t($end5, $end3) = ($end3, $end5);\n\t    }\n\t    else{\n\t\t$logger->logdie(\"end3 '$end3' = end5 '$end5'\");\n\t    }\n\n\t    #\n\t    # Convert to space-based coordinate\n\t    #\n\t    $end5--;\n\n\t    \n\t    #\n\t    # Create feature group\n\t    #\n\t    $FGroup = $doc->createAndAddFeatureGroup(\n\t\t\t\t\t\t     $asmseq,\n\t\t\t\t\t\t     '',\n\t\t\t\t\t\t     \"$feat_name\"\n\t\t\t\t\t\t     );  \n\n\t    my $Feat = $doc->createAndAddFeatureWithLoc(\n\t\t\t\t\t\t\t$asmFTable,\n\t\t\t\t\t\t\t\"$feat_name\",\n\t\t\t\t\t\t\t'',\n\t\t\t\t\t\t\t'$feat_type',\n\t\t\t\t\t\t\t'',\n\t\t\t\t\t\t\t'',\n\t\t\t\t\t\t\t$end5,\n\t\t\t\t\t\t\t$end3,\n\t\t\t\t\t\t\t$complement\n\t\t\t\t\t\t\t);\n\n\n\t    my $xref = $doc->createAndAddCrossReference(\n\t\t\t\t\t\t\t'parent'          => $Feat,\n\t\t\t\t\t\t\t'id'              => ++$crossrefctr,\n\t\t\t\t\t\t\t'database'        => $xref_database,\n\t\t\t\t\t\t\t'identifier'      => $feat_name,\n\t\t\t\t\t\t\t'identifier-type' => 'current'\n\t\t\t\t\t\t\t);\n\n\n\t    $logger->logdie(\"Feat was not defined\") if (!defined($Feat));\n\t    \n\n\t    $Feat->addattr('class', \"$feat_type\");\n\n\t    if ($locus ne 'NULL'){\n\t\t$doc->createAndAddBsmlAttribute(\n\t\t\t\t\t\t$Feat, \n\t\t\t\t\t\t'locus', \n\t\t\t\t\t\t\"$locus\"\n\t\t\t\t\t\t);\n\t    }\n\n\t    if ($product_name ne 'NULL'){\n\n\t\t$doc->createAndAddBsmlAttribute(\n\t\t\t\t\t\t$Feat, \n\t\t\t\t\t\t'gene product name', \n\t\t\t\t\t\t\"$product_name\"\n\t\t\t\t\t\t);\n\t    }\n\n\t}\n\n\t$logger->info(\"Writing BSML document $outdir/$asmbl_id.bsml\");\n\t\n\t$doc->write(\"$outdir/$asmbl_id.bsml\");\n\t\n\tif(! -e \"$outdir/$asmbl_id.bsml\"){\n\t    $logger->error(\"File not created $outdir/$asmbl_id.bsml\");\n\t}\n\t\n\tif($dtd){\n\t    my $dtdvalid = `$ENV{DTDVALID} $outdir/$asmbl_id.bsml --dtd $dtd`;\n\t    if($dtdvalid ne '0'){\n\t\t$logger->warn(\"DTD validation failed for $outdir/$asmbl_id.bsml\");\n\t    }\n\t    elsif($dtdvalid eq '0') {\n\t\t$logger->info(\"DTD validation passed for $outdir/$asmbl_id}.bsml\");\n\t    }\n\t}\n\tif($schema){\n\t    my $schemavalid = `$ENV{SCHEMAVALID} $outdir/$asmbl_id.bsml --schema $schema`;\n\t    if ($schemavalid ne '0'){\n\t\t$logger->warn(\"XML Schema validation failed for $outdir/$asmbl_id.bsml\");\n\t    }\n\t    elsif ($schemavalid eq '0'){\n\t\t$logger->info(\"XML schema validation passed for $outdir/$asmbl_id.bsml\");\n\t    }\n\t}\n\tchmod 0777, \"$outdir/$asmbl_id.bsml\";\n    }\n\n\n    $logger->info(\"Assemblies counted: $asmblctr->{'asmblcount'}\");\n    $logger->info(\"Number of features counted per assembly\\n\");\n    foreach my $assembly (keys %{$asmblctr}){\n\tnext if ($assembly eq 'asmblcount');\n\t$logger->info(\"assembly '$assembly' feature count '$asmblctr->{$assembly}->{'featctr'}'\");\n    }\n\n\n\n}\n\n#--------------------------------------------------------\n# verify_and_set_outdir()\n#\n#\n#--------------------------------------------------------\nsub verify_and_set_outdir {\n\n    my ( $outdir, $option) = @_;\n\n    $logger->debug(\"Verifying and setting output directory\") if ($logger->is_debug());\n\n    #\n    # strip trailing forward slashes\n    #\n    $outdir =~ s/\\/+$//;\n    \n    #\n    # set to current directory if not defined\n    #\n     if (!defined($outdir)){\n\tif (!defined($option)){\n\t    $outdir = \".\" \n\t}\n\telse{\n\t    $outdir = $option;\n\t}\n    }\n\n    #\n    # verify whether outdir is in fact a directory\n    #\n    $logger->fatal(\"$outdir is not a directory\") if (!-d $outdir);\n\n    #\n    # verify whether outdir has write permissions\n    #\n    $logger->fatal(\"$outdir does not have write permissions\") if ((-e $outdir) and (!-w $outdir));\n\n\n    $logger->debug(\"outdir is set to:$outdir\") if ($logger->is_debug());\n\n    #\n    # store the outdir in the environment variable\n    #\n    \n    return $outdir;\n    \n}#end sub verify_and_set_outdir()\n\n\n#----------------------------------------------------------------\n# print_usage()\n#\n#----------------------------------------------------------------\nsub print_usage {\n\n    print STDERR \"\\nSAMPLE USAGE:  $0 -D database -G genus -S species -f infile [-d debug_level] [-h] [-l log4perl] [-o outdir] [-s schema] [-t dtd] -y orgtype -z ftype\\n\";\n    print STDERR \"  -D|--database         = Legacy organism database name\\n\";\n    print STDERR \"  -G|--genus            = genus\\n\";\n    print STDERR \"  -S|--species          = species\\n\";\n    print STDERR \"  -f|--infile           = Tab-delimited file containing feature data\\n\";\n    print STDERR \"  -d|--debug_level      = Optional - Coati::Logger log4perl logging level.  Default debug level is 0\\n\";\n    print STDERR \"  -h|--help             = Print this usage help statement\\n\";\n    print STDERR \"  -l|--log4perl         = Optional - Coati::Logger log4perl log file.  Default is /tmp/db2bsml.pl.log\\n\";\n    print STDERR \"  -o|--outdir           = Optional - Directory to write the BSML gene model documents to. Default directory is current working directory\\n\";\n    print STDERR \"  -s|--schema           = Optional - schema validation via XML schema validator\\n\";\n    print STDERR \"  -t|--dtd              = Optional - DTD validation via DTD validator\\n\";\n    print STDERR \"  -y|--orgtype          = organism type e.g. euk, prok or ntprok\\n\";\n    print STDERR \"  -z|--ftype            = feature type either 'rna' or 'te' or 'repeat'\\n\";\n    exit 1;\n\n}",
      "options": {
        "database": "Legacy organism database name e.g. \"tba1\"\n\n=item B<--genus,-G>\n    \n    Legacy organism database name e.g. \"tba1\"\n\n=item B<--infile,-f> \n\n    Tab-delimited file containing the feature data\n\n=item B<--debug_level,-d> \n\n    Optional -- Coati::Logger log4perl logging level.  Default debug_level is 0\n\n=item B<--help,-h>\n\n    Print this help\n\n=item B<--log4perl,-l>\n    \n    Optional -- Coati::Logger log4perl log file.  Default is /tmp/rna2bsml.pl.log\n\n=item B<--outdir,-o> \n\n    Optional -- Directory to write BSML gene model documents.  Default directory is current working directory\n\n=item B<--schema,-s>\n\n    Optional -- Schema to validate against. If blank validate to inline schema\n\n=item B<--dtd,-t>\n\n    Optional -- DTD validation via the DTD validator\n\n=item B<--orgtype,-y>\n\n    organism type e.g. euk, prok or ntprok\n\n=item B<--ftype,-z>\n\n    feature type either 'rna', 'te', or 'repeat'\n\n=back"
      },
      "contact": null
    },
    {
      "tool": "rnammer",
      "converter_script": "rnammer2bsml.pl",
      "name": "RNAmmer2bsml.pl - convert RNAmmer output to BSML",
      "synopsis": "USAGE: RNAmmer2bsml.pl \n        --input=/path/to/rnammerfile \n        --output=/path/to/output.bsml\n        --fasta_input=/path/to/fastafile\n        --id_repository=/path/to/id_repository\n        --project=aa1 \n        [ --gzip_output=1       \n          --log=/path/to/logfile \n          --debug=3\n        ]",
      "description": "This script is used to convert the output from a RNAmmer search into BSML.",
      "options": {
        "input": "Input file file from a RNAmmer search.",
        "output": "Output BSML file (will be created, must not exist)",
        "fasta_input": "The input file that was used as input for the RNAmmer run",
        "id_repository": "Path to the project's id repository",
        "gzip_output": "Optional. A non-zero value will make compressed output.",
        "debug": "Debug level.  Use a large number to turn on verbose debugging.",
        "project": "Required. Project ID.  Used in creating feature ids. \n    If 'aa1' is passed, repeat feature IDs created are like aa1.repeat_region.4231.1\n    If 'parse' is passed, will parse from already present ids.",
        "log": "Log file",
        "help": "This help message"
      },
      "contact": "Gaurav Jain gjain@som.umaryland.edu =cut use warnings; use strict; use Getopt::Long qw(:config no_ignore_case no_auto_abbrev); use Pod::Usage; use Ergatis::Logger; use Ergatis::IdGenerator; use Chado::Gene; use BSML::GenePredictionBsml; use BSML::BsmlBuilder; my $input; # Input file name my $output; # Output file name my $fasta_input; # fasta input to RNAmmer my $idcreator; # Ergatis::IdGenerator object my $bsml; # BSML::BsmlBuilder object my $data = []; # parsed RNAmmer data my $debug = 4; # debug value. defaults to 4 (info) my $parse_project =0; my %options = (); my $results = GetOptions (\\%options, 'input|i=s', 'output|o=s', 'fasta_input|a=s', 'project|p=s', 'log|l=s', 'id_repository|r=s', 'gzip_output|g=s', 'debug=s', 'help|h') || &_pod; # Set up the logger my $logfile = $options{'log'} || Ergatis::Logger::get_default_logfilename(); my $logger = new Ergatis::Logger('LOG_FILE'=>$logfile, 'LOG_LEVEL'=>$options{'debug'}); $logger = $logger->get_logger(); ## make sure all passed options are peachy &check_parameters(\\%options); # Use the Gene.pm module if there exists a non-empty input # otherwise just dump an 'empty' bsml file. $data = &parse_RNAmmer_input( $input ); $bsml = &generateBsml( $data ); $bsml->writeBsml( $output, '', $options{'gzip_output'}); exit (0); ################ SUBS ###################### sub parse_RNAmmer_input { # Open the input file and parse the data into an array of gene models. my $infile = shift; my $genes; print(\"\\n\\ninput file is : $infile\\n\"); ## open the input file for parsing open (IN,\"< $infile\") || $logger->logdie(\"can't open input file for reading\"); ## Strip out uninteresting lines of data from the file #---- will uncomment later ----- my %rawdata; while (<IN>) { my @cols = split; unless( $options{'project'} && $options{'project'} ne 'parse' ){ my $seq_id = $cols[0]; $options{'project'} = $1 if( $seq_id =~ /^([^\\.]+)\\./ ); } #check whitespace, no warn next if ( /^\\s*$/ ); ## make sure we don't parse the RNAmmer output header lines next if ( /^\\#\\#gff-version2/i || /^sequence.*bounds.*cove/i || /^name.*end.*score/i || /\\-\\-.*\\-\\-/); ## there should be 9 elements in cols, unless we have an unrecognized format. # seqname source feature start end score +/- frame attribute # --------- ----------- ------- ------ ------ ----- --- ----- --------- # Contig520 RNAmmer-1.2 rRNA 273038 273152 97.6 + . 5s_rRNA # Contig520 RNAmmer-1.2 rRNA 520669 520783 95.3 + . 5s_rRNA unless (scalar @cols == 9) { $logger->error(\"the following RNAmmer_scan line was not recognized and could not be parsed:\\n$_\\n\") if ($logger->is_error); next; } ## add this data row to this sequence push( @{$rawdata{shift @cols}}, \\@cols ); } close IN; ## loop through each of the matches that we found and make a entries in the genes array. for my $seqid (keys %rawdata) { ## loop through each array reference of this key, adding to the data array as necessary. foreach my $arr ( @{$rawdata{$seqid}} ) { #print \"arr[2]= $$arr[2]\\n arr[3] = $$arr[3]\\n\\n\"; ## Determine strandedness my $complement = ($$arr[5] eq \"-\") ? 1 : 0; ## correct for interbase numbering if ($complement) { $$arr[3]--; ## End } else { $$arr[2]--; ## begin } ## First, create the gene model object my $currGene = new Chado::Gene ( $idcreator->next_id( 'type' => 'gene', 'project' => $options{project} ), ($complement) ? $$arr[3] : $$arr[2], ($complement) ? $$arr[2] : $$arr[3], $complement, $seqid ); ## Next, with the same coords, create the rRNA feature my $rrna_feat_id = $currGene->addFeature( $idcreator->next_id ( 'type' => 'rRNA', 'project' => $options{project} ), ($complement) ? $$arr[3] : $$arr[2], ($complement) ? $$arr[2] : $$arr[3], $complement, 'rRNA' ); ## add score attribute to feature $currGene->addFeatureAttribute( $rrna_feat_id, 'score', $$arr[4], ); ## add strand attribute to feature #$currGene->addFeatureAttribute( # $rrna_feat_id, # 'strand', # $$arr[5], # ); ## add frame attribute to feature #$currGene->addFeatureAttribute( # $rrna_feat_id, # 'frame', # $$arr[6], # ); ## add gene_product_name(\"attribute\" in RNAmmer output) attribute to feature $currGene->addFeatureAttribute( $rrna_feat_id, 'gene_product_name', $$arr[7], ); ## an exon needs to be added. if ($complement) { ## just add the whole thing as an exon &add_exon_and_cds($currGene, $$arr[2], $$arr[3], $complement); } else { &add_exon_and_cds($currGene, $$arr[3], $$arr[2], $complement); } # Handle Group now: my $count = $currGene->addToGroup( $currGene->getId, { 'all' => 1} ); &_die(\"Nothing was added to group\") unless ($count); push (@{$genes}, $currGene); } } return $genes; } sub add_exon_and_cds { # Add an exon and cds to the gene object. These features should share # start and stop coordinates. my ($gm, $start, $stop, $complement) = @_; foreach my $type (qw(exon CDS)) { # Add the exon or CDS to the gene model object $gm->addFeature( $idcreator->next_id( 'type' => $type, 'project' => $options{project} ), ($complement) ? $stop : $start, ($complement) ? $start : $stop, $complement, $type ); } } sub generateBsml { my $data = shift; print \"data = $data\\n\\n\"; #Create the document my $gene_pred = new BSML::GenePredictionBsml( 'RNAmmer' ); my $doc = $gene_pred->{'doc'}; unless($data && @{$data} > 0) { $gene_pred->addSequence( '', $fasta_input ); } foreach my $gene( @{$data} ) { $gene_pred->addGene($gene); my $addedTo = $gene_pred->addSequence($gene->{'seq'}, $fasta_input); $logger->logdie(\"Could not find identifier \".$gene->{'seq'}.\" in $fasta_input\") unless($addedTo || !(-e $fasta_input)); $logger->logdie(\"fasta_input file: '$fasta_input' does not exist\") unless(-e $fasta_input); } return $gene_pred; } sub check_parameters { # Parse options hash, make sure certain ones exist and have meaningful values. # Also take the time to setup some globally used values. my $error = ''; &_pod if $options{'help'}; ## make sure input file was given and exists if ($options{'input'}) { if (! -e $options{'input'}) { $logger->logdie(\"input file $options{'input'} does not exist\") } $input = $options{'input'}; } else { $error .= \"--input_file is a required opttion\\n\"; } ## make sure output file was given and doesn't exist yet if ($options{'output'}) { $output = $options{'output'}; } else { $error .= \"--output_file is a required option\\n\"; } ## Make sure we're given the input fasta if ($options{'fasta_input'}) { $fasta_input = $options{'fasta_input'}; } else { $error .= \"--fasta_input is a required option\\n\"; } ## Now set up the id generator stuff if ($options{'id_repository'}) { # we're going to generate ids $idcreator = new Ergatis::IdGenerator('id_repository' => $options{'id_repository'}); #---------- Set the pool size --------------- $idcreator->set_pool_size('gene'=>30,'rRNA'=>30,'exon'=>30,'CDS'=>30); } else { $error .= \"--id_repository is a required option\\n\"; } # The debug option is not required... but let's set it up if it's been given if ($options{'debug'}) { $debug = $options{'debug'}; } ## set default if project not passed. $options{project} ||= 'unknown'; &_die($error) if $error; return 1; } # END OF check_parameters sub _pod { # Used to display the perldoc help. pod2usage( {-exitval => 0, -verbose => 2} ); } sub _die { # Kinda like a hitman, this is called when something needs to DIE. my $msg = shift; $logger->logdie($msg); }"
    },
    {
      "tool": "seg",
      "converter_script": "seg2bsml.pl",
      "name": "seg2bsml.pl - convert seg output to bsml.",
      "synopsis": "USAGE: seg2bsml.pl\n                --input|-i seg.raw\n                --seg_input_file|-s model.fsa\n                --output|-o seg.bsml\n                --project|-p foo\n                --id_repository|-r /path/to/repository\n              [ --log|-l seg2bsml.log\n                --help\n                --debug  (currently unimplemented)\n              ]",
      "description": "This program converts raw seg output into bsml.  Currently, the encoding is of\n    type repeat_region, but when a satisfactory term is added to the ontology this\n    script should be updated to more accurately represent the masked regions.",
      "options": {
        "input": "- The raw seg output (from a seg run using the -l option)",
        "seg_input_file": "- The file used as input for seg",
        "help": "- Display this help"
      },
      "contact": "Jason Inman jinman@tigr.org =begin comment ## legal values for status are active, inactive, hidden, unstable status: active keywords: keywords to search for your script here =end comment =cut use Getopt::Long qw(:config no_ignore_case no_auto_abbrev); use Pod::Usage; use Ergatis::IdGenerator; use Ergatis::Logger; use BSML::BsmlRepository; use BSML::BsmlBuilder; use BSML::BsmlParserTwig; my %opts = (); my $input_file; my $output_file; my $seg_input_file; my $id_repository; my $project; my $results = GetOptions(\\%opts, 'input|i=s', 'seg_input_file|s=s', 'output|o=s', 'project|p=s', 'log|l=s', 'id_repository|r=s', 'command_id=s', # passed by workflow 'logconf=s', # passed by workflow (not used) 'debug=s', 'help|h', ) || pod2usage(); my $logfile = $opts{'log'} || Ergatis::Logger::get_default_logfilename(); my $logger = new Ergatis::Logger('LOG_FILE'=>$logfile, 'LOG_LEVEL'=>$opts{'debug'}); $logger = $logger->get_logger(); # display documentation if( $opts{'help'} ){ pod2usage( {-exitval=>0, -verbose => 2, -output => \\*STDOUT} ); } ## make sure all passed options are peachy &check_parameters(\\%opts); ## we want a new doc my $doc = new BSML::BsmlBuilder(); ## we're going to generate ids my $idcreator = new Ergatis::IdGenerator( id_repository => $id_repository ); ## open the input file for parsing open (my $ifh, $input_file) || $logger->logdie(\"can't open input file for reading\"); ## parse the data from the input file my @data = (); my $seqid; while (<$ifh>) { next unless (/^>(\\S+)\\((\\d+)-(\\d+)\\) complexity=(\\d+\\.\\d+ \\([\\d\\.\\/]+\\))\\n/); my %row; if ($seqid) { ## Normally, seg is fine for this, but for our bsml, we don't like it: $logger->logdie(\"Multiple input seqs detected!\") if ($seqid ne $1); } else { $seqid = $1; } $row{'start'} = $2; $row{'end'} = $3; $row{'complexity'} = $4; push @data, \\%row; } ## Begin putting seq data into the bsml doc my $seq = $doc->createAndAddSequence($seqid, undef, '', 'aa', 'polypeptide'); $seq->addBsmlLink('analysis','#seg_analysis','input_of'); ## seq data import: $doc->createAndAddSeqDataImport( $seq, 'fasta', $seg_input_file, '', $seqid ); ## feature table: my $ft = $doc->createAndAddFeatureTable($seq); my $mask; foreach my $row (@data) { # create and add the mask ## Remember to change this away from repeat_region to masked region or whatever the ## ontology stores it as eventually my $id = $idcreator->next_id( project => $project, type => 'repeat_region' ); $mask = $doc->createAndAddFeature($ft,$id, '','repeat_region'); $mask->addBsmlLink('analysis','#seg_analysis','computed_by'); ## make it interbase numbering: $$row{'start'}--; $$row{'end'}--; $mask->addBsmlIntervalLoc( $$row{'start'}, $$row{'end'}, 0); ## add the properties (complexity) to the masked region. $doc->createAndAddBsmlAttributes( $mask, 'complexity', $$row{'complexity'} ); } ## add the analysis: $doc->createAndAddAnalysis( id => 'seg_analysis', sourcename => $output_file ); ## write it out: $doc->write($output_file); ## Bob's yer uncle, mate! exit(0); sub check_parameters { my $error = ''; # input file checking if (exists $opts{'input'}) { $input_file = $opts{'input'}; ## make sure input file exists $error .= \"Input file $input_file does not exist.\\n\" unless (-e $input_file); } else { $error .= \"No input file specified.\\n\"; } # output file checking if (exists $opts{'output'}) { $output_file = $opts{'output'}; } else { $error .= \"No output file specified.\\n\"; } # housekeeping stuff if (exists $opts{'project'}) { $project = $opts{'project'}; } else { $error .= \"No project specified.\\n\"; } if (exists $opts{'id_repository'}) { $id_repository = $opts{'id_repository'}; unless (-e \"$id_repository/valid_id_repository\") { $error .= \"$id_repository does not appear to be a valid id repository.\\n\"; } if (exists $opts{'seg_input_file'}) { $seg_input_file = $opts{'seg_input_file'}; unless (-e $seg_input_file) { $error .= \"Can't find (seg input) $seg_input_file.\\n\"; } } else { $error .= \"No seg_input_file specified.\\n\"; } } else { $error .= \"No id_repository specified.\\n\"; } if ($error) { $logger->logdie(\"$error\"); } }"
    },
    {
      "tool": "signalp",
      "converter_script": "signalp2bsml.pl",
      "name": "signalp2bsml.pl - convert SignalP output to BSML",
      "synopsis": "USAGE: signalp2bsml.pl --input=/path/to/signalp_file --output=/path/to/output.bsml",
      "description": "This script is used to convert the output from SignalP into BSML.",
      "options": {
        "input": "Input file file from a signalp run.",
        "debug": "Debug level.  Use a large number to turn on verbose debugging.",
        "log": "Log file",
        "output": "Output BSML file (will be created, must not exist)",
        "help": "This help message"
      },
      "contact": "Brett Whitty bwhitty@tigr.org =cut use warnings; use strict; use Getopt::Long qw(:config no_ignore_case no_auto_abbrev); use Pod::Usage; use Ergatis::Logger; use BSML::BsmlRepository; use Ergatis::IdGenerator; use BSML::BsmlBuilder; use BSML::BsmlParserTwig; use Data::Dumper; my %options = (); my $results = GetOptions (\\%options, 'input|i=s', 'query_file_path|q=s', 'output|o=s', 'debug|d=s', 'command_id=s', ## passed by workflow 'logconf=s', ## passed by workflow (not used) 'project|p=s', 'id_repository=s', 'log|l=s', 'help|h') || pod2usage(); my $logfile = $options{'log'} || Ergatis::Logger::get_default_logfilename(); my $logger = new Ergatis::Logger('LOG_FILE'=>$logfile, 'LOG_LEVEL'=>$options{'debug'}); $logger = $logger->get_logger(); # display documentation if( $options{'help'} ){ pod2usage( {-exitval=>0, -verbose => 2, -output => \\*STDOUT} ); } ## make sure all passed options are peachy &check_parameters(\\%options); ## we want to create ids unique to this document, which will be replaced later. they must ## contain the prefix that will be used to look up a real id, such as ath1.gen.15 my $next_id = 1; ## we want a new doc my $doc = new BSML::BsmlBuilder(); ## we're going to generate ids my $idcreator = new Ergatis::IdGenerator( id_repository => $options{'id_repository'}); $idcreator->set_pool_size( 'signal_peptide' => 25 ); ## open the input file for parsing open (my $ifh, $options{'input'}) || $logger->logdie(\"can't open input file for reading\"); my $signalp_version = \"4.0\"; my @sequence_ids; my %deflines; my %result_ref_hash; my $temp; my $next_seq_flag = 0; while (<$ifh>) { chomp; # Use v3.0 format if this version of SignalP is used if ($_ =~ /SignalP 3.0 predictions/) { $signalp_version = \"3.0\"; } if ($signalp_version eq '3.0'){ ##recognize start of results for an individual sequence if ($next_seq_flag || /^-{70}/) { $logger->debug(\"start of sequence results entry found\") if($logger->is_debug()); my %nn_results; my %hmm_results; my $defline; if ($next_seq_flag) { $next_seq_flag = 0; $defline = $_; } else { $defline = <$ifh>; } chomp $defline; $defline =~ s/^>//; $defline =~ /^(\\S+)/; my $sequence_id = $1; $logger->debug(\"sequence id is '$sequence_id'\") if($logger->is_debug()); push(@sequence_ids, $sequence_id); $deflines{$sequence_id} = $defline; while (my $result_line = <$ifh>) { chomp $result_line; if ($result_line =~ /^SignalP-NN result:/) { $logger->debug(\"parsing signalp nn results\") if($logger->is_debug()); $temp = <$ifh>; chomp $temp; $temp =~ /length = (\\d+)/ || $logger->error(\"Couldn't parse sequence length in NN result.\") if ($logger->is_error); $temp = <$ifh>; # we will discard the header line $temp = <$ifh>; chomp $temp; $temp =~ /^ max\\. C\\s+([^\\s]+)\\s+([^\\s]+)\\s+([^\\s]+)\\s+([^\\s]+)/ || $logger->logdie(\"Couldn't parse max. C line in NN result\"); $nn_results{'maxc_pos'} = $1; $nn_results{'maxc_value'} = $2; $nn_results{'maxc_cutoff'} = $3; $nn_results{'maxc_signal_peptide'} = $4; $temp = <$ifh>; chomp $temp; $temp =~ /^ max\\. Y\\s+([^\\s]+)\\s+([^\\s]+)\\s+([^\\s]+)\\s+([^\\s]+)/ || $logger->logdie(\"Couldn't parse max. Y line in NN result\"); $nn_results{'maxy_pos'} = $1; $nn_results{'maxy_value'} = $2; $nn_results{'maxy_cutoff'} = $3; $nn_results{'maxy_signal_peptide'} = $4; $temp = <$ifh>; chomp $temp; $temp =~ /^ max\\. S\\s+([^\\s]+)\\s+([^\\s]+)\\s+([^\\s]+)\\s+([^\\s]+)/ || $logger->logdie(\"Couldn't parse max. S line in NN result\"); $nn_results{'maxs_pos'} = $1; $nn_results{'maxs_value'} = $2; $nn_results{'maxs_cutoff'} = $3; $nn_results{'maxs_signal_peptide'} = $4; $temp = <$ifh>; chomp $temp; $temp =~ /^ mean S\\s+([^\\s]+)\\s+([^\\s]+)\\s+([^\\s]+)\\s+([^\\s]+)/ || $logger->logdie(\"Couldn't parse mean S line in NN result\"); $nn_results{'means_pos'} = $1; $nn_results{'means_value'} = $2; $nn_results{'means_cutoff'} = $3; $nn_results{'means_signal_peptide'} = $4; $temp = <$ifh>; chomp $temp; $temp =~ /^ D\\s+([^\\s]+)\\s+([^\\s]+)\\s+([^\\s]+)\\s+([^\\s]+)/ || $logger->logdie(\"Couldn't parse D line in NN result\"); $nn_results{'d_pos'} = $1; $nn_results{'d_value'} = $2; $nn_results{'d_cutoff'} = $3; $nn_results{'d_signal_peptide'} = $4; $temp = <$ifh>; chomp $temp; if ($temp =~ /^# Most likely cleavage site between pos\\. (\\d+) and (\\d+): ([A-Z\\-]+)$/) { $nn_results{'cleavage_site_position'} = $1.\"-\".$2; } $result_ref_hash{$sequence_id, 'nn'} = \\%nn_results; } elsif ($result_line =~ /^SignalP-HMM result:/) { $logger->debug(\"parsing signalp hmm results\") if($logger->is_debug()); $temp = <$ifh>; # we will discard the header line $temp = <$ifh>; chomp $temp; ## If HMM predicts no signal peptide, prediction will be 'Non-secretory protein' $temp =~ /^Prediction: (.*)$/ || $logger->logdie(\"Couldn't parse prediction line in HMM result\"); $hmm_results{'prediction'} = $1; $temp = <$ifh>; chomp $temp; $temp =~ /^Signal peptide probability: (.*)$/ || $logger->logdie(\"Couldn't parse signal peptide probability line in HMM result\"); $hmm_results{'signal_peptide_probability'} = $1; $temp = <$ifh>; chomp $temp; if ($temp =~ /^Signal anchor probability: (.*)$/) { $hmm_results{'signal_anchor_probability'} = $1; $temp = <$ifh>; chomp $temp; } $temp =~ /^Max cleavage site probability: ([0-9]\\.[0-9]{3}) between pos\\. ([0-9\\-]+)\\s+and\\s+([0-9\\-]+)/ || $logger->logdie(\"Couldn't parse max cleavage site probability line in HMM result\"); $hmm_results{'max_cleavage_site_probability'} = $1; $hmm_results{'cleavage_site_position'} = $2.\"-\".$3; $result_ref_hash{$sequence_id, 'hmm'} = \\%hmm_results; last; } elsif ($result_line =~ /^-{70}/) { ## we'll hit this if result file contains only nn results $logger->debug(\"found beginning of new results block after nn results\\nshould only occur if run method was 'nn' only\") if($logger->is_debug()); $next_seq_flag = 1; ## so flag that we've hit the start of next sequence's results last; } } } } else { # We are using signalp v4.0 $temp = <$ifh>; #read SignalP version line my %nn_results; while (my $result_line = <$ifh>) { chomp $result_line; if ($result_line =~ /^# Measure/) { # Column fields $logger->debug(\"parsing signalp nn results\") if($logger->is_debug()); $temp = <$ifh>; # In v4.0 cutoff and Yes/No were removed from all except for \"D\" lines chomp $temp; $temp =~ /^ max\\. C\\s+([^\\s]+)\\s+([^\\s]+)/ || $logger->logdie(\"Couldn't parse max. C line in NN result\"); $nn_results{'maxc_pos'} = $1; $nn_results{'maxc_value'} = $2; $temp = <$ifh>; chomp $temp; $temp =~ /^ max\\. Y\\s+([^\\s]+)\\s+([^\\s]+)/ || $logger->logdie(\"Couldn't parse max. Y line in NN result\"); $nn_results{'maxy_pos'} = $1; $nn_results{'maxy_value'} = $2; $temp = <$ifh>; chomp $temp; $temp =~ /^ max\\. S\\s+([^\\s]+)\\s+([^\\s]+)/ || $logger->logdie(\"Couldn't parse max. S line in NN result\"); $nn_results{'maxs_pos'} = $1; $nn_results{'maxs_value'} = $2; $temp = <$ifh>; chomp $temp; $temp =~ /^ mean S\\s+([^\\s]+)\\s+([^\\s]+)/ || $logger->logdie(\"Couldn't parse mean S line in NN result\"); $nn_results{'means_pos'} = $1; $nn_results{'means_value'} = $2; $temp = <$ifh>; chomp $temp; $temp =~ /^ D\\s+([^\\s]+)\\s+([^\\s]+)\\s+([^\\s]+)\\s+([^\\s]+)/ || $logger->logdie(\"Couldn't parse D line in NN result\"); $nn_results{'d_pos'} = $1; $nn_results{'d_value'} = $2; $nn_results{'d_cutoff'} = $3; $nn_results{'d_signal_peptide'} = $4; } elsif ($result_line =~ /^Name=(\\S+)/) { $logger->debug(\"found ending of current results block for nn results\") if($logger->is_debug()); my $sequence_id = $1; if ($result_line =~ /Cleavage site between pos\\. (\\d+) and (\\d+):/) { $nn_results{'cleavage_site_position'} = $1.\"-\".$2; } my %results = %nn_results; $result_ref_hash{$sequence_id, 'nn'} = \\%results; %nn_results = (); push(@sequence_ids, $sequence_id); $deflines{$sequence_id} = $sequence_id; } } } } ## map these hash keys to ontology terms my %nn_onto = ( 'maxs_pos' => 's-position', 'maxs_value' => 's-score', 'maxs_cutoff' => 's-cutoff', 'maxs_signal_peptide' => 's-prediction', 'means_pos' => 's-mean-position', 'means_value' => 's-mean', 'means_cutoff' => 's-mean-cutoff', 'means_signal_peptide' => 's-mean-prediction', 'd_pos' => 'd-position', 'd_value' => 'd-score', 'd_cutoff' => 'd-cutoff', 'd_signal_peptide' => 'd-prediction', 'maxc_pos' => 'c-position', 'maxc_value' => 'c-score', 'maxc_cutoff' => 'c-cutoff', 'maxc_signal_peptide' => 'c-prediction', 'maxy_pos' => 'y-position', 'maxy_value' => 'y-score', 'maxy_cutoff' => 'y-cutoff', 'maxy_signal_peptide' => 'y-prediction', ); foreach my $s(@sequence_ids) { my $seq = $doc->createAndAddSequence( $s, # id $s, # title '', # length 'aa', # molecule 'polypeptide' # class ); $doc->createAndAddSeqDataImport( $seq, 'fasta', $options{'query_file_path'}, '', $s ); $doc->createAndAddBsmlAttribute( $seq, 'defline', $deflines{$s}, ); if ($signalp_version eq \"3.0\") { foreach my $a(('nn','hmm')) { $seq->addBsmlLink('analysis', '#signalp_'.$a.'_analysis', 'input_of'); } } else { foreach my $a(('best','notm')) { $seq->addBsmlLink('analysis', '#signalp_'.$a.'_analysis', 'input_of'); } } my $ft; ## create BSML for nn predictions if ($result_ref_hash{$s,'nn'}->{'cleavage_site_position'}) { if (!$ft){ $ft = $doc->createAndAddFeatureTable($seq); } ## parse out cleavage site coords my @coords = parse_position($result_ref_hash{$s,'nn'}->{'cleavage_site_position'}); my $site_pos = shift(@coords); ## create signal peptide feature my $signalp_id = $idcreator->next_id( project => $options{project}, type => 'signal_peptide', ); my $signalp = $doc->createAndAddFeature($ft, $signalp_id, '', 'signal_peptide'); $signalp->addBsmlIntervalLoc('0', $site_pos); $signalp->addBsmlLink('analysis', '#signalp_nn_analysis', 'computed_by'); foreach my $att(( 'maxs_pos', 'maxs_value', 'maxs_cutoff', 'maxs_signal_peptide', 'means_pos', 'means_value', 'means_cutoff', 'means_signal_peptide', 'd_pos', 'd_value', 'd_cutoff', 'd_signal_peptide', )) { $doc->createAndAddBsmlAttribute( $signalp, $nn_onto{$att}, $result_ref_hash{$s,'nn'}->{$att} ); } ## create cleavage site feature my $csite_id = $idcreator->next_id( project => $options{project}, type => 'cleavage_site', ); my $cleavage_site = $doc->createAndAddFeature($ft, $csite_id, '', 'cleavage_site'); $cleavage_site->addBsmlLink('analysis', '#signalp_nn_analysis', 'computed_by'); $cleavage_site->addBsmlSiteLoc($site_pos); $doc->createAndAddBsmlAttribute( $cleavage_site, 'max_cleavage_site_probability', $result_ref_hash{$s,'nn'}->{'max_cleavage_site_probability'} ); foreach my $att(( 'maxc_pos', 'maxc_value', 'maxc_cutoff', 'maxc_signal_peptide', 'maxy_pos', 'maxy_value', 'maxy_cutoff', 'maxy_signal_peptide', )) { $doc->createAndAddBsmlAttribute( $cleavage_site, $nn_onto{$att}, $result_ref_hash{$s,'nn'}->{$att} ); } } if ($signalp_version eq \"3.0\") { ## create BSML for hmm predictions if ($result_ref_hash{$s,'hmm'}->{'prediction'} ne 'Non-secretory protein') { if (!$ft){ $ft = $doc->createAndAddFeatureTable($seq); } ## parse out cleavage site coords my @coords = parse_position($result_ref_hash{$s,'hmm'}->{'cleavage_site_position'}); my $site_pos = shift(@coords); ## create signal peptide feature my $signalp_id = $idcreator->next_id(project => $options{project}, type => 'signal_peptide'); my $signalp = $doc->createAndAddFeature( $ft, $signalp_id, '', 'signal_peptide', ); $signalp->addBsmlIntervalLoc('0', $site_pos); $signalp->addBsmlLink('analysis', '#signalp_hmm_analysis', 'computed_by'); $doc->createAndAddBsmlAttribute( $signalp, 'signal_anchor', $result_ref_hash{$s,'hmm'}->{'signal_anchor_probability'}, ); $doc->createAndAddBsmlAttribute( $signalp, 'signal_probability', $result_ref_hash{$s,'hmm'}->{'signal_peptide_probability'} ); $doc->createAndAddBsmlAttribute( $signalp, 'prediction', $result_ref_hash{$s,'hmm'}->{'prediction'} ); ## prediction can be 'Signal anchor' or 'Signal peptide', signal anchor is uncleaved signal peptide if ($result_ref_hash{$s,'hmm'}->{'prediction'} eq 'Signal peptide') { ## create cleavage site feature my $csite_id = $idcreator->next_id( project => $options{project}, type => 'cleavage_site', ); my $cleavage_site = $doc->createAndAddFeature($ft, $csite_id, '', 'cleavage_site'); $cleavage_site->addBsmlLink('analysis', '#signalp_hmm_analysis', 'computed_by'); $cleavage_site->addBsmlSiteLoc($site_pos); $doc->createAndAddBsmlAttribute( $cleavage_site, 'max_cleavage_site_probability', $result_ref_hash{$s,'hmm'}->{'max_cleavage_site_probability'} ); } } } } ## add the analysis element (stores both v3.0 and v4.0) foreach my $a(('best','notm', 'nn', 'hmm')) { my $analysis = $doc->createAndAddAnalysis( id => 'signalp_'.$a.'_analysis', sourcename => $options{'output'}, program => \"signalp_$a\", algorithm => \"signalp_$a\", ); } ## now write the doc $doc->write($options{'output'}); exit(); sub check_parameters { ## make sure input file exists if (! -e $options{'input'}) { $logger->logdie(\"input file $options{'input'} does not exist\") } ## if (! $options{'query_file_path'}) { $logger->logdie(\"must provide path to query fasta file with --query_file_path\") } $options{'project'} = 'unknown' unless ($options{'project'}); $options{'command_id'} = '0' unless ($options{'command_id'}); return 1; } ## parse_position parses the position field to give an array containing ## start [and stop] sites sub parse_position { my ($position) = @_; if ($position =~ /^\\s*([^\\s]+)\\s*$/) { return split(\"-\", $1); } else { return (); } }"
    },
    {
      "tool": "snap",
      "converter_script": "snap2bsml.pl",
      "name": "snap2bsml.pl - convert snap ZFF output to BSML",
      "synopsis": "USAGE: snap2bsml.pl \n        --input=/path/to/snap.output.file.raw \n        --output=/path/to/output.bsml\n      [ --project=aa1 \n        --fasta_file=/path/to/somefile.fsa \n      ]",
      "description": "This script is used to convert the output from a snap search into BSML.",
      "options": {
        "input": "Input file from a snap search.",
        "debug": "Debug level.  Use a large number to turn on verbose debugging.",
        "fasta_file": "If passed, will create a Seq-data-import element referencing this\n    path.",
        "project": "Project ID.  Used in creating feature ids.  Defaults to 'unknown' if\n    not passed.",
        "log": "Log file",
        "output": "Output BSML file",
        "help": "This help message"
      },
      "contact": "Jason Inman jinman@tigr.org =cut use strict; use Getopt::Long qw(:config no_ignore_case no_auto_abbrev); use Pod::Usage; use Ergatis::Logger; #use Papyrus::TempIdCreator; use Ergatis::IdGenerator::IGSIdGenerator; use BSML::GenePredictionBsml; #use BSML::BsmlRepository; #use BSML::BsmlBuilder; #use BSML::BsmlParserTwig; my %options = (); my $results = GetOptions (\\%options, 'input|i=s', 'output|o=s', 'fasta_file|f=s', 'project|p=s', 'log|l=s', 'command_id=s', ## passed by workflow 'logconf=s', ## passed by workflow (not used) 'seq_class=s', 'id_repo=s', ## project id repository 'debug=s', 'help|h') || pod2usage(); my $logfile = $options{'log'} || Ergatis::Logger::get_default_logfilename(); my $logger = new Ergatis::Logger('LOG_FILE'=>$logfile, 'LOG_LEVEL'=>$options{'debug'}); $logger = $logger->get_logger(); # display documentation if( $options{'help'} ){ pod2usage( {-exitval=>0, -verbose => 2, -output => \\*STDOUT} ); } ## make sure all passed options are peachy &check_parameters(\\%options); ## we want a new doc my $doc = new BSML::BsmlBuilder(); ## we're going to generate ids #my $idcreator = new Papyrus::TempIdCreator(); my $idcreator = new Ergatis::IdGenerator::IGSIdGenerator( id_repository => $options{ 'id_repo' } ); ## open the input file for parsing open (my $ifh, $options{'input'}) || $logger->logdie(\"can't open input file for reading\"); my $seq_id; my ($seq, $ft, $fg); my ($last_group_name, $current_group_name, $current_transcript_id); my ($thing, $id); ## go through the file while (<$ifh>) { ## skip comment lines next if (/^\\#/); chomp; ## has the sequence been defined yet? it's in the first column ## this should happen on the first row only if (/^>(.*)/) { $seq_id = $1; $seq_id =~ s/\\s//g; ## create this sequence, an analysis link, and a feature table $logger->debug(\"adding seq_id $seq_id\") if $logger->is_debug; $seq = $doc->createAndAddSequence($seq_id, undef, '', 'dna', $options{'seq_class'}); $seq->addBsmlLink('analysis', '#snap_analysis'); $ft = $doc->createAndAddFeatureTable($seq); ## also add a link to the fasta file (Seq-data-import) if requested if ($options{'fasta_file'}) { $doc->createAndAddSeqDataImport( $seq, 'fasta', $options{'fasta_file'}, '', $seq_id); } next; # Get out of this loop. We don't need to do anymore with this line. } # If we've reached this point, we're in a data line. Let's begin parsing the columns. # Start with the group name. my @cols = split(/\\t/); if ($cols[8] =~ /($seq_id.*)/) { $current_group_name = $1; } else { $logger->logdie(\"unrecognized format in column 9: $cols[8]\"); } ## if column 9 (group) is defined and is different than the last one we need to ## create a new feature group if ($current_group_name && $current_group_name ne $last_group_name) { ## remember this group name $last_group_name = $current_group_name; ## pull a new gene id $current_transcript_id = $idcreator->next_id( project => $options{project}, type => 'gene', prefix => $options{command_id} ); $logger->debug(\"adding new feature group with parent $current_transcript_id\") if $logger->is_debug; $fg = $doc->createAndAddFeatureGroup( $seq, '', $current_transcript_id ); } ## adjust both positions so that we are numbering from zero $cols[1]--; ## change the + and - symbols in strand column to 0 and 1, respectively if ($cols[3] eq '+') { $cols[3] = 0; } elsif ($cols[3] eq '-') { $cols[3] = 1; } else { $logger->logdie(\"unknown value ($cols[3]) in strand column. expected + or -.\"); } ## handle each of the types we know about if ($cols[0] eq 'Einit' || $cols[0] eq 'Exon' || $cols[0] eq 'Esngl' || $cols[0] eq 'Eterm' ) { &add_feature('exon', $cols[1], $cols[2], $cols[3] ); &add_feature('CDS', $cols[1], $cols[2], $cols[3] ); } else { $logger->logdie(\"unrecognized type: $cols[0]\"); } } ## add the analysis element $doc->createAndAddAnalysis( id => 'snap_analysis', sourcename => $options{'output'}, ); ## now write the doc $doc->write($options{'output'}); exit; sub add_feature { my ($type, $start, $stop, $strand) = @_; $id = $idcreator->next_id( project => $options{project}, type => $type, prefix => $options{command_id} ); $thing = $doc->createAndAddFeature( $ft, $id, '', $type ); $thing->addBsmlLink('analysis', '#snap_analysis', 'computed_by'); $thing->addBsmlIntervalLoc($start, $stop, $strand); $fg->addBsmlFeatureGroupMember( $id, $type ); ## if type is a primary_transcript we need to add a gene too if ($type eq 'primary_transcript') { $thing = $doc->createAndAddFeature( $ft, $current_transcript_id, '', 'gene' ); $thing->addBsmlLink('analysis', '#snap_analysis', 'computed_by'); $thing->addBsmlIntervalLoc($start, $stop, $strand); $fg->addBsmlFeatureGroupMember( $current_transcript_id, 'gene' ); } } sub check_parameters { ## make sure input file exists if (! -e $options{'input'}) { $logger->logdie(\"input file $options{'input'} does not exist\") } $options{'fasta_file'} = '' unless ($options{'fasta_file'}); $options{'project'} = 'unknown' unless ($options{'project'}); $options{'command_id'} = '0' unless ($options{'command_id'}); return 1; }"
    },
    {
      "tool": "snoscan",
      "converter_script": "snoscan2bsml.pl",
      "name": "snoscan2bsml.pl - converts snoscan output to BSML",
      "synopsis": "USAGE: snoscan2bsml.pl \n            --input=/path/to/snoscanfile\n            --output=/path/to/output.bsml\n         [  --project=projectName \n            --class=class of sequence\n            --degug=integer(level of debug)\n            --fasta_file=input file to snoscan\n         ]",
      "description": "snoscan2bsml.pl will take an output file from snoscan, sorted or raw,\nand convert the format to BSML.",
      "options": {
        "input_file": "Input file from the snoscan search.",
        "output_file": "The file will be created",
        "class": "This is used by the workflow (for Id purporses)",
        "project": "Project ID. Used in creating feature IDs.  Defaults to unknown \n    if not passed.",
        "command_id": "The command passed in from the workflow",
        "debug": "Debug level.  Use a large number to turn on verbose debugging.",
        "log": "Log file",
        "help": "This help message."
      },
      "contact": "Kevin Galens kgalens@tigr.org =cut use strict; use Getopt::Long qw(:config no_ignore_case no_auto_abbrev pass_through); use Pod::Usage; use Ergatis::Logger; use BSML::BsmlRepository; use Papyrus::TempIdCreator; use BSML::BsmlBuilder; use BSML::BsmlParserTwig; my %options = (); my $results = GetOptions (\\%options, 'input|i=s', 'output|o=s', 'class|c=s', 'project|p=s', 'command_id=s', #Input from workflow 'log|l=s', 'debug|d=s', 'help|h') || pod2usage(); my $logfile = $options{'log'} || Ergatis::Logger::get_default_logfilename(); my $logger = new Ergatis::Logger('LOG_FILE'=>$logfile, 'LOG_LEVEL'=>$options{'debug'}); $logger = $logger->get_logger(); ## display documentation if( $options{'help'} ){ pod2usage( {-exitval => 0, -verbose => 2, -output => \\*STDERR} ); } ## make sure everything passed was peachy &check_parameters(\\%options); unless($options{'compress_bsml_output'}) { $options{'compress_bsml_output'} = 0; } #Create a new BSML document my $doc = new BSML::BsmlBuilder(); #Create a new id creator my $idcreator = new Papyrus::TempIdCreator(); #Open the input file (.sorted) my $inputFile; #The fasta file header line (Bug 3781) my $defline; #Should be able to handle gzip input without hassle (Bug 2591) my $mode = \"<\"; $mode = \"<:gzip\" if($options{'input'} =~ /\\.gz$/); open (IFH, $mode, \"$options{input}\") or $logger->logdie(\"can't open input file for reading\"); #or die (\"Unable to open output file ($!)\"); #If there was no sorted file made (which is indicated by the #words 'No output generated') then switch the sorted to raw #and open the file again. This means that the user did not #choose to sort the snoscan output and therefore has no #data in the .sorted file and the .raw file should be used #instead. if(<IFH> =~ /^No output generated/) { $inputFile = $options{input}; if(!($inputFile =~ s/sorted/raw/)) { $logger->logdie (\"Input file: $inputFile\\n\"); } close(IFH); print \"Opening $inputFile\\n\"; open(IFH, \"< $inputFile\") or die \"Unable to open $inputFile ($!)\"; } #%data will hold the summary line of output for each snoRNA predicted. my %data; #Holds start and end positions of snoRNAs already predicted. #Key is the location interval and value is the sequence id my %locs = {}; #Go through the input file while(<IFH>) { my @cols = split; if(/^>>/) { unless(@cols == 14 || @cols == 15) { warn (\"Cannot recognize input line\\n(@cols)\"); next; } #Unique ID = seqId (column1) and loc int (col3) #Value is the score of the prediction. Only keeping #high score. if(!(defined($data{\"$cols[1]\".\";;$cols[3]\"})) || $data{\"$cols[1]\".\";;$cols[3]\"} < $cols[2] ){ $data{\"$cols[1]\".\";;$cols[3]\"} = $cols[2]; } } } #Done with IFH close(IFH); foreach my $unique (keys %data) { my ($seqID, $intLoc) = split(';;', $unique); #Create a sequence object my $seq = $doc->createAndAddSequence($seqID, undef, undef, 'na', $options{'class'}); #Link it to the analysis as the input of $seq->addBsmlLink('analysis', '#snoscan_analysis', 'input_of'); #Create a feature group my $ft = $doc->createAndAddFeatureTable($seq); #If an input file was listed add the SeqDataImport if($options{'fasta_file'}) { $doc->createAndAddSeqDataImport( $seq, 'fasta', $options{fasta_file}, '', $seqID ); $doc->createAndAddBsmlAttribute( $seq, 'defline', $defline ); } #Create some variables used in following foreach loop my $startNuc; #Start of predicted snoRNA (interbase) my $endNuc; #End of predicted snoRNA (interbase) my $gene; #Feature Object my $snoRNA; #Also feature ojbect my $exon; #Again, feature object my $fg; #The feature group #Parse the start and end nucleotide positions if( $intLoc =~ /\\((\\d+)-(\\d+)\\)/) { $startNuc = $1-1; #Minus one to translate to interbase $endNuc = $2; #Find the snoRNA gene predicted and create a feature #object. $gene = $doc-> createAndAddFeature($ft, $idcreator-> new_id(db => $options{project}, so_type=>'gene', prefix=>$options{command_id} ), '', 'gene'); #Link the gene to the analysis $gene->addBsmlLink('analysis', '#snoscan_analysis', 'computed_by'); #Add an interval location element, to define start and stop #positions. &add_interval_loc($gene, $startNuc, $endNuc); #Create a snoRNA feature $snoRNA = $doc->createAndAddFeature($ft, $idcreator-> new_id(db => $options{project}, so_type=>'snoRNA', prefix=>$options{command_id} ), '', 'snoRNA'); #Link the snoRNA feature to the analysis $snoRNA->addBsmlLink('analysis', '#snoscan_analysis', 'computed_by'); #Add an Attribute element to the feature group in order #to document the bit score of the prediction. $snoRNA->addBsmlAttr(\"bit_score\", $data{$unique}); #Add an interval location element. &add_interval_loc($snoRNA, $startNuc, $endNuc); #Create an exon feature $exon = $doc-> createAndAddFeature($ft, $idcreator-> new_id(db => $options{project}, so_type=>'exon', prefix=>$options{command_id} ), '', 'exon'); #Link the snoRNA feature to the analysis $exon->addBsmlLink('analysis', '#snoscan_analysis', 'computed_by'); #Add an interval location element. &add_interval_loc($exon, $startNuc, $endNuc); #Now create and add a feature group containing these three members #and an Attribute element to hold the bit_score. $fg = $doc->createAndAddFeatureGroup( $seq, '', $gene->returnattr('id') ); $fg->addBsmlFeatureGroupMember( $gene->returnattr('id'), $gene->returnattr('class') ); $fg->addBsmlFeatureGroupMember( $snoRNA->returnattr('id'), $snoRNA->returnattr('class') ); $fg->addBsmlFeatureGroupMember( $exon->returnattr('id'), $exon->returnattr('class') ); } } #Add the analysis documentation my $analysis = $doc->createAndAddAnalysis( id=> 'snoscan_analysis', sourcename=> $options{'output'} ); #Write everything to the BSML document $doc->write($options{'output'},, $options{'compress_bsml_output'}); exit; ########################################################################## # SUB-ROUTINES # ########################################################################## sub check_parameters { my $options = shift; ## make sure input_file and output_dir were passed unless ( $options{input} && $options{output}) { #$logger->logdie(\"Required options are:\\n\\t--input_file\\n\". #\"\\t--output_dir\\n\\t--fragment_\"); if(!($options{input})) { print \"no input\\n\"; } if(!($options{output})) { print \"no output\\n\"; } pod2usage({-exitval => 2, -message => \"error message\", -verbose => 1, -output => \\*STDERR}); } #If the files input doesn't exist, check for the gzipped version. #Bug 2591 unless(-e $options{'input'}) { if(-e $options{'input'}.\".gz\") { $options{'input'} .= \".gz\"; } } ## make sure input_file exists if (! -e \"$options{input}\") { $logger->logdie(\"the input file passed ($options{input_file})\". \"cannot be read or does not exist\"); #die (\"The input file does not exist ($options{input})\"); } ##Make sure the output file doesn't exist if(-e \"$options{output}\") { $logger->logdie(\"The output file already exists\"); #die (\"The output file already exists\"); } if(!defined($options{'class'})) { $logger->logdie(\"The class was not defined\"); #die (\"The class was not defined\"); } #Parse the defline out of the fasta file. And save it for later. if($options{'fasta_input'}) { my $mod = \"<\"; if($options{'fasta_input'} =~ /\\.gz$/) { $mod = \"<:gzip\"; } elsif(!-e $options{'fasta_input'} && -e $options{'fasta_input'}.\".gz\") { $mod = \"<:gzip\"; } open(IN, $mod, $options{'fasta_input'}) or $logger->logdie(\"Unable to open $options{'fasta_input'} ($!)\"); while(<IN>) { chomp; if(/^>(.*)/) { $defline = $1; #Assume it's a single fasta file last; } } close(IN); } else { $logger->logdie(\"Option fasta_input is required\"); } } sub add_interval_loc { my ($feat, $n, $m) = @_; ## was it found on the forward or reverse strand? if ($n <= $m) { $feat->addBsmlIntervalLoc($n, $m, 0); } else { $feat->addBsmlIntervalLoc($m, $n, 1); } }"
    },
    {
      "tool": "snp",
      "converter_script": "snp2bsml.pl",
      "name": "snp2bsml.pl - convert clustered snp output information from show-snps to bsml",
      "synopsis": "usage: snp2bsml.pl [ --input|-i=/path/to/show-snps_clustered_output ]\n           [ --output|-o=/path/to/snp_data.bsml ]\n             --project\n           [ --log|-l=/path/to/logfile ]\n           [ --debug|-d=debug_level ]\n           [ --moltype|-m=molecule_type ]\n           [ --seqdata|-s=sequence_data ]",
      "description": "This script will parse out clustered output from show-snps tool from the\nMUMer package and create a multiple sequence alignment BSML representation\nfor the SNP data.",
      "options": {
        "input": "Clustered output from show-snps tool from MUMer suite",
        "output": "BSML multiple sequence alignment file for SNP representation",
        "project": "Project name",
        "id_repository": "Path to project id repository",
        "log": "Log file",
        "debug": "Debug level",
        "moltype": "Molecule type (nucleotide, protein)\n    Defaults to nucleotide",
        "seqdata": "SNP sequence data, in tab delimited format, containing:\n    sequence_id, position, orientation, base_call",
        "help": "This help message"
      },
      "contact": "Ed Lee (elee@tigr.org) =cut use strict; use warnings qw(all); use IO::File; use BSML::BsmlBuilder; use Ergatis::Logger; use Ergatis::IdGenerator; use Pod::Usage; use Getopt::Long qw(:config no_ignore_case); use Sequence::SeqLoc; my $moltype = 'nucleotide'; my $in = undef; my $out = undef; my $db = undef; my $logger = undef; my %seqdata = (); my $RECORD_DELIM = '//'; my %seqs_added = (); my %opts = (); &get_opts; &parse_data; sub print_usage { pod2usage( {-exitval => 0, -verbose => 2, -output => \\*STDERR} ); } sub get_opts { my $input_file = '/dev/stdin'; my $output_file = '/dev/stdout'; my $log_file = Ergatis::Logger::get_default_logfilename; my $debug = 4; GetOptions(\\%opts, 'input|i=s', 'output|o=s', 'log|l=s', 'debug|D=i', 'moltype|m=s', 'seqdata|s=s', 'help|h', 'id_repository=s', 'project=s'); print_usage if $opts{help}; $logger->logdie(\"No SNP seqdata provided\") if (!$opts{id_repository}); if (!$opts{project}) { $opts{project} = 'unknown'; } $input_file = $opts{input} if $opts{input}; $output_file = $opts{output} if $opts{output}; $log_file = $opts{log} if $opts{log}; $debug = $opts{debug} if $opts{debug}; $logger = new Ergatis::Logger('LOG_FILE' => $log_file, 'LOG_LEVEL' => $debug)-> get_logger; $in = new IO::File($input_file, \"r\") or $logger->logdie(\"Error reading input $input_file: $!\"); $out = new IO::File($output_file, \"w\") or $logger->logdie(\"Error writing output $output_file: $!\"); $moltype = $opts{moltype} if $opts{moltype}; init_seqdata($opts{seqdata}) if $opts{seqdata}; $logger->logdie(\"No SNP seqdata provided\") if (!scalar(keys(%seqdata))); } sub init_seqdata { my $seqdata_fname = shift; my $data = new IO::File($seqdata_fname) or die \"Error reading SNP sequence data $seqdata_fname: $!\"; while (my $line = <$data>) { chomp $line; my @tokens = split /\\t/, $line; $seqdata{$tokens[0]}{$tokens[1]}{$tokens[2]} = $tokens[3]; } } sub parse_data { my $id_creator = new Ergatis::IdGenerator('id_repository' => $opts{'id_repository'}); my $doc = new BSML::BsmlBuilder(); my @indels = (); my @cluster = (); while (my $line = <$in>) { chomp $line; if ($line =~ /^$RECORD_DELIM$/) { add_table($doc, \\@cluster, $id_creator, 'SNP'); if (is_indel(\\@cluster)) { push @indels, []; push @{$indels[$#indels]}, @cluster; } @cluster = (); next; } my $snp = new Sequence::SeqLoc($line); if ( ! $seqs_added{$snp->GetId}++ ) { ## assembly should probably not be hard-coded here. my $seq = $doc->createAndAddSequence($snp->GetId(), undef, '', 'dna', 'assembly'); $seq->addBsmlLink('analysis', '#nucmer_snps_analysis', 'input_of'); } $snp->SetSeqData(get_seq_data($snp)) if $snp->GetLength; push @cluster, $snp; } process_indels($doc, \\@indels, $id_creator); $doc->createAndAddAnalysis( 'id' => 'nucmer_snps_analysis', 'sourcename' => $opts{'input'}, 'algorithm' => 'nucmer_snps', 'program' => 'nucmer_snps', ); $doc->write($out); } sub add_table { my ($doc, $cluster, $id_creator, $type) = @_; my $msa_table = $doc->returnBsmlMultipleAlignmentTableR ($doc->addBsmlMultipleAlignmentTable); $msa_table->addBsmlLink('analysis', '#nucmer_snps_analysis', 'computed_by'); $msa_table->addattr('molecule-type', $moltype); $msa_table->addattr('id', $id_creator->next_id( project => $opts{project}, type => $type ) ); $msa_table->addattr('class', $type); my $aln_summary = $msa_table->returnBsmlAlignmentSummaryR ($msa_table->addBsmlAlignmentSummary); $aln_summary->addattr('seq-format', 'msa'); $aln_summary->addattr('seq-type', $moltype); my $seq_align = $msa_table->returnBsmlSequenceAlignmentR ($msa_table->addBsmlSequenceAlignment); my $seq_nums = \"\"; for (my $i = 0; $i < scalar(@{$cluster}); ++$i) { $seq_nums .= \"$i\"; $seq_nums .= \":\" if $i < $#$cluster; my $loc = $$cluster[$i]; my $length = $loc->GetSeqData ? length($loc->GetSeqData) : 0; my $aln_seq = $aln_summary->returnBsmlAlignedSequenceR ($aln_summary->addBsmlAlignedSequence); $aln_seq->addattr('name', $loc->GetId); $aln_seq->addattr('seqref', $loc->GetId); $aln_seq->addattr('length', $length); $aln_seq->addattr('seqnum', $i); $aln_seq->addattr('start', $length ? $loc->GetFrom() : $loc->GetFrom() + 1); $aln_seq->addattr('on-complement', $loc->GetStrand eq '+' ? '0' : '1'); my $seq_data = $seq_align->returnBsmlSequenceDataR ($seq_align->addBsmlSequenceData); $seq_data->addattr('seq-name', $loc->GetId); $seq_data->addSequenceAlignmentData($loc->GetSeqData) if $loc->IsSetSeqData; } $seq_align->addattr('sequences', $seq_nums); } sub process_indels { my ($doc, $indels, $id_creator) = @_; my @sorted_clusters = sort cluster_comparator @{$indels}; my @adjacent_clusters = (); my %written_clusters = (); my $prev_adjacent = 0; for (my $i = 0; $i < scalar(@sorted_clusters) - 1; ++$i) { my $cluster1 = $sorted_clusters[$i]; for (my $j = $i + 1; $j < scalar(@sorted_clusters); ++$j) { my $cluster2 = $sorted_clusters[$j]; if (is_adjacent($cluster1, $cluster2)) { if (!$prev_adjacent) { push @adjacent_clusters, []; push @{$adjacent_clusters [$#adjacent_clusters]}, $cluster1; ++$written_clusters{$cluster1}; $prev_adjacent = 1; } push @{$adjacent_clusters [$#adjacent_clusters]}, $cluster2; ++$written_clusters{$cluster2}; last; } else { $prev_adjacent = 0; } } } foreach my $cluster_group (@adjacent_clusters) { my $indel = \"\"; my $loc_with_seq = undef; foreach my $cluster (@{$cluster_group}) { foreach my $loc (@{$cluster}) { if ($loc->IsSetSeqData) { $indel .= $loc->GetSeqData; $loc_with_seq = $loc if !$loc_with_seq; } } } #if the indel is on the minus strand, reverse the order #the bases are already complemented so there's not need to #complement them if ($loc_with_seq->GetStrand() eq Sequence::SeqLoc::MINUS_STRAND) { $indel = reverse($indel); } my @indel_cluster = (); foreach my $loc (@{$$cluster_group[0]}) { if ($loc->GetId eq $loc_with_seq->GetId) { my $indel_loc = create_new_loc($loc, $indel); push @indel_cluster, $indel_loc; } else { push @indel_cluster, $loc; } } add_table($doc, \\@indel_cluster, $id_creator, 'indel'); } foreach my $cluster (@sorted_clusters) { next if exists $written_clusters{$cluster}; add_table($doc, \\@{$cluster}, $id_creator, 'indel'); } } sub copy_snp_data { my ($src, $dest) = @_; $dest->SetQueryId($src->GetQueryId); $dest->SetQueryPosition($src->GetQueryPosition); $dest->SetQueryFrame($src->GetQueryFrame); $dest->SetSubjectId($src->GetSubjectId); $dest->SetSubjectPosition($src->GetSubjectPosition); $dest->SetSubjectFrame($src->GetQueryFrame); } sub snp_comparator { my ($snp1, $snp2, $is_query) = @_; if ($is_query) { if ($snp1->GetQueryFrame > 0) { return $snp1->GetQueryPosition < $snp2->GetQueryPosition; } else { return $snp1->GetQueryPosition > $snp2->GetQueryPosition; } } else { if ($snp1->GetSubjectFrame > 0) { return $snp1->GetSubjectPosition < $snp2->GetSubjectPosition; } else { return $snp1->GetSubjectPosition > $snp2->GetSubjectPosition; } } } sub is_indel { my $cluster = shift; foreach my $loc (@{$cluster}) { return 1 if !$loc->GetLength; } return 0; } sub cluster_comparator { if ($$a[0]->GetId ne $$b[0]->GetId) { return $$a[0]->GetId cmp $$b[0]->GetId; } my $min_cluster_size = scalar(@{$a}) < scalar(@{$b}) ? scalar(@{$a}) : scalar(@{$b}); for (my $i = 0; $i < $min_cluster_size; ++$i) { if ($$a[$i]->GetId ne $$b[$i]->GetId) { return $$a[$i]->GetId cmp $$b[$i]->GetId; } if ($$a[$i]->GetFrom != $$b[$i]->GetFrom) { return $$a[0]->GetFrom <=> $$b[0]->GetFrom; } } } sub is_adjacent { my ($cluster1, $cluster2) = @_; return 0 if scalar(@{$cluster1}) != scalar(@{$cluster2}); for (my $i = 0; $i < scalar(@{$cluster1}); ++$i) { my $loc1 = $$cluster1[$i]; my $loc2 = $$cluster2[$i]; if ($loc1->GetId ne $loc2->GetId) { return 0; } if ($loc1->GetFrom != $loc2->GetFrom && $loc1->GetFrom + 1 != $loc2->GetFrom) { return 0; } } return 1; } sub get_seq_data { my $loc = shift; return $seqdata{$loc->GetId}{$loc->GetFrom}{$loc->GetStrand}; } sub create_new_loc { my ($loc, $indel) = @_; my $new_loc = new Sequence::SeqLoc($loc); $new_loc->SetSeqData($indel); # if ($new_loc->GetStrand eq '+') { # $new_loc->SetTo($new_loc->GetFrom + length($indel)); # } # else { # $new_loc->SetFrom($new_loc->GetTo - length($indel)); # } return $new_loc; }"
    },
    {
      "tool": "tRNAscan-SE",
      "converter_script": "tRNAscan-SE2bsml.pl",
      "name": "tRNAscan-SE2bsml.pl - convert tRNAcan-SE output to BSML",
      "synopsis": "USAGE: tRNAscan-SE2bsml.pl \n        --input=/path/to/tRNAscanfile \n        --output=/path/to/output.bsml\n        --fasta_input=/path/to/fastafile\n        --id_repository=/path/to/id_repository\n        --project=aa1 \n        [ --gzip_output=1       \n          --log=/path/to/logfile \n          --debug=3\n        ]",
      "description": "This script is used to convert the output from a tRNAscan-SE search into BSML.",
      "options": {
        "input": "Input file file from a tRNAscan-SE search.",
        "output": "Output BSML file (will be created, must not exist)",
        "fasta_input": "The input file that was used as input for the tRNAscan-SE run",
        "id_repository": "Path to the project's id repository",
        "gzip_output": "Optional. A non-zero value will make compressed output.",
        "debug": "Debug level.  Use a large number to turn on verbose debugging.",
        "project": "Required. Project ID.  Used in creating feature ids. \n    If 'aa1' is passed, repeat feature IDs created are like aa1.repeat_region.4231.1\n    If 'parse' is passed, will parse from already present ids.",
        "log": "Log file",
        "help": "This help message"
      },
      "contact": "Jason Inman jinman@tigr.org =cut use warnings; use strict; use Getopt::Long qw(:config no_ignore_case no_auto_abbrev); use Pod::Usage; use Ergatis::Logger; use Ergatis::IdGenerator; use Chado::Gene; use BSML::GenePredictionBsml; use BSML::BsmlBuilder; my $input; # Input file name my $output; # Output file name my $fasta_input; # fasta input to tRNAscan-SE my $idcreator; # Ergatis::IdGenerator object my $bsml; # BSML::BsmlBuilder object my $data = []; # parsed tRNAscan-SE data my $debug = 4; # debug value. defaults to 4 (info) my $parse_project =0; my %options = (); my $results = GetOptions (\\%options, 'input|i=s', 'output|o=s', 'fasta_input|a=s', 'project|p=s', 'log|l=s', 'id_repository|r=s', 'gzip_output|g=s', 'debug=s', 'help|h') || &_pod; # Set up the logger my $logfile = $options{'log'} || Ergatis::Logger::get_default_logfilename(); my $logger = new Ergatis::Logger('LOG_FILE'=>$logfile, 'LOG_LEVEL'=>$options{'debug'}); $logger = $logger->get_logger(); ## make sure all passed options are peachy &check_parameters(\\%options); # Use the Gene.pm module if there exists a non-empty input # otherwise just dump an 'empty' bsml file. $data = &parse_tRNAscanSE_input( $input ); $bsml = &generateBsml( $data ); $bsml->writeBsml( $output, '', $options{'gzip_output'}); exit (0); ################ SUBS ###################### sub parse_tRNAscanSE_input { # Open the input file and parse the data into an array of gene models. my $infile = shift; my $genes; ## open the input file for parsing open (IN,\"< $infile\") || $logger->logdie(\"can't open input file for reading\"); ## Strip out uninteresting lines of data from the file my %rawdata; while (<IN>) { my @cols = split; unless( $options{'project'} && $options{'project'} ne 'parse' ){ my $seq_id = $cols[0]; $options{'project'} = $1 if( $seq_id =~ /^([^\\.]+)\\./ ); } #check whitespace, no warn next if ( /^\\s*$/ ); ## make sure we don't parse the tRNAscan-SE output header lines next if ( /^sequence.*bounds.*cove/i || /^name.*end.*score/i || /\\-\\-.*\\-\\-/); ## there should be 9 elements in cols, unless we have an unrecognized format. unless (scalar @cols == 9) { $logger->error(\"the following tRNAscan-SE line was not recognized and could not be parsed:\\n$_\\n\") if ($logger->is_error); next; } ## add this data row to this sequence push( @{$rawdata{shift @cols}}, \\@cols ); } close IN; ## loop through each of the matches that we found and make a entries in the genes array. for my $seqid (keys %rawdata) { ## loop through each array reference of this key, adding to the data array as necessary. foreach my $arr ( @{$rawdata{$seqid}} ) { ## Determine strandedness my $complement = ($$arr[1] > $$arr[2]) ? 1 : 0; ## correct for interbase numbering if ($complement) { $$arr[2]--; ## Bounds End } else { $$arr[1]--; ## tRNA begin } ## First, create the gene model object my $currGene = new Chado::Gene ( $idcreator->next_id( 'type' => 'gene', 'project' => $options{project} ), ($complement) ? $$arr[2] : $$arr[1], ($complement) ? $$arr[1] : $$arr[2], $complement, $seqid ); ## Next, with the same coords, create the tRNA feature my $trna_feat_id = $currGene->addFeature( $idcreator->next_id ( 'type' => 'tRNA', 'project' => $options{project} ), ($complement) ? $$arr[2] : $$arr[1], ($complement) ? $$arr[1] : $$arr[2], $complement, 'tRNA' ); ## add name attribute to feature $currGene->addFeatureAttribute( $trna_feat_id, 'gene_product_name', 'tRNA-'.$$arr[3], ); ## add tRNA_anti-codon attribute to feature $currGene->addFeatureAttribute( $trna_feat_id, 'tRNA_anti-codon', $$arr[4], ); ## add score attribute to feature $currGene->addFeatureAttribute( $trna_feat_id, 'score', $$arr[7], ); ## an exon needs to be added. ## the following will eval as true if tRNAscan-SE reported an ## intron in the sequence, else the entire range is added as an exon. ##this seems to limit tRNAscan-SE to only report tRNAs with 0 or 1 intron. if ($$arr[5] && $$arr[6]) { if ($complement) { ## 1 is subtracted from each position to give interbase numbering $$arr[6]--; ## Bounds End ## exon1 &add_exon_and_cds($currGene, $$arr[2], $$arr[6], $complement); ## exon2 &add_exon_and_cds($currGene, $$arr[5], $$arr[1], $complement); } else { ## 1 is subtracted from each position to give interbase numbering $$arr[5]--; ## Intron Begin ## exon1 &add_exon_and_cds($currGene, $$arr[1], $$arr[5], $complement); ## exon2 &add_exon_and_cds($currGene, $$arr[6], $$arr[2], $complement); } } else { if ($complement) { ## just add the whole thing as an exon &add_exon_and_cds($currGene, $$arr[1], $$arr[2], $complement); } else { &add_exon_and_cds($currGene, $$arr[2], $$arr[1], $complement); } } # Handle Group now: my $count = $currGene->addToGroup( $currGene->getId, { 'all' => 1} ); &_die(\"Nothing was added to group\") unless ($count); push (@{$genes}, $currGene); } } return $genes; } sub generateBsml { my $data = shift; #Create the document my $gene_pred = new BSML::GenePredictionBsml( 'tRNAscan-SE' ); my $doc = $gene_pred->{'doc'}; unless($data && @{$data} > 0) { $gene_pred->addSequence( '', $fasta_input ); } foreach my $gene( @{$data} ) { $gene_pred->addGene($gene); my $addedTo = $gene_pred->addSequence($gene->{'seq'}, $fasta_input); $logger->logdie(\"Could not find identifier \".$gene->{'seq'}.\" in $fasta_input\") unless($addedTo || !(-e $fasta_input)); $logger->logdie(\"fasta_input file: '$fasta_input' does not exist\") unless(-e $fasta_input); } return $gene_pred; } sub add_exon_and_cds { # Add an exon and cds to the gene object. These features should share # start and stop coordinates. my ($gm, $start, $stop, $complement) = @_; foreach my $type (qw(exon CDS)) { # Add the exon or CDS to the gene model object $gm->addFeature( $idcreator->next_id( 'type' => $type, 'project' => $options{project} ), ($complement) ? $stop : $start, ($complement) ? $start : $stop, $complement, $type ); } } sub check_parameters { # Parse options hash, make sure certain ones exist and have meaningful values. # Also take the time to setup some globally used values. my $error = ''; &_pod if $options{'help'}; ## make sure input file was given and exists if ($options{'input'}) { if (! -e $options{'input'}) { $logger->logdie(\"input file $options{'input'} does not exist\") } $input = $options{'input'}; } else { $error .= \"--input_file is a required opttion\\n\"; } ## make sure output file was given and doesn't exist yet if ($options{'output'}) { $output = $options{'output'}; } else { $error .= \"--output_file is a required option\\n\"; } ## Make sure we're given the input fasta if ($options{'fasta_input'}) { $fasta_input = $options{'fasta_input'}; } else { $error .= \"--fasta_input is a required option\\n\"; } ## Now set up the id generator stuff if ($options{'id_repository'}) { # we're going to generate ids $idcreator = new Ergatis::IdGenerator('id_repository' => $options{'id_repository'}); # Set the pool size $idcreator->set_pool_size('gene'=>30,'tRNA'=>30,'exon'=>30,'CDS'=>30); } else { $error .= \"--id_repository is a required option\\n\"; } # The debug option is not required... but let's set it up if it's been given if ($options{'debug'}) { $debug = $options{'debug'}; } ## set default if project not passed. $options{project} ||= 'unknown'; &_die($error) if $error; return 1; } # END OF check_parameters sub _pod { # Used to display the perldoc help. pod2usage( {-exitval => 0, -verbose => 2} ); } sub _die { # Kinda like a hitman, this is called when something needs to DIE. my $msg = shift; $logger->logdie($msg); }"
    },
    {
      "tool": "targetp",
      "converter_script": "targetp2bsml.pl",
      "name": "targetp2bsml.pl - convert TargetP output to BSML",
      "synopsis": "USAGE: targetp2bsml.pl --input=/path/to/targetp_file --output=/path/to/output.bsml",
      "description": "This script is used to convert the output from TargetP into BSML.",
      "options": {
        "input": "Input file file from a targetp run.",
        "debug": "Debug level.  Use a large number to turn on verbose debugging.",
        "project": "[DEPRECATED]  Parses project name from input sequence id.",
        "log": "Log file",
        "output": "Output BSML file (will be created, must not exist)",
        "help": "This help message"
      },
      "contact": "Brett Whitty bwhitty@tigr.org =cut use strict; use Log::Log4perl qw(get_logger); use Getopt::Long qw(:config no_ignore_case no_auto_abbrev); use BSML::BsmlBuilder; use BSML::BsmlReader; use BSML::BsmlParserTwig; use BSML::BsmlRepository; use Ergatis::IdGenerator; use Pod::Usage; use Ergatis::Logger; my %options = (); my $results = GetOptions (\\%options, 'input|i=s', 'output|o=s', 'sequence_id|s=s', 'debug|d=s', 'command_id=s', ## passed by workflow 'logconf=s', ## passed by workflow (not used) 'project|p=s', 'id_repository=s', 'log|l=s', 'help|h') || pod2usage(); my $logfile = $options{'log'} || Ergatis::Logger::get_default_logfilename(); my $logger = new Ergatis::Logger('LOG_FILE'=>$logfile, 'LOG_LEVEL'=>$options{'debug'}); $logger = $logger->get_logger(); # display documentation if( $options{'help'} ){ pod2usage( {-exitval=>0, -verbose => 2, -output => \\*STDOUT} ); } ## make sure all passed options are peachy &check_parameters(\\%options); ## we want to create ids unique to this document, which will be replaced later. they must ## contain the prefix that will be used to look up a real id, such as ath1.gen.15 my $next_id = 1; ## we want a new doc my $doc = new BSML::BsmlBuilder(); ## we're going to generate ids my $idcreator = new Ergatis::IdGenerator( id_repository => $options{'id_repository'}); ## project variable my $project; ## open the input file for parsing open (my $ifh, $options{'input'}) || $logger->logdie(\"can't open input file for reading\"); my $plant_flag = 0; my @result_line_ref; while (<$ifh>) { chomp; if (/using plant networks/i) { $plant_flag = 1; } if ($plant_flag && /^cutoff\\s+([^ ]+)\\s+([^ ]+)\\s+([^ ]+)\\s+([^ ]+)/) { ## the cutoff values used will be added to the analysis block ## so we don't really need to parse them here my $ctp_cutoff = $1; my $mtp_cutoff = $2; my $sp_cutoff = $3; my $other_cutoff = $4; } elsif (!$plant_flag && /^cutoff\\s+([^ ]+)\\s+([^ ]+)\\s+([^ ]+)/) { ## the cutoff values used will be added to the analysis block ## so we don't really need to parse them here my $mtp_cutoff = $1; my $sp_cutoff = $2; my $other_cutoff = $3; } ## skip any lines we're not looking for specifically next if ( ! /^-{70}$/ ); ##recognize start of results for an individual sequence if (/^-{70}/) { $logger->debug(\"start of results table found\") if($logger->is_debug()); while (<$ifh>) { chomp; if (/^-{70}/) { last; } if ($plant_flag && /^(.{20})\\s+(\\d+)\\s+([^ ]+)\\s+([^ ]+)\\s+([^ ]+)\\s+([^ ]+)\\s+([^ ]+)\\s+([^ ]+)\\s+([^ ]+)?$/) { my $result_line = { 'name' => $1, 'len' => $2, 'ctp' => $3, 'mtp' => $4, 'sp' => $5, 'other' => $6, 'loc' => $7, 'rc' => $8, 'tplen' => $9, }; push (@result_line_ref, $result_line); } elsif (!$plant_flag && /^(.{20})\\s+(\\d+)\\s+([^ ]+)\\s+([^ ]+)\\s+([^ ]+)\\s+([^ ]+)\\s+([^ ]+)\\s+([^ ]+)?$/) { my $result_line = { 'name' => $1, 'len' => $2, 'mtp' => $3, 'sp' => $4, 'other' => $5, 'loc' => $6, 'rc' => $7, 'tplen' => $8, }; push (@result_line_ref, $result_line); } else { if ($plant_flag) {print STDERR \"died in plant mode\\n\";} else {print STDERR \"died in nonplant mode\\n\";} $logger->logdie(\"failed parsing result line:\\n$_\\n\"); } } } } ## GO mappings tables for output my %go_term = ( 'C' => 'plastid', 'M' => 'mitochondrion', 'S' => 'extracellular space', '_' => 'cytoplasm', '*' => 'cellular component unknown', '?' => 'cellular component unknown', ); my %go_id = ( 'C' => 'GO:0009536', 'M' => 'GO:0005739', 'S' => 'GO:0005615', '_' => 'GO:0005737', '*' => 'GO:0008372', '?' => 'GO:0008372', ); if ($options{'sequence_id'} && scalar(@result_line_ref) > 1) { $logger->logdie(\"Sequence ID was provided as an argument, but input file has multiple result lines. Sequence ID will override IDs read from the raw file.\"); } foreach my $line_ref(@result_line_ref) { $line_ref->{'name'} =~ s/\\s+$//; my $seq_id = ''; if ($options{'sequence_id'}) { $seq_id = $options{'sequence_id'}; } else { $seq_id = $line_ref->{'name'}; } $project = \"\"; $project = $1 if($seq_id =~ /^([^\\.]+)\\./); $logger->logdie(\"Could not parse project from $seq_id\") unless($project); my $seq = $doc->createAndAddSequence( $seq_id, undef, '', 'aa', 'polypeptide' ); $seq->addBsmlLink('analysis', '#targetp_analysis', 'input_of'); if ($line_ref->{'loc'} ne '*' && $line_ref->{'loc'} ne '?') { my $ft = $doc->createAndAddFeatureTable($seq); my $new_id = $idcreator->next_id( project => $project, type => 'transit_peptide', ); my $feature = $doc->createAndAddFeature($ft, $new_id, '', 'transit_peptide'); $feature->addBsmlLink('analysis', '#targetp_analysis', 'computed_by'); my $endpos = 0; if ($line_ref->{'tplen'} > 0) { $endpos = $line_ref->{'tplen'}; } $feature->addBsmlIntervalLoc('0', $endpos); delete($line_ref->{'name'}); delete($line_ref->{'len'}); delete($line_ref->{'tplen'}); # my $attribute_array_ref; # push( @{$attribute_array_ref}, { # name => 'GO', # content => $go_id{$line_ref->{'loc'}} # } # ); # push( @{$attribute_array_ref}, { # name => 'IEA', # content => 'targetp prediction' # } # ); # $feature->addBsmlAttributeList($attribute_array_ref); foreach my $k(keys %{$line_ref}) { $doc->createAndAddBsmlAttribute($feature, $k, $line_ref->{$k}); } } } my $analysis = $doc->createAndAddAnalysis( id => 'targetp_analysis', sourcename => $options{'output'}, algorithm => 'targetp', program => 'targetp' ); ## now write the doc $doc->write($options{'output'}); exit(); sub check_parameters { ## make sure input file exists if (! -e $options{'input'}) { $logger->logdie(\"input file $options{'input'} does not exist\") } ## make sure output file doesn't exist yet if (-e $options{'output'}) { $logger->logdie(\"can't create $options{'output'} because it already exists\") } $options{'command_id'} = '0' unless ($options{'command_id'}); return 1; } ## parse_position parses the position field to give an array containing ## start [and stop] sites sub parse_position { my ($position) = @_; if ($position =~ /^\\s*([^\\s]+)\\s*$/) { return split(\"-\", $1); } else { return (); } }"
    },
    {
      "tool": "tcov",
      "converter_script": "tcov2bsml.pl",
      "name": "tcov2bsml.pl  - convert tcov files into BSML documents",
      "synopsis": "USAGE:  tcov2bsml.pl -t tcov_file -b bsml_repository_path -o output_file_bsml\n\t-d database -a assembly_id",
      "description": "tcov2bsml.pl is designed to convert information in tcov files (coverage data)\ninto BSML documents.\n\n=cut\n\nuse BSML::BsmlBuilder;\nuse BSML::BsmlParserTwig;\n\nuse Getopt::Long qw(:config no_ignore_case no_auto_abbrev);\nuse Pod::Usage;\n\nuse strict;\n\n# Utility to convert coverage data stored in the TIGR tcov format from\n# getCoverage into BSML\n\n# BSML encoding to support externally linked BSML sequences with sequences\n# containing consensus quality scores, read depth, and most commonly occuring\n# alternative base mapped to them via the numbering element.\n\nmy %options = ();\nmy $results = GetOptions (\\%options, \n\t\t\t  'tcov|t=s',\n\t\t\t  'bsml_repository_path|b=s',\n\t\t\t  'database|d=s',\n\t\t\t  'chunk_size|c=s',\n\t\t\t  'output|o=s',  \n\t\t\t  'log|l=s',\n\t\t\t  'debug=s',\n\t\t\t  'assembly_id|a=i',\n\t\t\t  'help|h') || pod2usage();\n\n# display documentation\nif( $options{'help'} ){\n    pod2usage( {-exitval=>0, -verbose => 2, -output => \\*STDOUT} );\n}\n\nif( !( $options{'bsml_repository_path' } ) )\n{\n    pod2usage( {-exitval=>1, -verbose => 2, -output => \\*STDOUT} );\n}\n\nif( !( $options{'tcov' } ) )\n{\n    pod2usage( {-exitval=>1, -verbose => 2, -output => \\*STDOUT} );\n}\n\nif( !( $options{'database' } ) )\n{\n    pod2usage( {-exitval=>1, -verbose => 2, -output => \\*STDOUT} );\n}\n\nmy $tcovFilePath = $options{'tcov'};\nmy $repositoryPath = $options{'bsml_repository_path'};\nmy $outputFile = $options{'output'};\nmy $chunk_count;\nmy $database = $options{'database'};\n\nif( $options{'chunk_size'} )\n    {\n\t$chunk_count = $options{'chunk_size'};\n    }\nelse\n{\n    $chunk_count = 1000;\n}\n\n\n# filename is expected to encode the assembly id\n# ie /usr/local/annotation/MYCOTB/chauser/bmt_coverage_data/443.tcov\n\n$tcovFilePath =~ /(\\d+).tcov/;\nmy $assemblyId = $1 ? $1 : $options{assembly_id};\ndie \"No assembly id provided\" if !defined $assemblyId;\n\nopen( TCOV, $tcovFilePath ) or die \"Could not open $tcovFilePath\\n\";\n\n# an array containing the consensus quality score at each position\nmy @consensus_quality_score;\n\n# an array containing the read depth at each position\nmy @read_depth;\n\n# an array containing the most commonly occuring alternative base at \n# each position\nmy @most_common_alternate_base;\n\nwhile( my $line = <TCOV> )\n{\n    # tcov input is space delimited with each line representing the following\n    # base position | consensus base | consensus quality value | base calls covering the position \n    # | quality values of the bases | Indices of the corresponding bases and quality values\n    # see http://intranet/software_docs/getCoverage.html for a more thorough description\n\n    my @tokens = split ' ', $line;\n    next if scalar(@tokens) < 6;\n    shift @tokens if scalar(@tokens) > 6;\n    my ($pos, $consensus_base, $consensus_quality_value, $base_calls, $quality_values, $indices ) = @tokens;\n\n    # does not support ambiguous base calls \n    if( $consensus_base =~ /[AGCT]/ )\n    {\n\t$consensus_quality_score[$pos-1] = $consensus_quality_value;\n\t$read_depth[$pos-1] = length( $base_calls );\n\n\tmy $baseCount = { 'A' => 0, 'G' => 0, 'C' => 0, 'T' => 0 };\n\n\tfor( my $i=0; $i<length( $base_calls ); $i++ )\n\t{\n\t    my $base = substr( $base_calls, $i, 1 );\n\t    $baseCount->{$base} += 1;\n\t}\n\n\t# set the consensus base to -1 to get the second most common base\n\n\t$baseCount->{$consensus_base} = -1;\n\n\t# if the only base encountered is the consensus base and therefore the largest count is\n\t# an unencountered base, the consensus base will be used\n\n\tif( ($baseCount->{'A'}) >= $baseCount->{'G'} && ($baseCount->{'A'} >= $baseCount->{'C'}) &&  ($baseCount->{'A'} >= $baseCount->{'T'}) )\n\t{\n\t    if( $baseCount->{'A'} == 0 )\n\t    {\n\t\t$most_common_alternate_base[$pos-1] = $consensus_base;\n\t    }\n\t    else\n\t    {\n\t\t$most_common_alternate_base[$pos-1] = 'A';\n\t    }\n\t}\n\n\tif( ($baseCount->{'G'}) >= $baseCount->{'A'} && ($baseCount->{'G'} >= $baseCount->{'C'}) &&  ($baseCount->{'G'} >= $baseCount->{'T'}) )\n\t{\n\t    if( $baseCount->{'G'} == 0 )\n\t    {\n\t\t$most_common_alternate_base[$pos-1] = $consensus_base;\n\t    }\n\t    else\n\t    {\n\t\t$most_common_alternate_base[$pos-1] = 'G';\n\t    }\n\t}\n\n\tif( ($baseCount->{'C'}) >= $baseCount->{'G'} && ($baseCount->{'C'} >= $baseCount->{'A'}) &&  ($baseCount->{'C'} >= $baseCount->{'T'}) )\n\t{\n\t    if( $baseCount->{'C'} == 0 )\n\t    {\n\t\t$most_common_alternate_base[$pos-1] = $consensus_base;\n\t    }\n\t    else\n\t    {\n\t\t$most_common_alternate_base[$pos-1] = 'C';\n\t    }\n\t}\n\n\tif( ($baseCount->{'T'}) >= $baseCount->{'G'} && ($baseCount->{'T'} >= $baseCount->{'C'}) &&  ($baseCount->{'T'} >= $baseCount->{'A'}) )\n\t{\n\t    if( $baseCount->{'T'} == 0 )\n\t    {\n\t\t$most_common_alternate_base[$pos-1] = $consensus_base;\n\t    }\n\t    else\n\t    {\n\t\t$most_common_alternate_base[$pos-1] = 'T';\n\t    }\n\t}\n    }\n}\n\n# bsml builder class to construct the coverage document\nmy $bsmlDoc = new BSML::BsmlBuilder;\n\nmy $asmbl_length = @consensus_quality_score;\n\n\n# add the reference sequence and it's link in the repository\n\nmy $seq = $bsmlDoc->createAndAddExtendedSequenceN( id => $database.\"_\".$assemblyId.\"_assembly\",\n\t\t\t\t\t\t   class => \"contig\",\n\t\t\t\t\t\t   length => $asmbl_length );\n\n$seq->addattr( 'class', \"assembly\" );\n\n$bsmlDoc->createAndAddSeqDataImportN( seq => $seq,\n\t\t\t\t      format => \"BSML\",\n                                      source => $repositoryPath.\"/\".$database.\"_\".$assemblyId.\"_assembly.bsml\",\n                                      id => \"_\".$database.\"_\".$assemblyId.\"_assembly\");\n\n\n# add the consensus quality score sequence\n\nmy $tmpstr = '';\nmy $tmpstr_count = 0;\nmy $offset = 0;\nmy $count = 0;\n\n\nfor( my $i=0; $i<$asmbl_length; $i++ )\n{\n    $tmpstr .= \":$consensus_quality_score[$i]\";\n    $tmpstr_count++;\n\n    if( ((($i+1) % $chunk_count) == 0))\n    {\n\tmy $consensus_quality_score_seq = $bsmlDoc->createAndAddExtendedSequenceN( id => $database.\"_\".$assemblyId.\"_assembly_consensus_quality_score_\".$count,\n\t\t\t\t\t\t\t\t\t\t   class => \"consensus_quality_value\",\n\t\t\t\t\t\t\t\t\t\t   length => $tmpstr_count );\n\t\n\t$consensus_quality_score_seq->addattr( 'class', \"consensus_quality_value\" );\n    \n\t$bsmlDoc->createAndAddSeqData( $consensus_quality_score_seq, $tmpstr );\n\t\n\tmy $numbering = $bsmlDoc->createAndAddNumbering( seq => $consensus_quality_score_seq,\n\t\t\t\t\t\t seqref => $database.\"_\".$assemblyId.\"_assembly\",\n\t\t\t\t\t\t refnum => $offset,\n\t\t\t\t\t\t ascending => 1 );\n\n\t$offset += $chunk_count;\n\t$count++;\n\n\t$tmpstr = '';\n\t$tmpstr_count = 0;\n    }\n}\n\nmy $consensus_quality_score_seq = $bsmlDoc->createAndAddExtendedSequenceN( id => $database.\"_\".$assemblyId.\"_assembly_consensus_quality_score_\".$count,\n\t\t\t\t\t\t\t\t\t   class => \"consensus_quality_value\",\n\t\t\t\t\t\t\t\t\t   length => $tmpstr_count );\n\n$consensus_quality_score_seq->addattr( 'class', \"consensus_quality_value\" );\n\n$bsmlDoc->createAndAddSeqData( $consensus_quality_score_seq, $tmpstr );\n\n# map it to the reference sequence\n\nmy $numbering = $bsmlDoc->createAndAddNumbering( seq => $consensus_quality_score_seq,\n\t\t\t\t\t\t seqref => $database.\"_\".$assemblyId.\"_assembly\",\n\t\t\t\t\t\t refnum => $offset,\n\t\t\t\t\t\t ascending => 1 );\n\n# add the sequence depth score sequence\n\n$tmpstr = '';\n$tmpstr_count = 0;\n$offset = 0;\n$count = 0;\n\n\nfor( my $i=0; $i<$asmbl_length; $i++ )\n{\n    $tmpstr .= \":$read_depth[$i]\";\n    $tmpstr_count++;\n\n    if( ((($i+1) % $chunk_count) == 0))\n    {\n\tmy $read_depth_score_seq = $bsmlDoc->createAndAddExtendedSequenceN( id => $database.\"_\".$assemblyId.\"_assembly_read_depth_\".$count,\n\t\t\t\t\t\t\t\t\t\t   class => \"read_depth\",\n\t\t\t\t\t\t\t\t\t\t   length => $tmpstr_count );\n\t    \n\t$read_depth_score_seq->addattr( 'class', \"read_depth\" );\n\n\t$bsmlDoc->createAndAddSeqData( $read_depth_score_seq, $tmpstr );\n\t\n\tmy $numbering = $bsmlDoc->createAndAddNumbering( seq => $read_depth_score_seq,\n\t\t\t\t\t\t seqref => $database.\"_\".$assemblyId.\"_assembly\",\n\t\t\t\t\t\t refnum => $offset,\n\t\t\t\t\t\t ascending => 1 );\n\n\t$offset += $chunk_count;\n\t$count++;\n\n\t$tmpstr = '';\n\t$tmpstr_count = 0;\n    }\n}\n\nmy $read_depth_score_seq = $bsmlDoc->createAndAddExtendedSequenceN( id => $database.\"_\".$assemblyId.\"_assembly_read_depth_\".$count,\n\t\t\t\t\t\t\t\t\t   class => \"read_depth\",\n\t\t\t\t\t\t\t\t\t   length => $tmpstr_count );\n\n$read_depth_score_seq->addattr( 'class', \"read_depth\" );\n\n$bsmlDoc->createAndAddSeqData( $read_depth_score_seq, $tmpstr );\n\n# map it to the reference sequence\n\nmy $numbering = $bsmlDoc->createAndAddNumbering( seq => $read_depth_score_seq,\n\t\t\t\t\t\t seqref => $database.\"_\".$assemblyId.\"_assembly\",\n\t\t\t\t\t\t refnum => $offset,\n\t\t\t\t\t\t ascending => 1 );\n\n# add the alternate base sequence\n\n$tmpstr = '';\n$tmpstr_count = 0;\n$offset = 0;\n$count = 0;\n\nfor( my $i=0; $i<$asmbl_length; $i++ )\n{\n    $tmpstr .= \"$most_common_alternate_base[$i]\";\n    $tmpstr_count++;\n\n      if( ((($i+1) % $chunk_count) == 0))\n      {\n\tmy $alt_base_score_seq = $bsmlDoc->createAndAddExtendedSequenceN( id => $database.\"_\".$assemblyId.\"_assembly_alt_base_\".$count,\n\t\t\t\t\t\t\t\t\t\t   class => \"alternative_base\",\n\t\t\t\t\t\t\t\t\t\t   length => $tmpstr_count );\n\t    \n\t$alt_base_score_seq->addattr( 'class', \"alternative_base\" );\n\n\n\t$bsmlDoc->createAndAddSeqData( $alt_base_score_seq, $tmpstr );\n\t\n\tmy $numbering = $bsmlDoc->createAndAddNumbering( seq => $alt_base_score_seq,\n\t\t\t\t\t\t seqref => $database.\"_\".$assemblyId.\"_assembly\",\n\t\t\t\t\t\t refnum => $offset,\n\t\t\t\t\t\t ascending => 1 );\n\n\t$offset += $chunk_count;\n\t$count++;\n\n\t$tmpstr = '';\n\t$tmpstr_count = 0;\n    }\n\n\n}\n\nmy $alt_base_score_seq = $bsmlDoc->createAndAddExtendedSequenceN( id => $database.\"_\".$assemblyId.\"_assembly_alt_base_\".$count,\n\t\t\t\t\t\t\t\t\t   class => \"alternative_base\",\n\t\t\t\t\t\t\t\t\t   length => $tmpstr_count );\n\n$alt_base_score_seq->addattr( 'class', \"alternative_base\" );\n\n$bsmlDoc->createAndAddSeqData( $alt_base_score_seq, $tmpstr );\n\n# map it to the reference sequence\n\nmy $numbering = $bsmlDoc->createAndAddNumbering( seq => $alt_base_score_seq,\n\t\t\t\t\t\t seqref => $database.\"_\".$assemblyId.\"_assembly\",\n\t\t\t\t\t\t refnum => $offset,\n\t\t\t\t\t\t ascending => 1 );\n\n$bsmlDoc->write( $outputFile );",
      "options": {},
      "contact": null
    },
    {
      "tool": "tiling",
      "converter_script": "tiling2bsml.pl",
      "name": "tiling2bsml.pl  - convert show_tiling output into BSML sequence mapping documents",
      "synopsis": "USAGE:  tiling2bsml.pl -t tilings_file -b path_to_bsml_repository -o output_file_bsml",
      "description": "tiling2bsml.pl is designed to convert tiling path data from show_tiling \ninto BSML sequence mapping documents.\n\n\nThe tiling path input should be tab delimited with the following fields. The \nfirst line encode the reference assembly id, starting with a '>'\n\n# 0 - start in ref\n# 1 - end in ref\n# 2 - distance to next contig\n# 3 - length of this contig\n# 4 - alignment coverage\n# 5 - identity\n# 6 - orientation\n# 7 - id\n\n=cut\n\nuse strict;\nuse warnings;\n\nuse Getopt::Long qw(:config no_ignore_case no_auto_abbrev);\nuse Pod::Usage;\n\nBEGIN {\nuse BSML::BsmlBuilder;\n}\n\nmy %options = ();\nGetOptions( \\%options, \n\t    'tilingPath|t=s', \n\t    'referencePath|r=s',\n\t    'queryPath|q=s',\n        'gzip_output|g=s',\n\t    'outFile|o=s',\n\t    'reference_class=s',\n\t    'query_class=s',\n\t    'analysis_id|a=s',\n\t    'help|h' \n\t    ) || pod2usage();\n\n# display documentation\nif( $options{'help'} ){\n    pod2usage( {-exitval=>0, -verbose => 2, -output => \\*STDOUT} );\n}\n\nif( !( $options{'tilingPath'} ) ) {\n    pod2usage( {-exitval=>1, -verbose => 2, -output => \\*STDOUT} );\n}\n\n#path to original reference and query mfsa required for SeqDataImport in bsml\nif( !( $options{'referencePath'} ) ) {\n    pod2usage( {-exitval=>1, -verbose => 2, -output => \\*STDOUT} );\n}\n\n\nmy ($defline, $identifier);\nif( !( $options{'queryPath'} ) ) {\n    pod2usage( {-exitval=>1, -verbose => 2, -output => \\*STDOUT} );\n} else {\n    open(IN, \"$options{'queryPath'}\") or\n       die(\"Cannot open $options{'queryPath'} ($!)\");\n    while(<IN>) {\n        if(/^>(.*)/) {\n            $defline = $1;\n            $identifier = $1 if($defline =~ /^([^\\s])/);\n        }\n    }\n    close(IN);\n}\n\nif( !( $options{'outFile'} ) ) {\n    pod2usage( {-exitval=>1, -verbose => 2, -output => \\*STDOUT} );\n}\n\n#needed inputs available?\nif( !( $options{'reference_class'} ) ) {\n    pod2usage( {-exitval=>1, -verbose => 2, -output => \\*STDOUT} );\n}\nif( !( $options{'query_class'} ) ) {\n    pod2usage( {-exitval=>1, -verbose => 2, -output => \\*STDOUT} );\n}\n\n## handle some defaults\nif (! $options{analysis_id}) {\n    $options{analysis_id} = 'unknown_analysis';\n}\n\nmy $gzip_output;\nif($options{'gzip_output'}){\n    $gzip_output = $options{'gzip_output'};\n}\n\n\n\n# The output of show_tiling is tab deliminted with the following fields\n# 0 - start in ref\n# 1 - end in ref\n# 2 - distance to next contig\n# 3 - length of this contig\n# 4 - alignment coverage\n# 5 - identity\n# 6 - orientation\n# 7 - id\n\nmy $doc = new BSML::BsmlBuilder;\nmy $ref_id = \"\";\nmy $ref_length = -1;\nmy $reference_class = $options{'reference_class'};\nmy $query_class = $options{'query_class'};\nmy %unique_contigs; #track that each contig is only tiled once, otherwise it's ambiguous\n\n#predefine sequences w/ analysis element to track unused sequences\npredefineSequences($doc, $options{'referencePath'}, $reference_class);   #reference\npredefineSequences($doc, $options{'queryPath'}, $query_class);#query\n\nopen( TILINGS, $options{'tilingPath'} ) or die \"Unable to open $options{'tilingPath'}\";\nwhile (my $line = <TILINGS>) {\n    chomp $line;\n    #Add in a reference sequence\n    if ($line =~ />([\\S]*)[\\s]([\\d]*)/) {\n\t$ref_id = $1;\n\t$ref_length = $2;\n\n\tif( !( $doc->returnBsmlSequenceByIDR( clean_id($ref_id) )) ){\n\t    die \"Reference sequence $ref_id missing from predefined sequences\";\n\t}\n\n    }\n    #Add in a tile\n    else {\n\tunless ($ref_id) {\n\t    die \"No valid reference sequence\";\n\t}\n\tmy @tile = split(\"\\t\",$line);\n\tmy $tile_start = $tile[0] - 1; #interbase 0 coordinates\n\tmy $tile_end = $tile[1]; #not used\n\tmy $tile_length = $tile[3];\n\tmy $percent_coverage = $tile[4];\n\tmy $percent_identity = $tile[5];\n\tmy $tile_id = $tile[7];\n\n\tmy $tile_ascending = 1;\n\tmy $tile_is_complement = 0;\n\tmy $refnum = $tile_start;\n\n\tif( $tile[6] eq '-' ) { #was on the complement\n\t    $tile_is_complement = 1;\n\t    $tile_ascending = 0;\n\t    $refnum = $tile_end;\n\t}\n\n\t#ensure uniqueness\n\tif (exists $unique_contigs{$tile_id}) {\n\t    die \"Ambigous multi-tiling of contig $tile_id\";\n\t}\n\telse { $unique_contigs{$tile_id} = 1; }\n\n\t#check that tile.length < scaffold.length\n\tif ($ref_length < $tile_length) {\n\t    die \"Length of scaffold $ref_id ($ref_length), less than tile ($tile_id) ($tile_length)\";\n\t}\n\n\t#negative coords are okay, they occur with -c and tiling across origin\n\t#if ($tile_start < 0 || $tile_length < 0) {\n\t#    die \"Invalid tile_start ($tile_start) or tile_length ($tile_length) for $tile_id in $options{'tilingPath'}\";\n\t#}\n\n\tif( !( $doc->returnBsmlSequenceByIDR( clean_id($tile_id) )) ){\n\t    die \"Query sequence $tile_id missing from predefined sequences\";\n\t}\n\telse {\n\t    my $tile_sequence = $doc->returnBsmlSequenceByIDR( clean_id($tile_id) );\n\n\t    #Numbering element only applicable for exact matches\n\t    if ($percent_identity == 100 && $percent_coverage == 100) {\t\t\n\t\t$doc->createAndAddNumbering( seq => $tile_sequence,\n\t\t\t\t\t     seqref => clean_id($ref_id),\n\t\t\t\t\t     refnum => $refnum,\n\t\t\t\t\t     ascending => $tile_ascending );\n\t    }\n\n\t    my $aln = $doc->createAndAddSequencePairAlignment(\n                                                          refseq => clean_id($ref_id),\n                                                          compseq => clean_id($tile_id),\n                                                          method=> 'tiling',\n                                                          class => 'match'\n                                         );\n\t    $aln->addBsmlLink('analysis', '#' . $options{analysis_id}, 'computed_by');\n\n\t    my $run = $doc->createAndAddSequencePairRun(\n                                           alignment_pair => $aln,\n                                           refpos => $tile_start,\n                                           runlength => $tile_length,\n                                           refcomplement => 0, #ref sequence is never complement\n\t\t\t\t\t   #tile is always entire contig\n                                           comppos => 0,\n                                           #comprunlength => $tile_sequence->returnattr( 'length' ),\n                                           comprunlength => $tile_length,\n                                           compcomplement => $tile_is_complement,\n                                                    class => 'match_part');\n\n\t    #add percent_identity and percent_coverage Attributes\n\t    $run->addBsmlAttr( 'percent_identity', $percent_identity);\n\t    $run->addBsmlAttr( 'percent_coverage', $percent_coverage);\n\t}\t\n    }\n}\nclose(TILINGS);\n\n$doc->write( $options{'outFile'} );\n\n\nsub predefineSequences {\n    my $doc = shift;\n    my $seqfile = shift;\n    my $class = shift;\n\n    my %seqs = loadMultiSequence( $seqfile );\n\n    for my $seqid ( sort {$a<=>$b} keys %seqs ) {\n        ## capture the first element of the header up to the first whitespace\n        my $id;\n        if ($seqs{$seqid}{h} =~ /^(\\S+)/) {\n            $id = $1;\n        } else {\n            die(\"unrecognized header format: $seqs{$seqid}{h}\");\n        }\n\n\tmy $seqstub = $doc->createAndAddSequence(\n\t\t\t\t\t\t clean_id($id), #id\n\t\t\t\t\t\t $id, #title\n\t\t\t\t\t\t length($seqs{$seqid}{s}), #length\n\t\t\t\t\t\t 'dna', #molecule\n\t\t\t\t\t\t $class #class\n\t\t\t\t\t\t );\n\n\t#Seq-data-import/@identifier must equal the fasta header up to the first space\t    \n\tmy $dataimport = $doc->createAndAddSeqDataImport(\n \t\t\t\t    $seqstub,              # Sequence element object reference\n \t\t\t\t    'fasta',               # //Seq-data-import/@format\n \t\t\t\t    $seqfile,              # //Seq-data-import/@source\n \t\t\t\t    undef,                 # //Seq-data-import/@id\n\t\t\t\t    #should NOT be clean_id since it references the fasta file\n \t\t\t\t    $id                    # //Seq-data-import/@identifier\n \t\t\t\t    );\n\t$seqstub->addBsmlLink('analysis', '#' . $options{analysis_id}, 'input_of');\n        $seqstub->addBsmlAttr('defline', $defline);\n\n\t#bugzilla case 2692\n\t#http://jorvis-lx:8080/bugzilla/show_bug.cgi?id=2692\n\t#add //Attribute-list/Attribute[@name=\"SO\", content=<class>]\n\t#presumably class is from SO\n\t$seqstub->addBsmlAttributeList([{name => 'SO', content=> $class}]);\n\t\n    }\n}\n\n#taken from fasta2bsml.pl\nsub loadMultiSequence {\n    #  USAGE:   loadMultiSequence($filepath)\n    #  RETURNS: hash\n    #\n    #  takes a file or path as an argument.  that file should be a multiple-\n    #  sequence FASTA file.  It returns a hash with a structure like:\n    #      $db{id}{'h'} = header\n    #             {'s'} = sequence without whitespace\n    #\n    #  where id is an incrementing integer that represents that sequence's\n    #  order in the file.\n    #\n    #########################################################################\n    my ($file) = @_;\n    \n    my $seqid = 0;\n    my $seq = '';\n    my $header;\n    my %db;\n    \n    ## load the sequence file\n    open (my $sfh, \"<$file\") || die(\"can't open $file because $!\");\n\n    for (<$sfh>) {\n        ## if we find a header line ...\n        if (/^\\>(.*)/) {\n\n            $header = $1;\n\n            ## don't do anything if this is the first sequence\n            if ($seqid == 0) {\n                $seqid++;\n                $db{$seqid}{'h'} = $header;\n                next;\n            } \n\n            ## remove whitespace\n            $seq =~ s/\\s//g;\n \n            ## record the previous sequence before starting the new one\n            $db{$seqid}{'s'} = $seq;\n\n            ## increment the id counter\n            $seqid++;\n\n            ## record the new header\n            $db{$seqid}{'h'} = $header;\n\n            ## reset the sequence\n            $seq = '';\n\n        ## else we've found a sequence line\n        } else {\n            ## skip it if it is just whitespace\n            next if (/^\\s*$/);\n\n            ## record this portion of the sequence\n            $seq .= $_;\n        }\n    }\n    \n    ## don't forget the last sequence\n    $seq =~ s/\\s//g;\n    $db{$seqid}{'s'} = $seq;\n\n    ## close the sequence file\n    close $sfh;\n    \n    return %db;\n}\n\n\n#problems with the BSML not validating due to issues w/ fasta headers\nsub clean_id {\n    my $header = shift;\n    $header =~ s/'/_/;\n    $header =~ s/^(\\d)/_$1/;\n    return $header;\n}",
      "options": {},
      "contact": null
    },
    {
      "tool": "tmhmm",
      "converter_script": "tmhmm2bsml.pl",
      "name": "tmhmm2bsml.pl - convert TMHMM output to BSML",
      "synopsis": "USAGE: tmhmm2bsml.pl --input=/path/to/tmhmm_file --output=/path/to/output.bsml --project=aa1 --fasta_input=/path/to/tmhmm/input.fsa --compress_bsml_output=0",
      "description": "This script is used to convert the output from TMHMM into BSML.",
      "options": {
        "input": "Input file file from a tmhmm run [long format only!].",
        "project": "[OPTIONAL]\n    The project (used for id making).\n    Default: unknown",
        "fasta_input": "The fasta file used as input to the tmhmm run.",
        "compress_bsml_output": "Will create gzipped output",
        "id_repository": "Required for creating feature identifiers.  Each project should have\n    its own id_repository directory - use the full path to it here.  This\n    is used by the IdGenerator.pm module.",
        "debug": "Debug level.  Use a large number to turn on verbose debugging.",
        "log": "Log file",
        "output": "Output BSML file (will be created, must not exist)",
        "help": "This help message"
      },
      "contact": "Brett Whitty bwhitty@tigr.org =cut use strict; use Log::Log4perl qw(get_logger); use Getopt::Long qw(:config no_ignore_case no_auto_abbrev); use BSML::BsmlBuilder; use BSML::BsmlParserTwig; use BSML::BsmlRepository; use Ergatis::IdGenerator; use Pod::Usage; use Ergatis::Logger; my %options = (); my $results = GetOptions (\\%options, 'input|i=s', 'output|o=s', 'debug|d=s', 'id_repository|r=s', 'fasta_input=s', 'compress_bsml_output=s', 'project|p=s', 'log|l=s', 'help|h') || pod2usage(); my $logfile = $options{'log'} || Ergatis::Logger::get_default_logfilename(); my $logger = new Ergatis::Logger('LOG_FILE'=>$logfile, 'LOG_LEVEL'=>$options{'debug'}); $logger = $logger->get_logger(); # display documentation if( $options{'help'} ){ pod2usage( {-exitval=>0, -verbose => 2, -output => \\*STDOUT} ); } my $defline; my $fastaFile; my $gzip = 0; ## make sure all passed options are peachy &check_parameters(\\%options); ## we want to create ids unique to this document, which will be replaced later. they must ## contain the prefix that will be used to look up a real id, such as ath1.gen.15 my $next_id = 1; ## we want a new doc my $doc = new BSML::BsmlBuilder(); ## we're going to generate ids my $idgen = Ergatis::IdGenerator->new( id_repository => $options{id_repository} ); ## recognized output result data term mappings my %result_term = ( 'Length' => 'length', 'Number of predicted TMHs' => 'tmh_count', 'Exp number of AAs in TMHs' => 'exp_aa_in_tmh', 'Exp number, first 60 AAs' => 'exp_first_60', 'Total prob of N-in' => 'prob_n_in', ); ## recognized results qualifier term mappings my %qualifier = ( 'POSSIBLE N-term signal sequence' => 'n_term_signal', ); ## open the input file for parsing (even if it's gziped (bug 2591)) my $mode = \"<\"; $mode .= \":gzip\" if($options{'input'} =~ /.gz$/); open (my $ifh, $mode, $options{'input'}) || $logger->logdie(\"can't open input file for reading\"); my @sequence_ids; my %result_ref_hash; #my $temp; my %property_hash; my %segment_hash; my %qualifier_hash; my $skip_flag = 0; #my $line; while (my $line = <$ifh>) { chomp $line; ## skip lines until we hit #'s if ($skip_flag && !($line =~ /^#/)) { next; } ## skip lines that are like # <A HREF ... # these are commented out by tmhmm when functionality is removed next if ( $line =~ /^# \\</ ); if ($line =~ /^# ([^ ]+) ([^:]+):\\s+([^ ]+)$/) { $skip_flag = 0; my $seq_id = $1; my $term = $2; my $value = $3; if (defined($result_term{$term})) { if (!defined($property_hash{$seq_id})) { $property_hash{$seq_id} = []; } push(@{$property_hash{$seq_id}}, [$seq_id, $result_term{$term}, $value]); ## We may want to use these in the output later #print STDERR $result_term{$term}; } else { die \"unrecognized result term\"; } } elsif ($line =~ /^# ([^ ]+) (.*)$/) { $skip_flag = 0; my $seq_id = $1; my $term = $2; if (defined($qualifier{$term})) { ## We may want to use these in the output later #print STDERR $qualifier{$term}.\"\\n\"; if (!defined($qualifier_hash{$seq_id})) { $qualifier_hash{$seq_id} = {}; } #push(@{$qualifier_hash{$seq_id}}, [$seq_id, $result_term{$term}, $value]); $qualifier_hash{$seq_id}->{$qualifier{$term}} = 1; } else { die \"unrecognized qualifier term\"; } } if ($line =~ /^([^\\s]+)\\s+([^\\s]+)\\s+([^\\s]+)\\s+(\\d+)\\s+(\\d+)/) { my $id = $1; my $model = $2; my $state = $3; my $start = $4; my $end = $5; if (!defined($segment_hash{$id})) { $segment_hash{$id} = []; } push(@{$segment_hash{$id}}, [$id, $model, $state, $start, $end]); } } #print $segment_hash{$id}->[0]->[0]; #die(); foreach my $s(keys(%segment_hash)) { my $seq = $doc->createAndAddSequence($s, $defline, '', 'aa', 'polypeptide'); $doc->createAndAddBsmlAttribute( $seq, 'defline', $defline); $doc->createAndAddSeqDataImport( $seq, 'fasta', $options{fasta_input}, \"sdi_\" . $s . '_seq', $s ); $seq->addBsmlLink('analysis', '#tmhmm_analysis', 'input_of'); foreach my $prop_ref(@{$property_hash{$s}}) { $doc->createAndAddBsmlAttribute($seq, $prop_ref->[1], $prop_ref->[2]); } my $feature_table; $feature_table = $doc->createAndAddFeatureTable($seq); if ($qualifier_hash{$s}->{'n_term_signal'}) { my $new_id = $idgen->next_id( project => $options{project}, type => 'signal_peptide', ); # my $signalp = $doc->createAndAddFeature($feature_table, # $new_id, # '', # 'signal_peptide' # ); # $signalp->addBsmlLink('analysis', '#tmhmm_analysis', 'computed_by'); } ## this makes ID pulling more efficient if ( scalar @{$segment_hash{$s}} ) { $idgen->set_pool_size( located_sequence_feature => scalar @{$segment_hash{$s}} ); } foreach my $tm_ref( @{$segment_hash{$s}} ) { # Currently only dealing with the transmembrane regions (TMhelix) if($tm_ref->[2] eq 'TMhelix') { my $tm = $doc->createAndAddFeature( $feature_table, $idgen->next_id( project => $options{'project'}, #type => 'located_sequence_feature', type => 'transmembrane_region', ), $tm_ref->[2], ## state 'transmembrane_region' ); $tm->addBsmlLink('analysis', '#tmhmm_analysis', 'computed_by'); $tm->addBsmlIntervalLoc( $tm_ref->[3] - 1, ## start $tm_ref->[4], ## end 0 ); } } } ## add the analysis element my $analysis = $doc->createAndAddAnalysis( id => 'tmhmm_analysis', sourcename => $options{'output'}, program => 'tmhmm', algorithm => 'tmhmm', ); ## now write the doc $doc->write($options{'output'},,$gzip); exit(); sub check_parameters { ## required params my @required = qw( input output id_repository ); for ( @required ) { if (! defined $options{$_}) { $logger->logdie( \"$_ is a required option\" ); } } ## make sure input file exists if (! -e $options{'input'}) { unless(-e $options{'input'}.\".gz\") { $options{'input'}.=\".gz\"; } else { pod2usage({-message => \"Input file '$options{'input'}' does not exist!\"}); } } ## make sure the fasta input was provided. (Bug 3781) if($options{'fasta_input'}) { $fastaFile = $options{'fasta_input'}; open(IN, \"$fastaFile\") or pod2usage({-message => \"Could not open fasta_input $fastaFile ($!)\"}); while(<IN>) { chomp; if(/^>(.*)/) { $defline = $1; last; } } close(IN); } else { pod2usage({-message => \"Option fasta_input is required\"}); } ## in case they want to compress the bsml output (bug 2591) if($options{'compress_bsml_output'}) { $gzip = 1; } $options{'project'} = 'unknown' unless ($options{'project'}); $options{'command_id'} = '0' unless ($options{'command_id'}); return 1; } ## parse_position parses the position field to give an array containing ## start [and stop] sites sub parse_position { my ($position) = @_; if ($position =~ /^\\s*([^\\s]+)\\s*$/) { return split(\"-\", $1); } else { return (); } }"
    },
    {
      "tool": "transterm",
      "converter_script": "transterm2bsml.pl",
      "name": "transterm2bsml.pl - turns tranterm raw output to bsml",
      "synopsis": "USAGE: transterm2bsml.pl \n            --input_list=/path/to/some/transterm.raw.list\n            --input_file=/path/to/some/transterm.raw\n            --output=/path/to/transterm.bsml\n            --fasta_input=/path/to/transter.input.fsa\n            --compress_bsml_output=1\n            --id_repository=/path/to/id_repository/\n            --project=aa1\n          [ --log=/path/to/file.log\n            --debug=4\n            --help\n          ]",
      "description": "Creates a bsml document from raw transterm output.  See format for input and of output below.",
      "options": {
        "input_list": "List of input transterm raw files.",
        "input_file": "Input raw transterm file.",
        "output": "Output bsml file. If compress_bsml_output is a non zero value, a .gz will be appended to the end\n    of the filename if it does not already exist.",
        "fasta_input": "The input fasta file used as input to transterm.",
        "compress_bsml_output": "A non zero value will produce gzipped output.",
        "id_repository": "A valid id repository.  See Ergatis::IdGenerator for details."
      },
      "contact": "Kevin Galens kgalens@tigr.org =cut use strict; use warnings; use Getopt::Long qw(:config no_ignore_case no_auto_abbrev pass_through); use Pod::Usage; use BSML::BsmlBuilder; use Ergatis::Logger; use Ergatis::IdGenerator; use Data::Dumper; ####### GLOBALS AND CONSTANTS ########### my @inputFiles; my $project; my $output; my $debug; my $idMaker; my $inputFasta; my $compressOutput; my $defline; ######################################## my %options = (); my $results = GetOptions (\\%options, 'input_list|i=s', 'input_file|f=s', 'fasta_input|a=s', 'compress_bsml_output|c=s', 'output|o=s', 'project|p=s', 'id_repository|d=s', 'log|l=s', 'debug=s', 'help|h') || &_pod; #Setup the logger my $logfile = $options{'log'} || Ergatis::Logger::get_default_logfilename(); my $logger = new Ergatis::Logger('LOG_FILE'=>$logfile, 'LOG_LEVEL'=>$options{'debug'}); $logger = $logger->get_logger(); # Check the options. &check_parameters(\\%options); foreach my $file (@inputFiles) { my $tmp = &parseTranstermData($file); my $data; $data->{$file} = $tmp; my $bsml = &generateBsml($data); $bsml->write($output,'',$compressOutput); } exit(0); ######################## SUB ROUTINES ####################################### sub parseTranstermData { my $file = shift; my $retval; my $seq = \"\"; my $str = \"< $file\"; if(-e $file && $file =~ /\\.gz$/) { $str = \"<:gzip $file\"; } elsif(! -e $file && -e $file.\".gz\") { $str = \"<:gzip $file\"; } open(IN, $str) || &_die(\"Unable to open the transterm raw file $file ($!)\"); while(<IN>) { if(/^SEQUENCE\\s(.*?)\\s.*length\\s(\\d+)/) { $seq = $1; $retval->{$seq}->{'length'} = $2; } elsif(/^\\s+TERM/) { my @tmp = split(/\\s+/); my $strand = 0; #0 means forward strand. my ($start, $stop) = ($tmp[3], $tmp[5]); if($start > $stop) { my $tmpBound = $start; $start = $stop; $stop = $tmpBound; $strand = 1; } $retval->{$seq}->{$tmp[2]}->{'start'} = $start; $retval->{$seq}->{$tmp[2]}->{'stop'} = $stop; $retval->{$seq}->{$tmp[2]}->{'strand'} = $strand; $retval->{$seq}->{$tmp[2]}->{'conf'} = $tmp[8]; $retval->{$seq}->{$tmp[2]}->{'hp'} = $tmp[9]; $retval->{$seq}->{$tmp[2]}->{'tail'} = $tmp[10]; } } close(IN); return $retval; } sub generateBsml { my $data = shift; my $doc = new BSML::BsmlBuilder(); foreach my $file(keys %{$data}) { foreach my $seq(keys %{$data->{$file}}) { #Try to figure out the class my $class = 'sequence'; $class = $1 if($seq =~ /\\w+\\.(\\w+)\\./); my $seqObj = $doc->createAndAddSequence( $seq, $seq, $data->{$seq}->{'length'}, 'dna', $class ); $doc->createAndAddSeqDataImport( $seqObj, 'fasta', $inputFasta, '', $seq ); $doc->createAndAddLink( $seqObj, 'analysis', '#transterm_analysis', 'input_of' ); $doc->createAndAddBsmlAttribute( $seqObj, 'defline', $defline ); my $featTable = $doc->createAndAddFeatureTable($seqObj); #Start adding features to the sequence my ($key, $term); while(($key, $term) = each(%{$data->{$file}->{$seq}})) { next if($key eq 'length'); my $id = $idMaker->next_id( 'type' => 'terminator', 'project' => $project ); my $feat = $doc->createAndAddFeature( $featTable, $id, $id, 'terminator'); $feat->addBsmlLink('analysis', '#transterm_analysis', 'computed_by'); $feat->addBsmlIntervalLoc($data->{$file}->{$seq}->{$key}->{'start'}, $data->{$file}->{$seq}->{$key}->{'stop'}, $data->{$file}->{$seq}->{$key}->{'strand'}); $doc->createAndAddBsmlAttribute( $feat, 'confidence_score', $data->{$file}->{$seq}->{$key}->{'conf'} ); $doc->createAndAddBsmlAttribute( $feat, 'hairpin_score', $data->{$file}->{$seq}->{$key}->{'hp'} ); $doc->createAndAddBsmlAttribute( $feat, 'tail_score', $data->{$file}->{$seq}->{$key}->{'tail'} ); } } $doc->createAndAddAnalysis( 'id' => 'transterm_analysis', 'sourcename' => $file ); } return $doc; } sub check_parameters { my $options = shift; my $error = \"\"; &_pod if($options{'help'}); if($options{'input_list'}) { $error .= \"Option input_list ($options{'input_list'}) does not exist\\n\" unless(-e $options{'input_list'}); open(IN, \"< $options{'input_list'}\") || &_die(\"Unable to open $options{'input_list'} ($!)\"); @inputFiles = <IN>; close(IN); } if($options{'input_file'}) { $error .= \"Option input_file ($options{'input_file'}) does not exist\\n\" unless(-e $options{'input_file'}); push(@inputFiles, $options{'input_file'}); } unless($options{'input_list'} || $options{'input_file'}) { $error .= \"Either option input_list or input_file is required\\n\"; } if($options{'compress_bsml_output'}) { $compressOutput = 1; } else { $compressOutput = 0; } unless($options{'output'}) { $error .= \"Option output is required\\n\"; } else { $output = $options{'output'}; } unless($options{'project'}) { $error .= \"Option project is required\\n\"; } else { $project = $options{'project'}; } unless($options{'id_repository'}) { $error .= \"Option id_repository is required\\n\"; } else { $idMaker = new Ergatis::IdGenerator( 'id_repository' => $options{'id_repository'} ); $idMaker->set_pool_size('terminator' => 25 ); } if($options{'debug'}) { $debug = $options{'debug'}; } if($options{'fasta_input'}) { $inputFasta = $options{'fasta_input'}; unless(-e $inputFasta) { $error .= \"Option fasta_input ($inputFasta) does not exist\\n\"; } else { open(FSA, \"< $inputFasta\") or &_die(\"Unable to open $inputFasta\"); } open(FSA, \"< $inputFasta\") or &_die(\"Unable to open $inputFasta ($!)\"); while(<FSA>) { next unless(/^>(.+)/); $defline = $1; last; } close(FSA); } unless($error eq \"\") { &_die($error); } } sub _pod { pod2usage( {-exitval => 0, -verbose => 2, -output => \\*STDERR} ); } sub _die { my $msg = shift; $logger->logdie($msg); }"
    },
    {
      "tool": "trf",
      "converter_script": "trf2bsml.pl",
      "name": "trf2bsml.pl - convert Tandem Repeat Finder (trf) output to BSML",
      "synopsis": "USAGE: trf2bsml.pl \n            --input=/path/to/somefile.dat \n            --output=/path/to/output.bsml\n            --id_repository=/path/to/valid/id_repository\n           [--fasta_input=/path/to/trf/input.fsa\n            --gzip_output=1\n            --project=aa1 ]",
      "description": "This script is used to convert the output from a RepeatMasker search into BSML.",
      "options": {
        "input": "Input .dat file from a RepeatMasker search.",
        "debug": "Debug level.  Use a large number to turn on verbose debugging.",
        "log": "Log file",
        "output": "Output BSML file (will be created, must not exist)",
        "project": "Project ID.  Used in creating feature ids.  Defaults to 'unknown' if\n    not passed and is unable to parse from input file name.",
        "id_repository": "Used in the generation of ids.",
        "gzip_output": "[OPTIONAL] A non-zero value will result in compressed bsml output.  If there is no .gz extension on\n    the output file name, one will be added.",
        "fasta_input": "[OPTIONAL] The file used as input for the trf run.",
        "help": "This help message"
      },
      "contact": "Joshua Orvis jorvis@tigr.org =cut use strict; use Getopt::Long qw(:config no_ignore_case no_auto_abbrev); use Pod::Usage; use Ergatis::Logger; use Ergatis::IdGenerator; use BSML::BsmlRepository; use BSML::BsmlBuilder; use BSML::BsmlParserTwig; my $defline; my $identifier; my $gzip; my $fasta_input; my $project; my $id_repository; my %options = (); my $results = GetOptions (\\%options, 'input|i=s', 'output|o=s', 'debug|d=s', 'gzip_output|g=s', 'fasta_input|f=s', 'command_id=s', ## passed by workflow 'logconf=s', ## passed by workflow (not used) 'id_repository=s', 'project|p=s', 'log|l=s', 'help|h') || pod2usage(); my $logfile = $options{'log'} || Ergatis::Logger::get_default_logfilename(); my $logger = new Ergatis::Logger('LOG_FILE'=>$logfile, 'LOG_LEVEL'=>$options{'debug'}); $logger = $logger->get_logger(); # display documentation if( $options{'help'} ){ pod2usage( {-exitval=>0, -verbose => 2, -output => \\*STDOUT} ); } ## make sure all passed options are peachy &check_parameters(\\%options); ## we want to create ids unique to this document, which will be replaced later. they must ## contain the prefix that will be used to look up a real id, such as ath1.gen.15 my $next_id = 1; ## we want a new doc my $doc = new BSML::BsmlBuilder(); ## we're going to generate ids my $idcreator = new Ergatis::IdGenerator( 'id_repository' => $id_repository ); my $firstId = $idcreator->next_id( 'project' => $project, 'type' => 'gene'); ## open the input file for parsing open (my $ifh, $options{'input'}) || $logger->logdie(\"can't open input file for reading\"); my %data; my $qry_id; my $parameters; while (<$ifh>) { #check whitespace, no warn next if ( /^\\s*$/ ); ## only the data lines in the output file start with numbers if ( /^\\d/ ) { my @cols = split; ## there should be 15 elements in cols, unless we have an unrecognized format. unless (scalar @cols == 15) { $logger->error(\"the following RepeatMasker line was not recognized and could not be parsed:\\n$_\\n\") if ($logger->is_error); next; } ## add this data row to this sequence push( @{$data{$qry_id}}, \\@cols ); } elsif ( /^Sequence\\:\\s*(.+)\\s*$/ ) { $qry_id = $1; } elsif ( /^Parameters\\:\\s*(.+)\\s*$/ ) { $parameters = $1; } } ## loop through each of the matches that we found if(scalar (keys %data) == 0) { my $seqid = $1 if($defline =~ /(\\S+)/); my $seq = $doc->createAndAddSequence($seqid, undef, '', 'dna', 'assembly'); $seq->addBsmlLink('analysis', '#trf_analysis', 'input_of'); $seq->addBsmlAttr('defline', $defline); $doc->createAndAddSeqDataImport( $seq, 'fasta', $fasta_input, '', $identifier); } for my $seqid (keys %data) { my $bsmlId = $1 if($seqid =~ /^(\\S+)/); my $seq = $doc->createAndAddSequence($bsmlId, undef, '', 'dna', 'assembly'); $seq->addBsmlLink('analysis', '#trf_analysis', 'input_of'); $seq->addBsmlAttr('defline', $defline); $doc->createAndAddSeqDataImport( $seq, 'fasta', $fasta_input, '', $identifier); my $ft = $doc->createAndAddFeatureTable($seq); my $fg; ## loop through each array reference of this key my $repeat; my @elements; foreach my $arr ( @{$data{$seqid}} ) { ## grab an ID my $new_id = $idcreator->next_id( 'project' => $project, 'type' => 'tandem_repeat' ); ## add the repeat $repeat = $doc->createAndAddFeature($ft, $new_id, '', 'tandem_repeat' ); $repeat->addBsmlLink('analysis', '#trf_analysis', 'computed_by'); ## add the location of the repeat (all given by trf as coords are on the forward strand) ## 1 is subtracted from each position to give interbase numbering $repeat->addBsmlIntervalLoc( --$$arr[0], $$arr[1], 0); ## SO terms for these repeats need to be added as Attributes $doc->createAndAddBsmlAttributes( $repeat, 'period_size', $$arr[2], 'copies_aligned', $$arr[3], 'consensus_size', $$arr[4], 'percent_identity', $$arr[5], 'percent_indels', $$arr[6], 'raw_score', $$arr[7], 'percent_a', $$arr[8], 'percent_c', $$arr[9], 'percent_g', $$arr[10], 'percent_t', $$arr[11], 'entropy_score', $$arr[12], 'consensus_text', $$arr[13], 'matched_text', $$arr[14] ); } } ## add the analysis element my $analysis = $doc->createAndAddAnalysis( id => 'trf_analysis', sourcename => $options{'output'}, ); ## now write the doc $doc->write($options{'output'}); exit; sub check_parameters { ## make sure input file exists if (! -e $options{'input'}) { $logger->logdie(\"input file $options{'input'} does not exist\") } ## make sure output file doesn't exist yet if (-e $options{'output'}) { $logger->logdie(\"can't create $options{'output'} because it already exists\") } unless($options{'project'}) { $project = 'unknown'; $project = $1 if($options{'input'} =~ m|.*/([^/.]+)\\.[^/]+$|); } else { $project = $options{'project'}; } $options{'command_id'} = '0' unless ($options{'command_id'}); if($options{'id_repository'}) { $id_repository = $options{'id_repository'}; } else { $logger->logdie(\"Option id_repository is required\"); } if($options{'fasta_input'}) { $fasta_input = $options{'fasta_input'}; open(IN, \"< $fasta_input\") or $logger->logdie(\"Unable to open $fasta_input ($!)\"); while(<IN>) { chomp; if(/^>(.*)/){ $defline = $1; $identifier = $1 if($defline =~ /^([^\\s]+)/); last; } } close(IN); } $gzip = ($options{'gzip_output'}) ? 1 : 0; return 1; }"
    },
    {
      "tool": "twinscan",
      "converter_script": "twinscan2bsml.pl",
      "name": "twinscan2bsml.pl - convert twinscan GTF output to BSML",
      "synopsis": "USAGE: twinscan2bsml.pl \n        --input_file=/path/to/twinscan.raw.file \n        --output=/path/to/output.bsml\n        --project=aa1 \n        --fasta_input=/path/to/somefile.fsa \n        --id_repository=/path/to/repository\n        --sourcename=sourcename\n        --programversion='current'",
      "description": "This script is used to convert the output from a twinscan search into BSML.",
      "options": {
        "input_file": "Input file file from a twinscan run.  -i, --input_list, will take in a list\n    of input files, all of which will be stored in a single output bsml.",
        "output": "Output BSML file (will be created, must not exist)",
        "project": "Project ID.  Used in creating feature ids.",
        "fasta_input": "Needed to create a Seq-data-import element referencing this path.",
        "id_repository": "path to --project's id_repository",
        "programversion": "Version string to be used as value for the analysis attribute 'programversion'",
        "sourcename": "Sourcename string to be used as value for the analysis attribute 'sourcename'\n    Due to a silly hack in analysis2bsml.pl, you might need to put /dummy/dir at\n    the end of it.",
        "log": "Log file",
        "debug": "Debug level.  Use a large number to turn on verbose debugging.",
        "help": "This help message"
      },
      "contact": "Jason Inman jinman@tigr.org =cut use strict; use Getopt::Long qw(:config no_ignore_case no_auto_abbrev); use Pod::Usage; use Ergatis::Logger; use Ergatis::IdGenerator; use BSML::GenePredictionBsml; use Chado::Gene; ### Some globals my @inputFiles; my $project; my $output; my $sourcename; my $idMaker; my $bsml; my $data; my $inputFsa; my $debug; my $length; my $programversion; my %options = (); my $results = GetOptions (\\%options, 'input_list|i=s', 'input_file|f=s', 'output|o=s', 'project|p=s', 'id_repository|r=s', 'fasta_input|a=s', 'sourcename|s=s', 'programversion|v=s', 'log|l=s', 'command_id=s', ## passed by workflow 'logconf=s', ## passed by workflow (not used) 'debug=s', 'help|h') || pod2usage(); my $logfile = $options{'log'} || Ergatis::Logger::get_default_logfilename(); my $logger = new Ergatis::Logger('LOG_FILE'=>$logfile, 'LOG_LEVEL'=>$options{'debug'}); $logger = $logger->get_logger(); # display documentation if( $options{'help'} ){ pod2usage( {-exitval=>0, -verbose => 2, -output => \\*STDOUT} ); } ## make sure all passed options are peachy &check_parameters(\\%options); foreach my $file (@inputFiles) { $data = &parseTwinscanData($file); $bsml = &generateBsml($data); } $bsml->writeBsml($output); exit(0); sub parseTwinscanData { my $inFile = shift; ## open the input file for parsing open (my $ifh, \"< $inFile\") || $logger->logdie(\"Can't open input file for reading\"); my $source_seq_name = ''; my $current_group_name = ''; my $current_transcript_id = ''; my $previous_group_name = ''; my $first_feat_found = 0; my $last_feat_found = 0; my $comp_val; my $min_exon_low; my $max_exon_high; my $genes; my %tmp; my @group_members = (); ## go through the data now while (<$ifh>) { ## skip comment lines next if (/^#/); ## set flag for having found last gene data; $last_feat_found++ if eof($ifh); ## grab/modify a few values for later use chomp; my @cols = split(/\\t/); ## Get the gene id, ignore the transcript id for now. It's simple the ## gene_id . '.1' now, anyway. if ($cols[8] =~ /gene_id \"(\\S+);/) { $current_group_name = $1; } else { $logger->logdie(\"unrecognized format in attributes column: $cols[8]\"); } ## If this is a new gene id AND isn't the first one found, add the previous ## gene to out data hash. if ($current_group_name ne $previous_group_name) { if ($first_feat_found) { &add_group(\\@group_members, $min_exon_low, $max_exon_high, $comp_val, \\$genes, $source_seq_name); } else { $first_feat_found++; } $min_exon_low = ''; $max_exon_high = ''; $comp_val = ''; @group_members = (); # make this group the one to look for: $previous_group_name = $current_group_name; } ## store the source sequence name $source_seq_name = $cols[0]; ## count in interbase: $cols[3]--; ##store complement flas (1 is true, meaining feature lies on reverse strand) $comp_val = ($cols[6] eq '+') ? 0 : 1; ## build our temporary object: # skip start and stop codon entries, as they are pointless for us. unless ($cols[2] =~ /_codon/) { %tmp = ('low' => $cols[3], 'high' => $cols[4], 'comp' => $comp_val ); push @group_members, {%tmp}; } # Adjust the min/max coords for the gene (this will capture the extra three # bases from the stop codon, too, so all we'll have to modify later is the # terminal exon's last position. $min_exon_low = ($min_exon_low eq '') ? $cols[3] : (($min_exon_low < $cols[3] ) ? $min_exon_low : $cols[3] ); $max_exon_high = ($max_exon_high eq '') ? $cols[4] : (($max_exon_high > $cols[4]) ? $max_exon_high : $cols[4] ); ## If this is the last feat in the file, we should add this gene. if ($last_feat_found) { &add_group(\\@group_members, $min_exon_low, $max_exon_high, $comp_val, \\$genes, $source_seq_name); } } return $genes; } sub add_group { my $arr_ref = shift; my @grp_mems = @{$arr_ref}; my ($min, $max, $comp, $genes, $source_seq_name) = @_; ## \"Add\" the stop codon by increasing the terminal exon 3 bases if ($comp) { ${$grp_mems[0]}{'low'} -= 3; } else { ${$grp_mems[-1]}{'high'} += 3; } ## Create a new gene object: my $tmpGene = new Chado::Gene ( $idMaker->next_id( 'type' => 'gene', 'project' => $project ), $min, $max, $comp, $source_seq_name ); ## Add the polypeptide/transcript: foreach my $type( qw( transcript polypeptide ) ) { $tmpGene->addFeature( $idMaker->next_id( 'type' => $type, 'project' => $project ), $min, $max, $comp, $type ); } ## Now add the exons foreach my $feat (@grp_mems) { foreach my $type( qw( exon CDS ) ) { $tmpGene->addFeature( $idMaker->next_id( 'type' => $type, 'project' => $project), $$feat{'low'}, $$feat{'high'}, $$feat{'comp'}, $type ); } } ## Form the group now: my $count = $tmpGene->addToGroup($tmpGene->getId, {'all' => 1}); $logger->logdie(\"Nothing added to group\") unless ($count); push @{$$genes}, $tmpGene; } sub generateBsml { my $data = shift; #Create the document my $doc = new BSML::GenePredictionBsml( 'twinscan', $sourcename, $programversion); foreach my $gene(@{$data}) { $doc->addGene($gene); } my $seqId; open(IN, \"< $inputFsa\") or $logger->logdie(\"Unable to open $inputFsa\"); while(<IN>) { #assume it's a single fasta file if(/^>([^\\s+]+)/) { $seqId = $1; last; } } close(IN); my $addedTo = $doc->setFasta('', $inputFsa); $logger->logdie(\"$seqId was not a sequence associated with the gene\") unless($addedTo); return $doc; } sub check_parameters { my $options = shift; my $error = \"\"; # Check for input file(s) if($options{'input_list'}) { $error .= \"Option input_list ($options{'input_list'}) does not exist\\n\" unless(-e $options{'input_list'}); open(IN, \"< $options{'input_list'}\") || &_die(\"Unable to open $options{'input_list'} ($!)\"); @inputFiles = <IN>; close(IN); } if($options{'input_file'}) { $error .= \"Option input_file ($options{'input_file'}) does not exist\\n\" unless(-e $options{'input_file'}); push(@inputFiles, $options{'input_file'}); } unless($options{'input_list'} || $options{'input_file'}) { $error .= \"Either option input_list or input_file is required\\n\"; } # make sure we got a project unless ($options{'project'}) { $error .= \"Option project is required.\\n\"; } else { $project = $options{'project'}; } # Check for output file unless($options{'output'}) { $error .= \"Option output is required.\\n\"; } else { $output = $options{'output'}; } # Set up the id generator unless($options{'id_repository'}) { $error .= \"Option id_repository is required. Please see Ergatis::IdGenerator \". \"for details.\\n\"; } else { $idMaker = new Ergatis::IdGenerator( 'id_repository' => $options{'id_repository'} ); $idMaker->set_pool_size( 'exon' => 20, 'transcript' => 20, 'gene' => 20, 'polypeptide' => 20, 'CDS' => 20 ); } # Check for input fasta sequence: unless($options{'fasta_input'}) { $error .= \"Option fasta_input is required\\n\"; } else { $error .= \"$options{'fasta_input'} (fasta_input) does not exist\\n\" unless(-e $options{'fasta_input'}); $inputFsa = $options{'fasta_input'}; #Find the length of the sequence open(IN, \"<$options{'fasta_input'}\") or $logger->logdie(\"Can't open $options->{'fasta_input'}\"); my $seq = \"\"; my $curId; while(<IN>) { chomp; if(/^>(\\S+)/) { if(defined($curId)) { $length->{$curId} = length($seq); $seq = \"\"; } $curId = $1; } else { $seq.= $_; } } $length->{$curId} = length($seq); close(IN); } ## get sourcedir for the analysis section: if ($options{'sourcename'}) { $sourcename = $options{'sourcename'}; } else { $error .= \"--sourcename is a required option.\\n\"; } ## get programversion for the analysis section if ($options{'programversion'}) { $programversion = $options{'programversion'}; } else { $programversion = 'current'; } if($options{'debug'}) { $debug = $options{'debug'}; } unless($error eq \"\") { $logger->logdie($error); } }"
    }
  ]
}
